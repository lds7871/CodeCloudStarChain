/*
 Navicat Premium Data Transfer

 Source Server         : ruoyi
 Source Server Type    : MySQL
 Source Server Version : 80039 (8.0.39)
 Source Host           : localhost:3306
 Source Schema         : myxl-bf

 Target Server Type    : MySQL
 Target Server Version : 80039 (8.0.39)
 File Encoding         : 65001

 Date: 25/06/2025 19:10:26
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article_order
-- ----------------------------
DROP TABLE IF EXISTS `article_order`;
CREATE TABLE `article_order`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '订单表的自增id',
  `user_id` int NOT NULL COMMENT '用户标识',
  `art_id` int NOT NULL COMMENT '文章标识',
  `trade_status` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '支付状态',
  `out_trade_no` varchar(2555) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '订单号',
  `total_amount` double NOT NULL COMMENT '交易的金额',
  `gmt_payment` datetime NOT NULL COMMENT '交易的支付时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_order
-- ----------------------------

-- ----------------------------
-- Table structure for chat_msg
-- ----------------------------
DROP TABLE IF EXISTS `chat_msg`;
CREATE TABLE `chat_msg`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `chat_id` bigint NULL DEFAULT NULL,
  `sender_id` bigint NOT NULL COMMENT '发送人id',
  `type` enum('text','image') CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT 'text' COMMENT '消息类型',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '内容',
  `is_recalled` tinyint(1) NULL DEFAULT 0 COMMENT '是否撤回',
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '发送时间',
  `ip` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'ip地址',
  `location` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'ip归属地',
  `file_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '消息是文件时，存的文件名',
  `file_size` double NULL DEFAULT NULL COMMENT '文件大小',
  `duration` int NULL DEFAULT NULL COMMENT '语音时长',
  `reply_id` bigint NULL DEFAULT NULL COMMENT '回复消息id',
  `reply_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '回复消息内容',
  `reply_user_id` bigint NULL DEFAULT NULL COMMENT '回复用户id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '聊天消息' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of chat_msg
-- ----------------------------

-- ----------------------------
-- Table structure for file_detail
-- ----------------------------
DROP TABLE IF EXISTS `file_detail`;
CREATE TABLE `file_detail`  (
  `id` varchar(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '文件id',
  `url` varchar(512) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '文件访问地址',
  `size` bigint NULL DEFAULT NULL COMMENT '文件大小，单位字节',
  `filename` varchar(256) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '文件名称',
  `original_filename` varchar(256) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '原始文件名',
  `base_path` varchar(256) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '基础存储路径',
  `path` varchar(256) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '存储路径',
  `ext` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '文件扩展名',
  `content_type` varchar(128) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT 'MIME类型',
  `platform` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '存储平台',
  `th_url` varchar(512) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '缩略图访问路径',
  `th_filename` varchar(256) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '缩略图名称',
  `th_size` bigint NULL DEFAULT NULL COMMENT '缩略图大小，单位字节',
  `th_content_type` varchar(128) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '缩略图MIME类型',
  `object_id` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '文件所属对象id',
  `object_type` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '文件所属对象类型，例如用户头像，评价图片',
  `metadata` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL COMMENT '文件元数据',
  `user_metadata` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL COMMENT '文件用户元数据',
  `th_metadata` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL COMMENT '缩略图元数据',
  `th_user_metadata` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL COMMENT '缩略图用户元数据',
  `attr` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL COMMENT '附加属性',
  `file_acl` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '文件ACL',
  `th_file_acl` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '缩略图文件ACL',
  `hash_info` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL COMMENT '哈希信息',
  `upload_id` varchar(128) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '上传ID，仅在手动分片上传时使用',
  `upload_status` int NULL DEFAULT NULL COMMENT '上传状态，仅在手动分片上传时使用，1：初始化完成，2：上传完成',
  `source` varchar(25) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '图片来源',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci COMMENT = '文件记录表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of file_detail
-- ----------------------------
INSERT INTO `file_detail` VALUES ('08e7984cb82870531743acdee387980f', 'http://127.0.0.1:8800/localFile/local-plus/20250426/moment/74_猫猫.jpg', 4180665, '74_猫猫.jpg', '猫猫.jpg', 'local-plus/', '20250426/moment/', 'jpg', 'image/jpeg', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"moment\"}', NULL, NULL, '{}', NULL, NULL, 'moment', '2025-04-26 18:49:26');
INSERT INTO `file_detail` VALUES ('123d7135fd74380fb7b4f73ac0bd4984', 'http://127.0.0.1:8800/localFile/local-plus/20250427/default/00_屏幕截图 2025-01-22 004145.png', 651311, '00_屏幕截图 2025-01-22 004145.png', '屏幕截图 2025-01-22 004145.png', 'local-plus/', '20250427/default/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"default\"}', NULL, NULL, '{}', NULL, NULL, 'default', '2025-04-27 17:47:00');
INSERT INTO `file_detail` VALUES ('13885374f3e5045fcd542a152cf968ec', 'http://127.0.0.1:80/localFile/local-plus/20250430/article-cover/21_屏幕截图 2025-04-01 174721.png', 2785, '21_屏幕截图 2025-04-01 174721.png', '屏幕截图 2025-04-01 174721.png', 'local-plus/', '20250430/article-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-cover\"}', NULL, NULL, '{}', NULL, NULL, 'article-cover', '2025-04-30 12:29:09');
INSERT INTO `file_detail` VALUES ('199ba579722ea9e47589688bbe1a77fa', 'http://127.0.0.1:80/localFile/local-plus/20250430/article-cover/09_屏幕截图 2024-12-14 121515.png', 81312, '09_屏幕截图 2024-12-14 121515.png', '屏幕截图 2024-12-14 121515.png', 'local-plus/', '20250430/article-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-cover\"}', NULL, NULL, '{}', NULL, NULL, 'article-cover', '2025-04-30 12:28:09');
INSERT INTO `file_detail` VALUES ('2647bc9c81b6dd4936e4b0d79c041ee6', 'http://127.0.0.1:8800/localFile/local-plus/20250426/moment/72_屏幕截图 2025-04-06 174629.png', 2334668, '72_屏幕截图 2025-04-06 174629.png', '屏幕截图 2025-04-06 174629.png', 'local-plus/', '20250426/moment/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"moment\"}', NULL, NULL, '{}', NULL, NULL, 'moment', '2025-04-26 18:50:09');
INSERT INTO `file_detail` VALUES ('2e2a229072a848cc037f3aba08f4eea8', 'http://127.0.0.1:80/localFile/local-plus/20250430/avatar/45_avatar.jpg', 166191, '45_avatar.jpg', 'avatar.jpg', 'local-plus/', '20250430/avatar/', 'jpg', 'image/jpg', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"avatar\"}', NULL, NULL, '{}', NULL, NULL, 'avatar', '2025-04-30 11:17:29');
INSERT INTO `file_detail` VALUES ('3bd57d990650870db37ae41773aceffa', 'http://127.0.0.1:8800/localFile/local-plus/20250428/article-cover/46_图片6.png', 606974, '46_图片6.png', '图片6.png', 'local-plus/', '20250428/article-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-cover\"}', NULL, NULL, '{}', NULL, NULL, 'article-cover', '2025-04-28 16:41:00');
INSERT INTO `file_detail` VALUES ('3f4dbeeb988ab75a9256a67d190c5321', 'http://127.0.0.1:8800/localFile/local-plus/20250426/article-cover/12_大英博物馆-7.jpg', 966227, '12_大英博物馆-7.jpg', '大英博物馆-7.jpg', 'local-plus/', '20250426/article-cover/', 'jpg', 'image/jpeg', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-cover\"}', NULL, NULL, '{}', NULL, NULL, 'article-cover', '2025-04-26 14:59:50');
INSERT INTO `file_detail` VALUES ('48d745a33046f272d035e78443b630e8', 'http://127.0.0.1:8800/localFile/local-plus/20250426/photo/34_屏幕截图 2025-04-23 144648.png', 669121, '34_屏幕截图 2025-04-23 144648.png', '屏幕截图 2025-04-23 144648.png', 'local-plus/', '20250426/photo/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"photo\"}', NULL, NULL, '{}', NULL, NULL, 'photo', '2025-04-26 21:59:36');
INSERT INTO `file_detail` VALUES ('4b5b5ef2cf0500f231d26cbc1a36028f', 'http://127.0.0.1:8800/localFile/local-plus/20250426/article-cover/92_温馨.jpg', 446164, '92_温馨.jpg', '温馨.jpg', 'local-plus/', '20250426/article-cover/', 'jpg', 'image/jpeg', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-cover\"}', NULL, NULL, '{}', NULL, NULL, 'article-cover', '2025-04-26 14:58:11');
INSERT INTO `file_detail` VALUES ('6438ee1937401d29d20afdeb514f1fe4', 'http://127.0.0.1:8800/localFile/local-plus/20250428/avatar/85_avatar.jpg', 28514, '85_avatar.jpg', 'avatar.jpg', 'local-plus/', '20250428/avatar/', 'jpg', 'image/jpg', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"avatar\"}', NULL, NULL, '{}', NULL, NULL, 'avatar', '2025-04-28 17:54:21');
INSERT INTO `file_detail` VALUES ('65a59589c8bb9045201a459dd90ad6f4', 'http://127.0.0.1:80/localFile/local-plus/20250430/article-cover/84_屏幕截图 2025-04-01 174811.png', 2767, '84_屏幕截图 2025-04-01 174811.png', '屏幕截图 2025-04-01 174811.png', 'local-plus/', '20250430/article-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-cover\"}', NULL, NULL, '{}', NULL, NULL, 'article-cover', '2025-04-30 12:28:24');
INSERT INTO `file_detail` VALUES ('6c3c6846569e0ab91bd0643efd5bab8c', 'http://127.0.0.1:80/localFile/local-plus/20250625/article-cover/19_屏幕截图 2025-06-22 115526.png', 779334, '19_屏幕截图 2025-06-22 115526.png', '屏幕截图 2025-06-22 115526.png', 'local-plus/', '20250625/article-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-cover\"}', NULL, NULL, '{}', NULL, NULL, 'article-cover', '2025-06-25 17:49:23');
INSERT INTO `file_detail` VALUES ('7b5ae22e29690c4ee135a3badac373dd', 'http://127.0.0.1:8800/localFile/local-plus/20250426/album-cover/61_屏幕截图 2025-04-23 152719.png', 847939, '61_屏幕截图 2025-04-23 152719.png', '屏幕截图 2025-04-23 152719.png', 'local-plus/', '20250426/album-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"album-cover\"}', NULL, NULL, '{}', NULL, NULL, 'album-cover', '2025-04-26 21:26:34');
INSERT INTO `file_detail` VALUES ('808f1eb14b1ac970c6825a35cad32f4a', 'http://127.0.0.1:8800/localFile/local-plus/20250426/album-cover/65_屏幕截图 2025-04-23 152719.png', 847939, '65_屏幕截图 2025-04-23 152719.png', '屏幕截图 2025-04-23 152719.png', 'local-plus/', '20250426/album-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"album-cover\"}', NULL, NULL, '{}', NULL, NULL, 'album-cover', '2025-04-26 21:26:43');
INSERT INTO `file_detail` VALUES ('843cb7994379ecd4fddaafc9d3b8170b', 'http://127.0.0.1:80/localFile/local-plus/20250430/album-cover/37_屏幕截图 2025-04-25 130821.png', 43531, '37_屏幕截图 2025-04-25 130821.png', '屏幕截图 2025-04-25 130821.png', 'local-plus/', '20250430/album-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"album-cover\"}', NULL, NULL, '{}', NULL, NULL, 'album-cover', '2025-04-30 12:30:01');
INSERT INTO `file_detail` VALUES ('87d24b97934f900cbff169d0be949111', 'http://127.0.0.1:80/localFile/local-plus/20250529/article-cover/58_f0bcd1046e707daf712e7d0d7f5bbfa2.png', 5354, '58_f0bcd1046e707daf712e7d0d7f5bbfa2.png', 'f0bcd1046e707daf712e7d0d7f5bbfa2.png', 'local-plus/', '20250529/article-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-cover\"}', NULL, NULL, '{}', NULL, NULL, 'article-cover', '2025-05-29 17:28:58');
INSERT INTO `file_detail` VALUES ('8d0498e13ebce150ddc6a164fcd05c1e', 'http://127.0.0.1:80/localFile/local-plus/20250430/moment/50_屏幕截图 2025-03-11 150004.png', 290024, '50_屏幕截图 2025-03-11 150004.png', '屏幕截图 2025-03-11 150004.png', 'local-plus/', '20250430/moment/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"moment\"}', NULL, NULL, '{}', NULL, NULL, 'moment', '2025-04-30 12:30:56');
INSERT INTO `file_detail` VALUES ('8d6768147e9fd61a996aedcc777d55b0', 'http://127.0.0.1:8800/localFile/local-plus/20250426/photo/48_屏幕截图 2025-02-27 192825.png', 1122038, '48_屏幕截图 2025-02-27 192825.png', '屏幕截图 2025-02-27 192825.png', 'local-plus/', '20250426/photo/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"photo\"}', NULL, NULL, '{}', NULL, NULL, 'photo', '2025-04-26 22:00:31');
INSERT INTO `file_detail` VALUES ('954b3a97dcc834c7242716010e0c2c35', 'http://127.0.0.1:80/localFile/local-plus/20250430/avatar/04_avatar.jpg', 155167, '04_avatar.jpg', 'avatar.jpg', 'local-plus/', '20250430/avatar/', 'jpg', 'image/jpg', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"avatar\"}', NULL, NULL, '{}', NULL, NULL, 'avatar', '2025-04-30 11:17:55');
INSERT INTO `file_detail` VALUES ('98b5ee329c70f2356d5cdfb99cef8e9c', 'http://127.0.0.1:80/localFile/local-plus/20250430/album-cover/22_屏幕截图 2025-04-09 120720.png', 194331, '22_屏幕截图 2025-04-09 120720.png', '屏幕截图 2025-04-09 120720.png', 'local-plus/', '20250430/album-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"album-cover\"}', NULL, NULL, '{}', NULL, NULL, 'album-cover', '2025-04-30 12:29:53');
INSERT INTO `file_detail` VALUES ('9ce3714af0d37ffc01c8ecac34fef82d', 'http://127.0.0.1:80/localFile/local-plus/20250430/album-cover/83_屏幕截图 2024-11-20 192511.png', 4521816, '83_屏幕截图 2024-11-20 192511.png', '屏幕截图 2024-11-20 192511.png', 'local-plus/', '20250430/album-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"album-cover\"}', NULL, NULL, '{}', NULL, NULL, 'album-cover', '2025-04-30 12:30:14');
INSERT INTO `file_detail` VALUES ('a166ce2d2ce6e81f007c3c86dfe74632', 'http://127.0.0.1:8800/localFile/local-plus/20250427/default/91_屏幕截图 2025-04-14 224717.png', 969224, '91_屏幕截图 2025-04-14 224717.png', '屏幕截图 2025-04-14 224717.png', 'local-plus/', '20250427/default/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"default\"}', NULL, NULL, '{}', NULL, NULL, 'default', '2025-04-27 17:46:57');
INSERT INTO `file_detail` VALUES ('a2adaf1428f6a927ccd227de6ca2aa3d', 'http://127.0.0.1:80/localFile/local-plus/20250430/moment/16_屏幕截图 2025-04-07 140204.png', 5657, '16_屏幕截图 2025-04-07 140204.png', '屏幕截图 2025-04-07 140204.png', 'local-plus/', '20250430/moment/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"moment\"}', NULL, NULL, '{}', NULL, NULL, 'moment', '2025-04-30 12:30:44');
INSERT INTO `file_detail` VALUES ('aeb2f9e8225d96fe171d47ed4e8e508e', 'http://127.0.0.1:8800/localFile/local-plus/20250428/article-content/75_preview.png', 398828, '75_preview.png', 'preview.png', 'local-plus/', '20250428/article-content/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-content\"}', NULL, NULL, '{}', NULL, NULL, 'article-content', '2025-04-28 18:07:18');
INSERT INTO `file_detail` VALUES ('b314eb3eb2d4a4f2976dc30390f903d9', 'http://127.0.0.1:80/localFile/local-plus/20250430/article-cover/34_屏幕截图 2025-04-01 180541.png', 9878, '34_屏幕截图 2025-04-01 180541.png', '屏幕截图 2025-04-01 180541.png', 'local-plus/', '20250430/article-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-cover\"}', NULL, NULL, '{}', NULL, NULL, 'article-cover', '2025-04-30 12:29:29');
INSERT INTO `file_detail` VALUES ('d4a30f963d554a8854fa5f2a869bc15b', 'http://127.0.0.1:80/localFile/local-plus/20250430/moment/07_屏幕截图 2025-04-08 154813.png', 370074, '07_屏幕截图 2025-04-08 154813.png', '屏幕截图 2025-04-08 154813.png', 'local-plus/', '20250430/moment/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"moment\"}', NULL, NULL, '{}', NULL, NULL, 'moment', '2025-04-30 12:30:35');
INSERT INTO `file_detail` VALUES ('e8f225ab79c1dbc08d0138fbac0fbf0d', 'http://127.0.0.1:80/localFile/local-plus/20250430/article-cover/70_屏幕截图 2025-04-01 174721.png', 2785, '70_屏幕截图 2025-04-01 174721.png', '屏幕截图 2025-04-01 174721.png', 'local-plus/', '20250430/article-cover/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-cover\"}', NULL, NULL, '{}', NULL, NULL, 'article-cover', '2025-04-30 12:28:42');
INSERT INTO `file_detail` VALUES ('e9478115aae4150753e14f3d703e5c4c', 'http://127.0.0.1:8800/localFile/local-plus/20250428/article-cover/91_2.jpg', 15688, '91_2.jpg', '2.jpg', 'local-plus/', '20250428/article-cover/', 'jpg', 'image/jpeg', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"article-cover\"}', NULL, NULL, '{}', NULL, NULL, 'article-cover', '2025-04-28 16:04:02');
INSERT INTO `file_detail` VALUES ('f8b625d7fd1f847c597390818075b82d', 'http://127.0.0.1:8800/localFile/local-plus/20250426/photo/12_屏幕截图 2024-10-09 124341.png', 982346, '12_屏幕截图 2024-10-09 124341.png', '屏幕截图 2024-10-09 124341.png', 'local-plus/', '20250426/photo/', 'png', 'image/png', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"photo\"}', NULL, NULL, '{}', NULL, NULL, 'photo', '2025-04-26 22:07:44');
INSERT INTO `file_detail` VALUES ('fc47601f2d8ebdd771af7c0022efb999', 'http://127.0.0.1:8800/localFile/local-plus/20250427/default/30_艾丝妲.jpg', 204814, '30_艾丝妲.jpg', '艾丝妲.jpg', 'local-plus/', '20250427/default/', 'jpg', 'image/jpeg', 'local', NULL, NULL, NULL, NULL, NULL, NULL, '{}', '{}', '{}', '{}', '{\"source\":\"default\"}', NULL, NULL, '{}', NULL, NULL, 'default', '2025-04-27 17:46:01');

-- ----------------------------
-- Table structure for file_part_detail
-- ----------------------------
DROP TABLE IF EXISTS `file_part_detail`;
CREATE TABLE `file_part_detail`  (
  `id` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '分片id',
  `platform` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '存储平台',
  `upload_id` varchar(128) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '上传ID，仅在手动分片上传时使用',
  `e_tag` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '分片 ETag',
  `part_number` int NULL DEFAULT NULL COMMENT '分片号。每一个上传的分片都有一个分片号，一般情况下取值范围是1~10000',
  `part_size` bigint NULL DEFAULT NULL COMMENT '文件大小，单位字节',
  `hash_info` text CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL COMMENT '哈希信息',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci COMMENT = '文件分片信息表，仅在手动分片上传时使用' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of file_part_detail
-- ----------------------------

-- ----------------------------
-- Table structure for gen_table
-- ----------------------------
DROP TABLE IF EXISTS `gen_table`;
CREATE TABLE `gen_table`  (
  `table_id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',
  `table_name` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '' COMMENT '表名称',
  `table_comment` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '' COMMENT '表描述',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`table_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 23 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '代码生成业务表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of gen_table
-- ----------------------------
INSERT INTO `gen_table` VALUES (16, 'sys_tag', '标签表', '2024-12-22 10:38:49', NULL);
INSERT INTO `gen_table` VALUES (17, 'sys_web_config', '网站配置表', '2024-12-22 11:55:59', NULL);
INSERT INTO `gen_table` VALUES (18, 'sys_article', '文章标签关联表', '2024-12-22 12:20:29', '2024-12-25 14:32:51');
INSERT INTO `gen_table` VALUES (19, 'sys_category', '分类表', '2024-12-22 13:22:38', NULL);
INSERT INTO `gen_table` VALUES (20, 'sys_friend', '友情链接', '2024-12-22 13:57:02', NULL);

-- ----------------------------
-- Table structure for gen_table_column
-- ----------------------------
DROP TABLE IF EXISTS `gen_table_column`;
CREATE TABLE `gen_table_column`  (
  `column_id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',
  `table_id` bigint NOT NULL COMMENT '归属表编号',
  `column_name` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '列名称',
  `column_comment` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '列描述',
  `column_type` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '列类型',
  `java_type` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'JAVA类型',
  `java_field` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'JAVA字段名',
  `is_pk` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '是否主键（1是）',
  `is_required` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '是否必填（1是）',
  `is_insert` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '是否为插入字段（1是）',
  `is_edit` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '是否编辑字段（1是）',
  `is_list` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '是否列表字段（1是）',
  `is_query` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '是否查询字段（1是）',
  `query_type` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT 'EQ' COMMENT '查询方式（等于、不等于、大于、小于、范围）',
  `html_type` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '显示类型（文本框、文本域、下拉框、复选框、单选框、日期控件）',
  `sort` int NULL DEFAULT NULL COMMENT '排序',
  PRIMARY KEY (`column_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 263 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '代码生成业务表字段' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of gen_table_column
-- ----------------------------
INSERT INTO `gen_table_column` VALUES (178, 16, 'id', '主键', 'int', 'Integer', 'id', '1', '1', '1', '1', '1', '1', 'EQ', 'input', 1);
INSERT INTO `gen_table_column` VALUES (179, 16, 'name', '名称', 'varchar', 'String', 'name', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 2);
INSERT INTO `gen_table_column` VALUES (180, 16, 'sort', '排序', 'int', 'Integer', 'sort', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 3);
INSERT INTO `gen_table_column` VALUES (181, 16, 'create_time', '创建时间', 'datetime', 'Date', 'createTime', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 4);
INSERT INTO `gen_table_column` VALUES (182, 16, 'update_time', '更新时间', 'datetime', 'Date', 'updateTime', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 5);
INSERT INTO `gen_table_column` VALUES (183, 17, 'id', '主键', 'bigint', 'Long', 'id', '1', '1', '1', '1', '1', '1', 'EQ', 'input', 1);
INSERT INTO `gen_table_column` VALUES (184, 17, 'logo', 'logo(文件UID)', 'varchar', 'String', 'logo', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 2);
INSERT INTO `gen_table_column` VALUES (185, 17, 'name', '网站名称', 'varchar', 'String', 'name', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 3);
INSERT INTO `gen_table_column` VALUES (186, 17, 'summary', '介绍', 'varchar', 'String', 'summary', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 4);
INSERT INTO `gen_table_column` VALUES (187, 17, 'record_num', '备案号', 'varchar', 'String', 'recordNum', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 5);
INSERT INTO `gen_table_column` VALUES (188, 17, 'web_url', '网站地址', 'varchar', 'String', 'webUrl', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 6);
INSERT INTO `gen_table_column` VALUES (189, 17, 'author', '作者', 'varchar', 'String', 'author', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 7);
INSERT INTO `gen_table_column` VALUES (190, 17, 'author_info', '个性签名', 'varchar', 'String', 'authorInfo', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 8);
INSERT INTO `gen_table_column` VALUES (191, 17, 'author_avatar', '作者头像', 'varchar', 'String', 'authorAvatar', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 9);
INSERT INTO `gen_table_column` VALUES (192, 17, 'ali_pay', '支付宝收款码', 'varchar', 'String', 'aliPay', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 10);
INSERT INTO `gen_table_column` VALUES (193, 17, 'weixin_pay', '微信收款码', 'varchar', 'String', 'weixinPay', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 11);
INSERT INTO `gen_table_column` VALUES (194, 17, 'github', 'github地址', 'varchar', 'String', 'github', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 12);
INSERT INTO `gen_table_column` VALUES (195, 17, 'gitee', 'gitee地址', 'varchar', 'String', 'gitee', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 13);
INSERT INTO `gen_table_column` VALUES (196, 17, 'qq_number', 'QQ号', 'varchar', 'String', 'qqNumber', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 14);
INSERT INTO `gen_table_column` VALUES (197, 17, 'qq_group', 'QQ群', 'varchar', 'String', 'qqGroup', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 15);
INSERT INTO `gen_table_column` VALUES (198, 17, 'email', '邮箱', 'varchar', 'String', 'email', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 16);
INSERT INTO `gen_table_column` VALUES (199, 17, 'wechat', '微信', 'varchar', 'String', 'wechat', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 17);
INSERT INTO `gen_table_column` VALUES (200, 17, 'show_list', '显示的列表（用于控制邮箱、QQ、QQ群、Github、Gitee、微信是否显示在前端）', 'varchar', 'String', 'showList', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 18);
INSERT INTO `gen_table_column` VALUES (201, 17, 'login_type_list', '登录方式列表（用于控制前端登录方式，如账号密码,码云,Github,QQ,微信）', 'varchar', 'String', 'loginTypeList', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 19);
INSERT INTO `gen_table_column` VALUES (202, 17, 'open_comment', '是否开启评论(0:否 1:是)', 'tinyint', 'Integer', 'openComment', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 20);
INSERT INTO `gen_table_column` VALUES (203, 17, 'open_admiration', '是否开启赞赏(0:否， 1:是)', 'tinyint', 'Integer', 'openAdmiration', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 21);
INSERT INTO `gen_table_column` VALUES (204, 17, 'tourist_avatar', '游客头像', 'varchar', 'String', 'touristAvatar', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 22);
INSERT INTO `gen_table_column` VALUES (205, 17, 'bulletin', '公告', 'varchar', 'String', 'bulletin', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 23);
INSERT INTO `gen_table_column` VALUES (206, 17, 'about_me', '关于我', 'mediumtext', 'String', 'aboutMe', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 24);
INSERT INTO `gen_table_column` VALUES (207, 17, 'create_time', '创建时间', 'datetime', 'Date', 'createTime', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 25);
INSERT INTO `gen_table_column` VALUES (208, 17, 'update_time', '更新时间', 'datetime', 'Date', 'updateTime', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 26);
INSERT INTO `gen_table_column` VALUES (209, 18, 'id', '主键id', 'bigint', 'Long', 'id', NULL, '1', '1', '1', '1', '1', 'EQ', 'input', 1);
INSERT INTO `gen_table_column` VALUES (210, 18, 'user_id', '用户id', 'int', 'Integer', 'userId', NULL, '1', '1', '1', '1', '1', 'EQ', 'input', 2);
INSERT INTO `gen_table_column` VALUES (211, 18, 'category_id', '分类id', 'bigint', 'Long', 'categoryId', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 3);
INSERT INTO `gen_table_column` VALUES (212, 18, 'title', '文章标题', 'varchar', 'String', 'title', NULL, '1', '1', '1', '1', '1', 'EQ', 'input', 4);
INSERT INTO `gen_table_column` VALUES (213, 18, 'cover', '文章封面地址', 'varchar', 'String', 'cover', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 5);
INSERT INTO `gen_table_column` VALUES (214, 18, 'summary', '文章简介', 'varchar', 'String', 'summary', NULL, '1', '1', '1', '1', '1', 'EQ', 'input', 6);
INSERT INTO `gen_table_column` VALUES (215, 18, 'content', '文章内容', 'mediumtext', 'String', 'content', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 7);
INSERT INTO `gen_table_column` VALUES (216, 18, 'content_md', '文章内容md格式', 'mediumtext', 'String', 'contentMd', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 8);
INSERT INTO `gen_table_column` VALUES (217, 18, 'read_type', '阅读方式 0无需验证 1：评论阅读 2：点赞阅读 3：扫码阅读', 'int', 'Integer', 'readType', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 9);
INSERT INTO `gen_table_column` VALUES (218, 18, 'is_stick', '是否置顶 0否 1是', 'int', 'Integer', 'isStick', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 10);
INSERT INTO `gen_table_column` VALUES (219, 18, 'is_publish', '是否发布 0：下架 1：发布', 'int', 'Integer', 'isPublish', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 11);
INSERT INTO `gen_table_column` VALUES (220, 18, 'is_original', '是否原创  0：转载 1:原创', 'int', 'Integer', 'isOriginal', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 12);
INSERT INTO `gen_table_column` VALUES (221, 18, 'is_carousel', '是否首页轮播', 'int', 'Integer', 'isCarousel', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 13);
INSERT INTO `gen_table_column` VALUES (222, 18, 'is_recommend', '是否推荐', 'int', 'Integer', 'isRecommend', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 14);
INSERT INTO `gen_table_column` VALUES (223, 18, 'original_url', '转载地址', 'varchar', 'String', 'originalUrl', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 15);
INSERT INTO `gen_table_column` VALUES (224, 18, 'quantity', '文章阅读量', 'bigint', 'Long', 'quantity', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 16);
INSERT INTO `gen_table_column` VALUES (225, 18, 'keywords', '关键词', 'varchar', 'String', 'keywords', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 17);
INSERT INTO `gen_table_column` VALUES (226, 18, 'create_time', '创建时间', 'datetime', 'Date', 'createTime', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 18);
INSERT INTO `gen_table_column` VALUES (227, 18, 'update_time', '修改时间', 'datetime', 'Date', 'updateTime', NULL, '0', '1', '1', '1', '1', 'EQ', 'input', 19);
INSERT INTO `gen_table_column` VALUES (228, 19, 'id', '主键', 'int', 'Integer', 'id', '1', '1', '1', '1', '1', '1', 'EQ', 'input', 1);
INSERT INTO `gen_table_column` VALUES (229, 19, 'name', '名称', 'varchar', 'String', 'name', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 2);
INSERT INTO `gen_table_column` VALUES (230, 19, 'sort', '排序', 'int', 'Integer', 'sort', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 3);
INSERT INTO `gen_table_column` VALUES (231, 19, 'create_time', '创建时间', 'datetime', 'Date', 'createTime', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 4);
INSERT INTO `gen_table_column` VALUES (232, 19, 'update_time', '更新时间', 'datetime', 'Date', 'updateTime', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 5);
INSERT INTO `gen_table_column` VALUES (233, 20, 'id', '主键ID', 'int', 'Integer', 'id', '1', '1', '1', '1', '1', '1', 'EQ', 'input', 1);
INSERT INTO `gen_table_column` VALUES (234, 20, 'name', '网站名称', 'varchar', 'String', 'name', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 2);
INSERT INTO `gen_table_column` VALUES (235, 20, 'url', '网站地址', 'varchar', 'String', 'url', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 3);
INSERT INTO `gen_table_column` VALUES (236, 20, 'avatar', '网站头像地址', 'varchar', 'String', 'avatar', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 4);
INSERT INTO `gen_table_column` VALUES (237, 20, 'info', '网站描述', 'varchar', 'String', 'info', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 5);
INSERT INTO `gen_table_column` VALUES (238, 20, 'email', '邮箱', 'varchar', 'String', 'email', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 6);
INSERT INTO `gen_table_column` VALUES (239, 20, 'sort', '排序', 'int', 'Integer', 'sort', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 7);
INSERT INTO `gen_table_column` VALUES (240, 20, 'reason', '下架原因', 'varchar', 'String', 'reason', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 8);
INSERT INTO `gen_table_column` VALUES (241, 20, 'status', 'ENUM-状态:\"0,下架;1,申请;2:上架\"', 'int', 'Integer', 'status', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 9);
INSERT INTO `gen_table_column` VALUES (242, 20, 'create_time', '创建时间', 'datetime', 'Date', 'createTime', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 10);
INSERT INTO `gen_table_column` VALUES (243, 20, 'update_time', '修改时间', 'datetime', 'Date', 'updateTime', '0', '0', '1', '1', '1', '1', 'EQ', 'input', 11);

-- ----------------------------
-- Table structure for gitee_info
-- ----------------------------
DROP TABLE IF EXISTS `gitee_info`;
CREATE TABLE `gitee_info`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'gitee用户标识',
  `unique_id` bigint NOT NULL COMMENT 'gitee的标识',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'gitee的用户名',
  `avatar_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '头像',
  `created_at` datetime NOT NULL COMMENT '创建时间',
  `updated_at` datetime NOT NULL COMMENT '更新时间',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱',
  `mobile` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '手机号',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'ip',
  `ip_location` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'ip地址',
  `os` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '操作系统',
  `last_login_time` datetime NULL DEFAULT NULL COMMENT '最后的登录时间',
  `browser` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '浏览器引擎',
  `role_id` int NOT NULL DEFAULT 15 COMMENT '角色',
  `signature` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '签名',
  `token` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `balance` int NOT NULL DEFAULT 0 COMMENT '账户余额',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of gitee_info
-- ----------------------------
INSERT INTO `gitee_info` VALUES (2, 13301976, 'icw', 'https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIZmpjibvlwshS7GAWbEjEibsylzByOV1mIZ0eGq4F0caZnicj0YUOuKvofbMI8sXyxmyKDo7xUjFraVNOKYoUPh7lKHA5KDqDzO24GF5Tfe2Vvg/132', '2023-08-10 14:17:15', '2025-04-28 15:54:32', '2180323848@qq.com', NULL, '27.148.48.195', '中国|福建省|福州市|电信', 'Linux', '2025-05-29 17:47:58', 'Chrome', 1, NULL, NULL, 1);
INSERT INTO `gitee_info` VALUES (4, 14330592, '布朗尼', 'https://foruda.gitee.com/avatar/1745982662939962362/14330592_brony_1745982662.png', '2024-04-21 13:13:31', '2025-04-30 11:11:02', NULL, NULL, '140.224.63.55', '中国|福建省|泉州市|电信', 'Windows', '2025-05-10 13:28:03', 'Chrome', 15, NULL, NULL, 0);
INSERT INTO `gitee_info` VALUES (5, 14698172, '00FF00HEAD', 'https://gitee.com/assets/no_portrait.png', '2024-07-17 12:56:49', '2025-04-30 11:35:29', NULL, NULL, '192.168.145.99', '内网IP|内网IP', 'Windows', '2025-04-30 12:24:53', 'Chrome', 15, NULL, NULL, 0);

-- ----------------------------
-- Table structure for qrtz_job_details
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_job_details`;
CREATE TABLE `qrtz_job_details`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `JOB_NAME` varchar(190) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `JOB_GROUP` varchar(190) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `DESCRIPTION` varchar(250) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `JOB_CLASS_NAME` varchar(250) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `IS_DURABLE` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `IS_NONCONCURRENT` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `IS_UPDATE_DATA` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `REQUESTS_RECOVERY` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `JOB_DATA` blob NULL,
  PRIMARY KEY (`SCHED_NAME`, `JOB_NAME`, `JOB_GROUP`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of qrtz_job_details
-- ----------------------------

-- ----------------------------
-- Table structure for qrtz_triggers
-- ----------------------------
DROP TABLE IF EXISTS `qrtz_triggers`;
CREATE TABLE `qrtz_triggers`  (
  `SCHED_NAME` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `TRIGGER_NAME` varchar(190) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `TRIGGER_GROUP` varchar(190) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `JOB_NAME` varchar(190) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `JOB_GROUP` varchar(190) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `DESCRIPTION` varchar(250) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `NEXT_FIRE_TIME` bigint NULL DEFAULT NULL,
  `PREV_FIRE_TIME` bigint NULL DEFAULT NULL,
  `PRIORITY` int NULL DEFAULT NULL,
  `TRIGGER_STATE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `TRIGGER_TYPE` varchar(8) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `START_TIME` bigint NOT NULL,
  `END_TIME` bigint NULL DEFAULT NULL,
  `CALENDAR_NAME` varchar(190) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `MISFIRE_INSTR` smallint NULL DEFAULT NULL,
  `JOB_DATA` blob NULL,
  PRIMARY KEY (`SCHED_NAME`, `TRIGGER_NAME`, `TRIGGER_GROUP`) USING BTREE,
  INDEX `SCHED_NAME`(`SCHED_NAME` ASC, `JOB_NAME` ASC, `JOB_GROUP` ASC) USING BTREE,
  CONSTRAINT `qrtz_triggers_ibfk_1` FOREIGN KEY (`SCHED_NAME`, `JOB_NAME`, `JOB_GROUP`) REFERENCES `qrtz_job_details` (`SCHED_NAME`, `JOB_NAME`, `JOB_GROUP`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of qrtz_triggers
-- ----------------------------

-- ----------------------------
-- Table structure for sys_album
-- ----------------------------
DROP TABLE IF EXISTS `sys_album`;
CREATE TABLE `sys_album`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '相册名',
  `description` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '相册描述',
  `cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '封面URL',
  `is_lock` int NULL DEFAULT 0 COMMENT '是否加密 0：否 1：是',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '密码',
  `sort` int NULL DEFAULT NULL COMMENT '排序',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '相册' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_album
-- ----------------------------
INSERT INTO `sys_album` VALUES (6, 'bug', '', 'http://127.0.0.1:80/localFile/local-plus/20250430/album-cover/22_屏幕截图 2025-04-09 120720.png', 0, '', NULL, '2025-04-26 21:26:54');
INSERT INTO `sys_album` VALUES (7, 'ping', '', 'http://127.0.0.1:80/localFile/local-plus/20250430/album-cover/37_屏幕截图 2025-04-25 130821.png', 0, '', NULL, '2025-04-26 21:27:14');
INSERT INTO `sys_album` VALUES (8, '221', '', 'http://127.0.0.1:80/localFile/local-plus/20250430/album-cover/83_屏幕截图 2024-11-20 192511.png', 0, '', NULL, '2025-04-26 21:27:59');

-- ----------------------------
-- Table structure for sys_article
-- ----------------------------
DROP TABLE IF EXISTS `sys_article`;
CREATE TABLE `sys_article`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `user_id` int NOT NULL COMMENT '用户id',
  `category_id` bigint NULL DEFAULT 0 COMMENT '分类id',
  `title` varchar(150) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '文章标题',
  `cover` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章封面地址',
  `summary` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '文章简介',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '文章内容',
  `content_md` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '文章内容md格式',
  `read_type` int NULL DEFAULT 1 COMMENT '阅读方式 0无需验证 1：评论阅读 2：点赞阅读 3：扫码阅读',
  `is_stick` int NULL DEFAULT 0 COMMENT '是否置顶 0否 1是',
  `status` int NULL DEFAULT 0 COMMENT '状态 0：下架 1：发布',
  `is_original` int NULL DEFAULT 1 COMMENT '是否原创  0：转载 1:原创',
  `is_carousel` int NULL DEFAULT 0 COMMENT '是否首页轮播',
  `is_recommend` int NULL DEFAULT 0 COMMENT '是否推荐',
  `original_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '转载地址',
  `quantity` bigint NULL DEFAULT 0 COMMENT '文章阅读量',
  `keywords` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '关键词',
  `ai_describe` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT 'Ai生成的简短描述',
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `user_id`(`user_id` ASC) USING BTREE,
  FULLTEXT INDEX `title`(`title`) WITH PARSER `ngram`
) ENGINE = InnoDB AUTO_INCREMENT = 337 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '博客文章表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_article
-- ----------------------------
INSERT INTO `sys_article` VALUES (292, 1, 20, '个人开发的管理系统  Neat-Admin', 'img/Neat-Admin 管理系统.png', '基于vue3+typescript+elmentui-plus开发的一款后台管理系统，功能跟若依差不多，主要不同的是样式美化，要比若依更漂亮', '<h4><a id=\"_0\"></a>前言</h4>\r\n<p>本后台管理系统基于当下前沿的技术栈 vue3、typescript 以及 elementui-plus 进行精心构建。在功能维度上，其与若依系统具备相当的完整性与丰富度，涵盖了诸如用户管理、权限控制、数据统计分析、业务流程处理等一系列核心后台管理功能模块，能够高效地支撑各类企业级业务运营需求。然而，本系统在视觉呈现方面展现出独特的优势，通过对样式的深度美化与精心雕琢，采用了更为先进的 UI 设计理念与精细化的布局策略，运用精致的色彩搭配、优雅的字体选择以及灵动的交互元素设计，使其整体视觉效果相较于若依更为美观、精致且专业，能够为用户带来更舒适、高效且具品质感的操作体验，极大地提升了后台管理工作的愉悦度与便捷性，彰显出卓越的专业性与高端品质形象。</p>\r\n<h4><a id=\"_4\"></a>视频预览</h4>\r\n<p><video height=\"100%\" width=\"100%\" src=\"http://127.0.0.1:8800/localFile/local-plus/upload/20241120_230652.mp4\" controls autoplay></video></p>\r\n<h4><a id=\"_8\"></a>仓库地址</h4>\r\n<p><a href=\"https://gitee.com/quequnlong/vue-neat-admin\" target=\"_blank\">Neat-Admin</a></p>\r\n', '#### 前言\r\n\r\n  本后台管理系统基于当下前沿的技术栈 vue3、typescript 以及 elementui-plus 进行精心构建。在功能维度上，其与若依系统具备相当的完整性与丰富度，涵盖了诸如用户管理、权限控制、数据统计分析、业务流程处理等一系列核心后台管理功能模块，能够高效地支撑各类企业级业务运营需求。然而，本系统在视觉呈现方面展现出独特的优势，通过对样式的深度美化与精心雕琢，采用了更为先进的 UI 设计理念与精细化的布局策略，运用精致的色彩搭配、优雅的字体选择以及灵动的交互元素设计，使其整体视觉效果相较于若依更为美观、精致且专业，能够为用户带来更舒适、高效且具品质感的操作体验，极大地提升了后台管理工作的愉悦度与便捷性，彰显出卓越的专业性与高端品质形象。\r\n  \r\n  #### 视频预览\r\n    <video height=100% width=100% src=\"http://127.0.0.1:8800/localFile/local-plus/upload/20241120_230652.mp4\" controls autoplay></video>\r\n  \r\n  \r\n  #### 仓库地址\r\n  [Neat-Admin](https://gitee.com/quequnlong/vue-neat-admin)', 1, 0, 1, 1, 1, 0, NULL, 1, NULL, NULL, '2024-11-27 22:05:36', '2024-12-27 04:00:00');
INSERT INTO `sys_article` VALUES (296, 1, 17, 'SpringBoot 3 集成 Sa-Token 实现权限相关功能', 'img/SpringBoot 3 集成 Sa-Token 实现权限相关功能.png', 'SpringBoot 3 集成 Sa-Token 实现权限相关功能', '<h2><a id=\"1SaToken__content_views_0\"></a>1、Sa-Token 介绍 {#content_views}</h2>\n<h3><a id=\"11_SaToken_httpssatokencchttpssatokencc_httpssatokencc_3\"></a>1.1 Sa-Token 开发文档：<a href=\"https://sa-token.cc/\" title=\"https://sa-token.cc\" target=\"_blank\">https://sa-token.cc</a></h3>\n<h3><a id=\"12_SaToken__Java____OAuth20___5\"></a><strong>1.2 Sa-Token</strong> 是一个轻量级 Java 权限认证框架，主要解决：<strong>登录认证</strong> 、<strong>权限认证</strong> 、<strong>单点登录</strong> 、<strong>OAuth2.0</strong> 、<strong>微服务鉴权</strong> 等一系列权限相关问题。</h3>\n<h3><a id=\"13_httpsiblogcsdnimgcnblog_migrate61de5b4e66af7c02266d67e618c86dd9png_7\"></a>1.3 功能结构图<img src=\"https://i-blog.csdnimg.cn/blog_migrate/61de5b4e66af7c02266d67e618c86dd9.png\" alt=\"\" /></h3>\n<h2><a id=\"2_SpringBoot_3__SaToken_9\"></a>2、 SpringBoot 3 集成 Sa-Token</h2>\n<h3><a id=\"21_Maven_12\"></a><strong>2.1 Maven</strong></h3>\n<pre><div class=\"hljs\"><code class=\"lang-XML\"><span class=\"hljs-comment\">&lt;!-- Sa-Token --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>cn.dev33<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sa-token-spring-boot3-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.38.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Sa-Token 集成 jwt --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>cn.dev33<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sa-token-jwt<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.38.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Sa-Token 集成 redis， 并使用 jackson 序列化 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>cn.dev33<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sa-token-redis-jackson<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.38.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 提供Redis连接池 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.apache.commons<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>commons-pool2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- fastjson2 处理 json 数据 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.fastjson2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>fastjson2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.0.48<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 使用 springdoc 生成 swagger 文档  --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springdoc<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.mysql<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>mysql-connector-j<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>8.3.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- mybatis-plus-boot-starter 中 mybatis-spring 版本不够，排除之后引入新版本 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.baomidou<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.5.6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">exclusions</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">exclusion</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.mybatis<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>mybatis-spring<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">exclusion</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">exclusions</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.mybatis<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>mybatis-spring<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.0.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<h3><a id=\"22_yml__satoken_87\"></a>2.2 yml 配置 sa-token</h3>\n<pre><div class=\"hljs\"><code class=\"lang-java\">server:\n  port: <span class=\"hljs-number\">8080</span>\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql:<span class=\"hljs-comment\">//localhost:3306/xxx</span>\n    username: xxx\n    password: xxx\n  data:\n    redis:\n      database: <span class=\"hljs-number\">1</span>\n\nsa-token:\n  token-name: X-Token\n  # token有效期，单位s 默认<span class=\"hljs-number\">30</span>天, -<span class=\"hljs-number\">1</span>代表永不过期\n  timeout: -<span class=\"hljs-number\">1</span>\n  # token 最低活跃频率（单位：秒），如果 token 超过此时间没有访问系统就会被冻结，默认-<span class=\"hljs-number\">1</span> 代表不限制，永不冻结\n  active-timeout: <span class=\"hljs-number\">3600</span>\n  # jwt秘钥\n  jwt-secret-key: qazwsxedc\n\n# 文件上传下载目录\nfiles:\n  upload:\n    path: D:/files/\n</code></div></pre>\n<h3><a id=\"23__118\"></a>2.3 常量</h3>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.dragon.springboot3vue3.common;\n\n<span class=\"hljs-keyword\">import</span> io.swagger.v3.oas.annotations.media.Schema;\n\n<span class=\"hljs-meta\">@Schema(description = &quot;常量&quot;)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Constant</span> {\n\n    <span class=\"hljs-comment\">// SaResult 默认设置了 200 为成功, 500 为 失败</span>\n    \n    <span class=\"hljs-comment\">/********** CODE &amp; MSG **********/</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String TOKEN= <span class=\"hljs-string\">&quot;X-Token&quot;</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String USER_PASSWORD= <span class=\"hljs-string\">&quot;123456&quot;</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">TOKEN_INVALID_CODE</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">20001</span>; <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">TOKEN_INVALID_MSG</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Token无效，请重新登录&quot;</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">USERNAME_OCCUPIED_CODE</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">20002</span>; <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">USERNAME_OCCUPIED_MSG</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;用户名被占用，请重新输入&quot;</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">USERNAME_OR_PASSWORD_ERROR_CODE</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">20003</span>; <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">USERNAME_OR_PASSWORD_ERROR_MSG</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;用户名或密码输入错误&quot;</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">MISSING_NECESSARY_PARAMETERS_CODE</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">20004</span>; <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">MISSING_NECESSARY_PARAMETERS_MSG</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;缺少必要的参数&quot;</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ORIGINAL_PASSWORD_ERROR_CODE</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">20005</span>; <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">ORIGINAL_PASSWORD_ERROR_MSG</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;原密码输入错误&quot;</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">PASSWORD_INCONSISTENCY_CODE</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">20006</span>; <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">PASSWORD_INCONSISTENCY_MSG</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;两次输入的新密码不一致&quot;</span>;\n\n    <span class=\"hljs-comment\">//  请求白名单，请求会放行</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String[] WHITE_LIST = {\n            <span class=\"hljs-string\">&quot;/user/register&quot;</span>,\n            <span class=\"hljs-string\">&quot;/user/login&quot;</span>,\n            <span class=\"hljs-string\">&quot;/user/logout&quot;</span>,\n            <span class=\"hljs-string\">&quot;/swagger-ui/**&quot;</span>,\n            <span class=\"hljs-string\">&quot;/v3/**&quot;</span>,\n            <span class=\"hljs-string\">&quot;/files/{fileName}&quot;</span>,\n    };\n}\n</code></div></pre>\n<h3><a id=\"24_config_152\"></a>2.4 config-配置类</h3>\n<h4><a id=\"241__154\"></a>2.4.1 跨域配置类</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.dragon.springboot3vue3.config;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.context.annotation.Bean;\n<span class=\"hljs-keyword\">import</span> org.springframework.context.annotation.Configuration;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.cors.CorsConfiguration;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.filter.CorsFilter;\n<span class=\"hljs-keyword\">import</span> java.util.List;\n\n<span class=\"hljs-comment\">/**\n * 跨域配置类\n */</span>\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CorsConfig</span> {\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> CorsFilter <span class=\"hljs-title function_\">corsFilter</span><span class=\"hljs-params\">()</span>{\n        <span class=\"hljs-type\">CorsConfiguration</span> <span class=\"hljs-variable\">corsConfiguration</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CorsConfiguration</span>();\n        corsConfiguration.setAllowedOrigins(List.of(<span class=\"hljs-string\">&quot;http://localhost:3000&quot;</span>, <span class=\"hljs-string\">&quot;http://127.0.0.1:5173&quot;</span>,<span class=\"hljs-string\">&quot;http://localhost:5173&quot;</span>)); <span class=\"hljs-comment\">// 设置允许的来源</span>\n        corsConfiguration.setAllowedMethods(List.of(<span class=\"hljs-string\">&quot;*&quot;</span>));     <span class=\"hljs-comment\">// 设置允许的方法</span>\n        corsConfiguration.setAllowedHeaders(List.of(<span class=\"hljs-string\">&quot;*&quot;</span>));     <span class=\"hljs-comment\">// 设置允许的头部</span>\n        corsConfiguration.setAllowCredentials(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 允许携带凭证</span>\n\n        <span class=\"hljs-type\">UrlBasedCorsConfigurationSource</span> <span class=\"hljs-variable\">urlBasedCorsConfigurationSource</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">UrlBasedCorsConfigurationSource</span>();\n        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class=\"hljs-string\">&quot;/**&quot;</span>,corsConfiguration);\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CorsFilter</span>(urlBasedCorsConfigurationSource);\n    }\n}\n</code></div></pre>\n<h4><a id=\"242_SaToken__188\"></a>2.4.2 SaToken 配置类</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.dragon.springboot3vue3.config;\n\n<span class=\"hljs-keyword\">import</span> cn.dev33.satoken.interceptor.SaInterceptor;\n<span class=\"hljs-keyword\">import</span> cn.dev33.satoken.jwt.StpLogicJwtForSimple;\n<span class=\"hljs-keyword\">import</span> cn.dev33.satoken.router.SaRouter;\n<span class=\"hljs-keyword\">import</span> cn.dev33.satoken.stp.StpLogic;\n<span class=\"hljs-keyword\">import</span> cn.dev33.satoken.stp.StpUtil;\n<span class=\"hljs-keyword\">import</span> com.dragon.springboot3vue3.common.Constant;\n<span class=\"hljs-keyword\">import</span> org.springframework.context.annotation.Bean;\n<span class=\"hljs-keyword\">import</span> org.springframework.context.annotation.Configuration;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SaTokenConfigure</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">WebMvcConfigurer</span> {\n    <span class=\"hljs-comment\">// Sa-Token 整合 jwt (Simple 简单模式)</span>\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> StpLogic <span class=\"hljs-title function_\">getStpLogicJwt</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StpLogicJwtForSimple</span>();\n    }\n\n    <span class=\"hljs-comment\">// 注册 Sa-Token 拦截器</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addInterceptors</span><span class=\"hljs-params\">(InterceptorRegistry registry)</span> {\n        registry.addInterceptor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SaInterceptor</span>(handle -&gt; {\n            <span class=\"hljs-comment\">// 登录拦截，放行白名单</span>\n            SaRouter.match(<span class=\"hljs-string\">&quot;/**&quot;</span>).notMatch(Constant.WHITE_LIST).check(r -&gt; StpUtil.checkLogin());\n\n        }))\n        .addPathPatterns(<span class=\"hljs-string\">&quot;/**&quot;</span>);\n    }\n}\n</code></div></pre>\n<h4><a id=\"243_Swagger__225\"></a>2.4.3 Swagger 配置类</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.dragon.springboot3vue3.config;\n\n<span class=\"hljs-keyword\">import</span> io.swagger.v3.oas.models.ExternalDocumentation;\n<span class=\"hljs-keyword\">import</span> io.swagger.v3.oas.models.OpenAPI;\n<span class=\"hljs-keyword\">import</span> io.swagger.v3.oas.models.info.Info;\n<span class=\"hljs-keyword\">import</span> io.swagger.v3.oas.models.info.License;\n<span class=\"hljs-keyword\">import</span> org.springframework.context.annotation.Bean;\n<span class=\"hljs-keyword\">import</span> org.springframework.context.annotation.Configuration;\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SwaggerConfig</span> {\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> OpenAPI <span class=\"hljs-title function_\">openAPI</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-type\">OpenAPI</span> <span class=\"hljs-variable\">openAPI</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OpenAPI</span>();\n        openAPI.info(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Info</span>().title(<span class=\"hljs-string\">&quot;前后端分离管理系统&quot;</span>)\n                               .description(<span class=\"hljs-string\">&quot;使用springboot3-vue3等技术&quot;</span>)\n                               .version(<span class=\"hljs-string\">&quot;v1.0.0&quot;</span>)\n                               .license(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">License</span>().name(<span class=\"hljs-string\">&quot;Apache 2.0&quot;</span>).url(<span class=\"hljs-string\">&quot;https://springdoc.org&quot;</span>)));\n        openAPI.externalDocs(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ExternalDocumentation</span>().description(<span class=\"hljs-string\">&quot;项目API文档&quot;</span>)\n                                                        .url(<span class=\"hljs-string\">&quot;/&quot;</span>));\n        <span class=\"hljs-keyword\">return</span> openAPI;\n    }\n}\n</code></div></pre>\n<h4><a id=\"244_MybatisPlus__254\"></a>2.4.4 MybatisPlus 配置类</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.dragon.springboot3vue3.config;\n\n<span class=\"hljs-keyword\">import</span> com.baomidou.mybatisplus.annotation.DbType;\n<span class=\"hljs-keyword\">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;\n<span class=\"hljs-keyword\">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;\n<span class=\"hljs-keyword\">import</span> org.springframework.context.annotation.Bean;\n<span class=\"hljs-keyword\">import</span> org.springframework.context.annotation.Configuration;\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MybatisPlusConfig</span> {\n    <span class=\"hljs-comment\">/**\n     * 添加 MybatisPlus 分页插件\n     */</span>\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> MybatisPlusInterceptor <span class=\"hljs-title function_\">mybatisPlusInterceptor</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-type\">MybatisPlusInterceptor</span> <span class=\"hljs-variable\">interceptor</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MybatisPlusInterceptor</span>();\n        interceptor.addInnerInterceptor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PaginationInnerInterceptor</span>(DbType.MYSQL));\n        <span class=\"hljs-keyword\">return</span> interceptor;\n    }\n}\n</code></div></pre>\n<h3><a id=\"25__279\"></a>2.5 实现登录认证</h3>\n<p>2.5.1 SaResult - SaToken封装的结果集</p>\n<p>2.5.2 StpUtil - SaToken的鉴权工具类（<a href=\"https://sa-token.cc/doc.html#/api/stp-util\" title=\"Sa-Token\" target=\"_blank\">Sa-Token</a>）</p>\n<p>2.5.3 StringRedisTemplate - Redis工具类</p>\n<p>2.5.4 BCrypt - 密码加密方式（<a href=\"https://sa-token.cc/doc.html#/up/password-secure\" title=\"Sa-Token\" target=\"_blank\">Sa-Token</a>）</p>\n<p>2.5.5 @Tag、@Operation - Swagger(SpringDoc)注解</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.dragon.springboot3vue3.controller;\n\n<span class=\"hljs-keyword\">import</span> cn.dev33.satoken.secure.BCrypt;\n<span class=\"hljs-keyword\">import</span> cn.dev33.satoken.stp.StpUtil;\n<span class=\"hljs-keyword\">import</span> cn.dev33.satoken.util.SaResult;\n<span class=\"hljs-keyword\">import</span> com.alibaba.fastjson2.JSON;\n<span class=\"hljs-keyword\">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;\n<span class=\"hljs-keyword\">import</span> com.dragon.springboot3vue3.common.Constant;\n<span class=\"hljs-keyword\">import</span> com.dragon.springboot3vue3.controller.dto.entityDto.RegisterOrLoginDto;\n<span class=\"hljs-keyword\">import</span> com.dragon.springboot3vue3.controller.dto.entityDto.UserDto;\n<span class=\"hljs-keyword\">import</span> com.dragon.springboot3vue3.controller.dto.pageDto.UserPageDto;\n<span class=\"hljs-keyword\">import</span> com.dragon.springboot3vue3.entity.User;\n<span class=\"hljs-keyword\">import</span> com.dragon.springboot3vue3.service.IUserService;\n<span class=\"hljs-keyword\">import</span> io.swagger.v3.oas.annotations.Operation;\n<span class=\"hljs-keyword\">import</span> io.swagger.v3.oas.annotations.tags.Tag;\n<span class=\"hljs-keyword\">import</span> jakarta.servlet.http.HttpServletResponse;\n<span class=\"hljs-keyword\">import</span> org.apache.commons.lang3.StringUtils;\n<span class=\"hljs-keyword\">import</span> org.springframework.beans.BeanUtils;\n<span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;\n<span class=\"hljs-keyword\">import</span> org.springframework.validation.annotation.Validated;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.*;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.multipart.MultipartFile;\n<span class=\"hljs-keyword\">import</span> java.util.List;\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.TimeUnit;\n\n<span class=\"hljs-meta\">@Tag(name = &quot;用户接口&quot;)</span>\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping(&quot;/user&quot;)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserController</span> {\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> IUserService userService;\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> StringRedisTemplate stringRedisTemplate;\n\n    <span class=\"hljs-meta\">@Operation(summary = &quot;注册&quot;)</span>\n    <span class=\"hljs-meta\">@PostMapping(&quot;/register&quot;)</span>\n    <span class=\"hljs-keyword\">public</span> SaResult <span class=\"hljs-title function_\">register</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@RequestBody</span> <span class=\"hljs-meta\">@Validated</span> RegisterOrLoginDto registerDto)</span>{\n        User user=userService.lambdaQuery().eq(User::getUsername,registerDto.getUsername()).one();\n        <span class=\"hljs-keyword\">if</span>(user!=<span class=\"hljs-literal\">null</span>){\n            <span class=\"hljs-keyword\">return</span> SaResult.error(Constant.USERNAME_OCCUPIED_MSG).setCode(Constant.USERNAME_OCCUPIED_CODE);\n        }\n        user=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>();\n        BeanUtils.copyProperties(registerDto,user);\n        <span class=\"hljs-comment\">// BCrypt.hashpw() 密码加密</span>\n        user.setPassword(BCrypt.hashpw(registerDto.getPassword(), BCrypt.gensalt()));\n        userService.save(user);\n        <span class=\"hljs-keyword\">return</span> SaResult.ok();\n    }\n\n    <span class=\"hljs-meta\">@Operation(summary = &quot;登录&quot;)</span>\n    <span class=\"hljs-meta\">@PostMapping(&quot;/login&quot;)</span>\n    <span class=\"hljs-keyword\">public</span> SaResult <span class=\"hljs-title function_\">login</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@RequestBody</span> <span class=\"hljs-meta\">@Validated</span> RegisterOrLoginDto loginDto)</span>{\n        User user=userService.lambdaQuery().eq(User::getUsername,loginDto.getUsername()).one();\n        <span class=\"hljs-comment\">// BCrypt.checkpw(前端明文,后端密文)</span>\n        <span class=\"hljs-keyword\">if</span>(user!=<span class=\"hljs-literal\">null</span> &amp;&amp; BCrypt.checkpw(loginDto.getPassword(),user.getPassword())){\n            <span class=\"hljs-comment\">// 登录认证</span>\n            StpUtil.login(user.getId());\n            <span class=\"hljs-comment\">// 生成token，token 信息自动存入redis，在yml里配置 sa-token 相关信息</span>\n            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">token</span> <span class=\"hljs-operator\">=</span> StpUtil.getTokenValue();\n            <span class=\"hljs-comment\">// 将用户信息存入 redis</span>\n            stringRedisTemplate.opsForValue().set(user.getId(), JSON.toJSONString(user),<span class=\"hljs-number\">1</span>, TimeUnit.DAYS);\n\n            <span class=\"hljs-keyword\">return</span> SaResult.ok().setData(token);\n        }\n        <span class=\"hljs-keyword\">return</span> SaResult.error(Constant.USERNAME_OR_PASSWORD_ERROR_MSG).setCode(Constant.USERNAME_OR_PASSWORD_ERROR_CODE);\n    }\n\n    <span class=\"hljs-meta\">@Operation(summary = &quot;注销&quot;)</span>\n    <span class=\"hljs-meta\">@PostMapping(&quot;/logout&quot;)</span>\n    <span class=\"hljs-keyword\">public</span> SaResult <span class=\"hljs-title function_\">logout</span><span class=\"hljs-params\">()</span>{\n        StpUtil.logout();\n        <span class=\"hljs-keyword\">return</span> SaResult.ok();\n    }\n\n    <span class=\"hljs-meta\">@Operation(summary = &quot;获取登录用户信息&quot;)</span>\n    <span class=\"hljs-meta\">@GetMapping(&quot;/userInfo&quot;)</span>\n    <span class=\"hljs-keyword\">public</span> SaResult <span class=\"hljs-title function_\">userInfo</span><span class=\"hljs-params\">()</span>{\n        <span class=\"hljs-comment\">// Redis 中获取登录的用户信息</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">userInfo</span> <span class=\"hljs-operator\">=</span> stringRedisTemplate.opsForValue().get(StpUtil.getLoginIdAsString());\n        User user= JSON.parseObject(userInfo,User.class);\n        <span class=\"hljs-keyword\">return</span> SaResult.ok().setData(user);\n    }\n}\n</code></div></pre>\n<h3><a id=\"26_swaggeruihttplocalhost8080swaggeruiindexhtmlhttplocalhost8080swaggeruiindexhtml_httplocalhost8080swaggeruiindexhtml_378\"></a>2.6 swagger-ui地址：<a href=\"http://localhost:8080/swagger-ui/index.html\" title=\"http://localhost:8080/swagger-ui/index.html\" target=\"_blank\">http://localhost:8080/swagger-ui/index.html</a></h3>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/8036ff05256828c0d4ad6c70ca1a3e18.png\" alt=\"\" /></p>\n', '1、Sa-Token 介绍 {#content_views}\n------------------------------\n\n### 1.1 Sa-Token 开发文档：[https://sa-token.cc](https://sa-token.cc/ \"https://sa-token.cc\")\n\n### **1.2 Sa-Token** 是一个轻量级 Java 权限认证框架，主要解决：**登录认证** 、**权限认证** 、**单点登录** 、**OAuth2.0** 、**微服务鉴权** 等一系列权限相关问题。\n\n### 1.3 功能结构图![](https://i-blog.csdnimg.cn/blog_migrate/61de5b4e66af7c02266d67e618c86dd9.png)\n\n2、 SpringBoot 3 集成 Sa-Token\n---------------------------\n\n### **2.1 Maven**\n\n```XML\n<!-- Sa-Token -->\n<dependency>\n    <groupId>cn.dev33</groupId>\n    <artifactId>sa-token-spring-boot3-starter</artifactId>\n    <version>1.38.0</version>\n</dependency>\n\n<!-- Sa-Token 集成 jwt -->\n<dependency>\n    <groupId>cn.dev33</groupId>\n    <artifactId>sa-token-jwt</artifactId>\n    <version>1.38.0</version>\n</dependency>\n\n<!-- Sa-Token 集成 redis， 并使用 jackson 序列化 -->\n<dependency>\n    <groupId>cn.dev33</groupId>\n    <artifactId>sa-token-redis-jackson</artifactId>\n    <version>1.38.0</version>\n</dependency>\n\n<!-- 提供Redis连接池 -->\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n</dependency>\n\n<!-- fastjson2 处理 json 数据 -->\n<dependency>\n    <groupId>com.alibaba.fastjson2</groupId>\n    <artifactId>fastjson2</artifactId>\n    <version>2.0.48</version>\n</dependency>\n\n<!-- 使用 springdoc 生成 swagger 文档  -->\n<dependency>\n    <groupId>org.springdoc</groupId>\n    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>\n    <version>2.5.0</version>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>com.mysql</groupId>\n    <artifactId>mysql-connector-j</artifactId>\n    <version>8.3.0</version>\n</dependency>\n\n<!-- mybatis-plus-boot-starter 中 mybatis-spring 版本不够，排除之后引入新版本 -->\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.5.6</version>\n    <exclusions>\n        <exclusion>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis-spring</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-spring</artifactId>\n    <version>3.0.3</version>\n</dependency>\n```\n\n### 2.2 yml 配置 sa-token\n\n```java\nserver:\n  port: 8080\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/xxx\n    username: xxx\n    password: xxx\n  data:\n    redis:\n      database: 1\n\nsa-token:\n  token-name: X-Token\n  # token有效期，单位s 默认30天, -1代表永不过期\n  timeout: -1\n  # token 最低活跃频率（单位：秒），如果 token 超过此时间没有访问系统就会被冻结，默认-1 代表不限制，永不冻结\n  active-timeout: 3600\n  # jwt秘钥\n  jwt-secret-key: qazwsxedc\n\n# 文件上传下载目录\nfiles:\n  upload:\n    path: D:/files/\n```\n\n### 2.3 常量\n\n```java\npackage com.dragon.springboot3vue3.common;\n\nimport io.swagger.v3.oas.annotations.media.Schema;\n\n@Schema(description = \"常量\")\npublic class Constant {\n\n    // SaResult 默认设置了 200 为成功, 500 为 失败\n    \n    /********** CODE & MSG **********/\n    public static final String TOKEN= \"X-Token\";\n    public static final String USER_PASSWORD= \"123456\";\n    public static final int TOKEN_INVALID_CODE = 20001; public static final String TOKEN_INVALID_MSG = \"Token无效，请重新登录\";\n    public static final int USERNAME_OCCUPIED_CODE = 20002; public static final String USERNAME_OCCUPIED_MSG = \"用户名被占用，请重新输入\";\n    public static final int USERNAME_OR_PASSWORD_ERROR_CODE = 20003; public static final String USERNAME_OR_PASSWORD_ERROR_MSG = \"用户名或密码输入错误\";\n    public static final int MISSING_NECESSARY_PARAMETERS_CODE = 20004; public static final String MISSING_NECESSARY_PARAMETERS_MSG = \"缺少必要的参数\";\n    public static final int ORIGINAL_PASSWORD_ERROR_CODE = 20005; public static final String ORIGINAL_PASSWORD_ERROR_MSG = \"原密码输入错误\";\n    public static final int PASSWORD_INCONSISTENCY_CODE = 20006; public static final String PASSWORD_INCONSISTENCY_MSG = \"两次输入的新密码不一致\";\n\n    //  请求白名单，请求会放行\n    public static final String[] WHITE_LIST = {\n            \"/user/register\",\n            \"/user/login\",\n            \"/user/logout\",\n            \"/swagger-ui/**\",\n            \"/v3/**\",\n            \"/files/{fileName}\",\n    };\n}\n```\n\n### 2.4 config-配置类\n\n#### 2.4.1 跨域配置类\n\n```java\npackage com.dragon.springboot3vue3.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\nimport org.springframework.web.filter.CorsFilter;\nimport java.util.List;\n\n/**\n * 跨域配置类\n */\n@Configuration\npublic class CorsConfig {\n\n    @Bean\n    public CorsFilter corsFilter(){\n        CorsConfiguration corsConfiguration = new CorsConfiguration();\n        corsConfiguration.setAllowedOrigins(List.of(\"http://localhost:3000\", \"http://127.0.0.1:5173\",\"http://localhost:5173\")); // 设置允许的来源\n        corsConfiguration.setAllowedMethods(List.of(\"*\"));     // 设置允许的方法\n        corsConfiguration.setAllowedHeaders(List.of(\"*\"));     // 设置允许的头部\n        corsConfiguration.setAllowCredentials(true); // 允许携带凭证\n\n        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();\n        urlBasedCorsConfigurationSource.registerCorsConfiguration(\"/**\",corsConfiguration);\n\n        return new CorsFilter(urlBasedCorsConfigurationSource);\n    }\n}\n```\n\n#### 2.4.2 SaToken 配置类\n\n```java\npackage com.dragon.springboot3vue3.config;\n\nimport cn.dev33.satoken.interceptor.SaInterceptor;\nimport cn.dev33.satoken.jwt.StpLogicJwtForSimple;\nimport cn.dev33.satoken.router.SaRouter;\nimport cn.dev33.satoken.stp.StpLogic;\nimport cn.dev33.satoken.stp.StpUtil;\nimport com.dragon.springboot3vue3.common.Constant;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class SaTokenConfigure implements WebMvcConfigurer {\n    // Sa-Token 整合 jwt (Simple 简单模式)\n    @Bean\n    public StpLogic getStpLogicJwt() {\n        return new StpLogicJwtForSimple();\n    }\n\n    // 注册 Sa-Token 拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new SaInterceptor(handle -> {\n            // 登录拦截，放行白名单\n            SaRouter.match(\"/**\").notMatch(Constant.WHITE_LIST).check(r -> StpUtil.checkLogin());\n\n        }))\n        .addPathPatterns(\"/**\");\n    }\n}\n```\n\n#### 2.4.3 Swagger 配置类\n\n```java\npackage com.dragon.springboot3vue3.config;\n\nimport io.swagger.v3.oas.models.ExternalDocumentation;\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.oas.models.info.Info;\nimport io.swagger.v3.oas.models.info.License;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class SwaggerConfig {\n\n    @Bean\n    public OpenAPI openAPI() {\n        OpenAPI openAPI = new OpenAPI();\n        openAPI.info(new Info().title(\"前后端分离管理系统\")\n                               .description(\"使用springboot3-vue3等技术\")\n                               .version(\"v1.0.0\")\n                               .license(new License().name(\"Apache 2.0\").url(\"https://springdoc.org\")));\n        openAPI.externalDocs(new ExternalDocumentation().description(\"项目API文档\")\n                                                        .url(\"/\"));\n        return openAPI;\n    }\n}\n```\n\n#### 2.4.4 MybatisPlus 配置类\n\n```java\npackage com.dragon.springboot3vue3.config;\n\nimport com.baomidou.mybatisplus.annotation.DbType;\nimport com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;\nimport com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MybatisPlusConfig {\n    /**\n     * 添加 MybatisPlus 分页插件\n     */\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        return interceptor;\n    }\n}\n```\n\n### 2.5 实现登录认证\n\n2.5.1 SaResult - SaToken封装的结果集\n\n2.5.2 StpUtil - SaToken的鉴权工具类（[Sa-Token](https://sa-token.cc/doc.html#/api/stp-util \"Sa-Token\")）\n\n2.5.3 StringRedisTemplate - Redis工具类\n\n2.5.4 BCrypt - 密码加密方式（[Sa-Token](https://sa-token.cc/doc.html#/up/password-secure \"Sa-Token\")）\n\n2.5.5 @Tag、@Operation - Swagger(SpringDoc)注解\n\n```java\npackage com.dragon.springboot3vue3.controller;\n\nimport cn.dev33.satoken.secure.BCrypt;\nimport cn.dev33.satoken.stp.StpUtil;\nimport cn.dev33.satoken.util.SaResult;\nimport com.alibaba.fastjson2.JSON;\nimport com.baomidou.mybatisplus.extension.plugins.pagination.Page;\nimport com.dragon.springboot3vue3.common.Constant;\nimport com.dragon.springboot3vue3.controller.dto.entityDto.RegisterOrLoginDto;\nimport com.dragon.springboot3vue3.controller.dto.entityDto.UserDto;\nimport com.dragon.springboot3vue3.controller.dto.pageDto.UserPageDto;\nimport com.dragon.springboot3vue3.entity.User;\nimport com.dragon.springboot3vue3.service.IUserService;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport jakarta.servlet.http.HttpServletResponse;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.StringRedisTemplate;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.multipart.MultipartFile;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n@Tag(name = \"用户接口\")\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n    @Autowired\n    private IUserService userService;\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Operation(summary = \"注册\")\n    @PostMapping(\"/register\")\n    public SaResult register(@RequestBody @Validated RegisterOrLoginDto registerDto){\n        User user=userService.lambdaQuery().eq(User::getUsername,registerDto.getUsername()).one();\n        if(user!=null){\n            return SaResult.error(Constant.USERNAME_OCCUPIED_MSG).setCode(Constant.USERNAME_OCCUPIED_CODE);\n        }\n        user=new User();\n        BeanUtils.copyProperties(registerDto,user);\n        // BCrypt.hashpw() 密码加密\n        user.setPassword(BCrypt.hashpw(registerDto.getPassword(), BCrypt.gensalt()));\n        userService.save(user);\n        return SaResult.ok();\n    }\n\n    @Operation(summary = \"登录\")\n    @PostMapping(\"/login\")\n    public SaResult login(@RequestBody @Validated RegisterOrLoginDto loginDto){\n        User user=userService.lambdaQuery().eq(User::getUsername,loginDto.getUsername()).one();\n        // BCrypt.checkpw(前端明文,后端密文)\n        if(user!=null && BCrypt.checkpw(loginDto.getPassword(),user.getPassword())){\n            // 登录认证\n            StpUtil.login(user.getId());\n            // 生成token，token 信息自动存入redis，在yml里配置 sa-token 相关信息\n            String token = StpUtil.getTokenValue();\n            // 将用户信息存入 redis\n            stringRedisTemplate.opsForValue().set(user.getId(), JSON.toJSONString(user),1, TimeUnit.DAYS);\n\n            return SaResult.ok().setData(token);\n        }\n        return SaResult.error(Constant.USERNAME_OR_PASSWORD_ERROR_MSG).setCode(Constant.USERNAME_OR_PASSWORD_ERROR_CODE);\n    }\n\n    @Operation(summary = \"注销\")\n    @PostMapping(\"/logout\")\n    public SaResult logout(){\n        StpUtil.logout();\n        return SaResult.ok();\n    }\n\n    @Operation(summary = \"获取登录用户信息\")\n    @GetMapping(\"/userInfo\")\n    public SaResult userInfo(){\n        // Redis 中获取登录的用户信息\n        String userInfo = stringRedisTemplate.opsForValue().get(StpUtil.getLoginIdAsString());\n        User user= JSON.parseObject(userInfo,User.class);\n        return SaResult.ok().setData(user);\n    }\n}\n```\n\n### 2.6 swagger-ui地址：[http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html \"http://localhost:8080/swagger-ui/index.html\")\n\n![](https://i-blog.csdnimg.cn/blog_migrate/8036ff05256828c0d4ad6c70ca1a3e18.png)\n', 3, 1, 1, 1, 1, 1, 'https://blog.csdn.net/qq_58159506/article/details/139647081', 1, '111', NULL, '2025-04-26 11:58:46', '2025-04-30 12:28:14');
INSERT INTO `sys_article` VALUES (298, 1, 17, 'OAuth 2.0 授权认证详解', 'img/OAuth 2.0 授权认证详解.png', 'OAuth 2.0 授权认证详解', '<h2><a id=\"OAuth20_content_views_0\"></a>​​​​​​一、认识OAuth2.0 {#content_views}</h2>\n<h3><a id=\"t111_OAuth_20__311OAuth_20__3\"></a>{#t1}{#11_OAuth_20__3}1.1、OAuth 2.0 应用场景</h3>\n<p>OAuth 2.0 （Open Authorization，开放授权）标准目前被广泛应用在<ins>第三方登录场景</ins> 中，以下是虚拟出来的角色，阐述 OAuth2 能帮我们干什么，引用阮一峰这篇<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2014%2F05%2Foauth_2_0.html\" title=\"理解OAuth 2.0\" target=\"_blank\">理解OAuth 2.0</a>中的例子：</p>\n<p>有一个&quot;云冲印&quot;的网站（客户端），可以将用户（资源拥有者）储存在Google（HTTP服务提供商）的照片，冲印出来。用户为了使用该服务，必须让&quot;云冲印&quot;读取自己储存在Google上的照片。</p>\n<p>问题是只有得到用户的授权，Google才会同意&quot;云冲印&quot;读取这些照片。那么，&quot;云冲印&quot;怎样获得用户的授权呢？</p>\n<p>传统方法是，用户将自己的Google用户名和密码，告诉&quot;云冲印&quot;，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点：</p>\n<p>1）&quot;云冲印&quot;为了后续的服务，会保存用户的密码，这样很不安全。</p>\n<p>2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。</p>\n<p>3）&quot;云冲印&quot;拥有了获取用户储存在Google所有资料的权力，用户没法限制&quot;云冲印&quot;获得授权的范围和有效期。</p>\n<p>4）用户只有修改密码，才能收回赋予&quot;云冲印&quot;的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。</p>\n<p>5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p>\n<h3><a id=\"t212__1512_23\"></a>{#t2}{#12__15}1.2、名词概念</h3>\n<p>OAuth 就是为了解决上面这些问题而诞生的。在详解 OAuth 之前，需要明确一些基本的概念，从上面场景中抽象出以下概念。</p>\n<p><strong>第三方应用程序</strong></p>\n<p><strong>Third-party application</strong> ：第三方应用程序，本文中又称&quot;客户端&quot;（client），即上一节例子中的&quot;云冲印&quot;。</p>\n<p><strong>HTTP服务提供商</strong></p>\n<p><strong>HTTP service</strong> ：HTTP服务提供商，本文中简称&quot;服务提供商&quot;，即上一节例子中的Google。</p>\n<p><strong>资源所有者</strong></p>\n<p><strong>Resource Owner</strong>：资源所有者，本文中又称&quot;用户&quot;（user）。</p>\n<p><strong>用户代理</strong></p>\n<p><strong>User Agent</strong>：用户代理，本文中就是指浏览器。</p>\n<p><strong>认证服务器</strong></p>\n<p><strong>Authorization server</strong> ：认证服务器，即<ins>服务提供商专门用来处理认证的服务器</ins>。</p>\n<p><strong>资源服务器</strong></p>\n<p><strong>Resource server</strong> ：资源服务器，即<ins>服务提供商存放用户生成的资源的服务器</ins>。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>\n<p>知道了上面这些名词，就不难理解，OAuth的作用就是<ins>让&quot;客户端&quot;安全可控地获取&quot;用户&quot;的授权，从而可以和&quot;服务商提供商&quot;进行互动。</ins></p>\n<h2><a id=\"t3OAuth__45OAuth__53\"></a>{#t3}{#OAuth__45}二、OAuth 的授权认证流程</h2>\n<h3><a id=\"t421__4821_56\"></a>{#t4}{#21__48}2.1、认证思路</h3>\n<p>OAuth 在&quot;客户端&quot;与&quot;服务提供商&quot;之间，设置了一个 <strong>授权层</strong> （authorization layer）。“客户端&quot;不能直接登录&quot;服务提供商”，只能登录授权层，以此将用户与客户端区分开来。<ins>&quot;客户端&quot;登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</ins></p>\n<p>&quot;客户端&quot;登录授权层以后，&quot;服务提供商&quot;根据令牌的权限范围和有效期，向&quot;客户端&quot;开放用户储存的资料。</p>\n<h3><a id=\"t522__5422_62\"></a>{#t5}{#22__54}2.2、认证流程</h3>\n<p>官方 RFC 6749 文件中的 OAuth 2.0 流程图有点晦涩，优化了 一下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/ca456ad49e2b8ada819e5f09a05a0410.png\" alt=\"\" /></p>\n<p>1）用户访问第三方应用程序（简称：客户端）以后，客户端要求用户给予授权。</p>\n<p>2）用户同意给予客户端授权。</p>\n<p>3）<ins>客户端使用第 2 步获得的授权，向认证服务器申请令牌</ins>。</p>\n<p>4）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p>\n<p>5）客户端使用令牌，向资源服务器申请获取资源。</p>\n<p>6）资源服务器确认令牌无误，同意向客户端开放资源。</p>\n<p>上述中的第 2 步 是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p>\n<h2><a id=\"t6_69_82\"></a>{#t6}{#_69}三、四种授权模式</h2>\n<p>上一小节可以得出用户对客户端的授权动作是核心，客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式：</p>\n<h3><a id=\"t731_authorization_code_7431authorization_code_87\"></a>{#t7}{#31_authorization_code_74}3.1、授权码模式（authorization code）</h3>\n<p>授权码（authorization code）方式，指的是<ins>第三方应用先申请一个授权码，然后再用该码获取令牌。</ins></p>\n<h3><a id=\"t832_implicit_7832implicit_91\"></a>{#t8}{#32_implicit_78}3.2、简化模式（implicit）</h3>\n<p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，<ins>允许直接向前端颁发令牌</ins>。这种方式没有授权码这个中间步骤，所以称为（授权码）“隐藏式”（implicit）。</p>\n<h3><a id=\"t933_resource_owner_password_credentials_8233resource_owner_password_credentials_95\"></a>{#t9}{#33_resource_owner_password_credentials_82}3.3、密码模式（resource owner password credentials）</h3>\n<p>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为&quot;密码式&quot;（password）。</p>\n<h3><a id=\"t1034_client_credentials_8634client_credentials_99\"></a>{#t10}{#34_client_credentials_86}3.4、客户端模式（client credentials）</h3>\n<p>最后一种方式是凭证式（client credentials），<ins>适用于没有前端的命令行应用，即在命令行下请求令牌。</ins></p>\n<h2><a id=\"t11_90_103\"></a>{#t11}{#_90}四、授权码模式详解</h2>\n<h3><a id=\"t1241__9341_106\"></a>{#t12}{#41__93}4.1、授权码模式流程</h3>\n<p>授权码模式（authorization code）是功能最完整、流程最严密安全的授权模式。它的特点就是<ins>通过客户端的<strong>后台服务器</strong>，与&quot;服务提供商&quot;的认证服务器进行互动。</ins></p>\n<p>注意这种方式适用于那些有后端的 Web 应用。<ins>授权码通过前端传送，令牌则是储存在后端</ins>，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/b162ba0ab8877cc5dc79389b7c103a22.png\" alt=\"\" /></p>\n<p>授权码模式流程如下：</p>\n<p>1）用户访问客户端，客户端将用户导向认证服务器。</p>\n<p>2）用户选择是否给予客户端授权。</p>\n<p>3）假设用户给予授权，认证服务器将用户导向客户端事先指定的&quot;重定向URI&quot;（redirection URI），同时附上一个授权码（每个用户的授权码不同）。</p>\n<p>4）客户端收到授权码，附上早先的&quot;重定向URI&quot;，向认证服务器申请令牌。这一步是在客户端的 <strong>后台服务器</strong> 上完成的，对用户不可见。</p>\n<p>5）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>\n<p>从上述的流程描述可知，只有第 2 步需要用户进行授权操作，之后的流程都是在客户端的后台和认证服务器后台之前进行&quot;静默&quot;操作，对于用户来说是无感知的。</p>\n<p>下面是上面这些步骤所需要的参数。</p>\n<h3><a id=\"t1342__11342_130\"></a>{#t13}{#42__113}4.2、授权码模式流程的五个步骤</h3>\n<p>{#_1__115}<strong>第 1 步骤</strong></p>\n<p>{#_117}<strong>参数说明</strong></p>\n<p>第 1 步骤中，客户端申请认证的URI，包含以下参数：</p>\n<ul>\n<li><code>response_type</code>：表示授权类型，<strong>必选项</strong>，此处的值固定为&quot;code&quot;</li>\n<li><code>client_id</code>：表示客户端的ID，<strong>必选项</strong></li>\n<li><code>redirect_uri</code>：表示重定向URI，可选项</li>\n<li><code>scope</code>：表示申请的权限范围，可选项</li>\n<li><code>state</code>：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>\n</ul>\n<p>{#_127}<strong>示例</strong></p>\n<p>A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">https:<span class=\"hljs-comment\">//b.com/oauth/authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=read </span>\n</code></div></pre>\n<p>上面 URL 中：</p>\n<p><code>response_type</code>参数表示要求返回授权码（<code>code</code>）；</p>\n<p><ins><code>client_id</code>参数让 B 网站知道是谁在请求；</ins></p>\n<p><code>redirect_uri</code>参数是 B 网站接受或拒绝请求后的跳转网址；</p>\n<p><code>scope</code>参数表示要求的授权范围（这里是只读）。</p>\n<p>{#_2__145}<strong>第 2 步骤</strong></p>\n<p>第 2 步骤中，<ins>用户跳转后，</ins> <ins>B 网站会要求用户登录，然后询问是否同意给予 A 网站授权</ins>。</p>\n<p>{#_3__149}<strong>第 3 步骤</strong></p>\n<p>{#_151}<strong>参数说明</strong></p>\n<p>第 3 步骤中，服务器回应客户端的URI，包含以下参数：</p>\n<ul>\n<li><code>code</code>：表示授权码，<strong>必选项</strong> 。该码的有效期应该很短，<ins>通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。</ins> 该码与客户端ID和重定向URI，是一一对应关系。</li>\n<li><code>state</code>：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>\n</ul>\n<p>{#_158}<strong>示例</strong></p>\n<p>在第 2 步骤用户表示同意之后，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">https:<span class=\"hljs-comment\">//a.com/callback?code=AUTHORIZATION_CODE </span>\n</code></div></pre>\n<p>上面 URL 中，<code>code</code>参数就是授权码。</p>\n<p>{#_4__168}<strong>第 4 步骤</strong></p>\n<p>{#_170}<strong>参数说明</strong></p>\n<p>第 4 步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p>\n<ul>\n<li><code>grant_type</code>：表示使用的授权模式，<strong>必选项</strong>，此处的值固定为&quot;authorization_code&quot;。</li>\n<li><code>code</code>：表示上一步获得的授权码，<strong>必选项</strong>。</li>\n<li><code>redirect_uri</code>：表示重定向URI，<strong>必选项</strong>，且必须与A步骤中的该参数值保持一致。</li>\n<li><code>client_id</code>：表示客户端ID，<strong>必选项</strong>。</li>\n</ul>\n<p>{#_179}<strong>示例</strong></p>\n<p>在第 3 步骤中，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">https:<span class=\"hljs-comment\">//b.com/oauth/token?</span>\n client_id=CLIENT_ID&amp;\n client_secret=CLIENT_SECRET&amp;\n grant_type=authorization_code&amp;\n code=AUTHORIZATION_CODE&amp;\n redirect_uri=CALLBACK_URL \n</code></div></pre>\n<p>上面 URL 中：</p>\n<p><code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求）；</p>\n<p><code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码；</p>\n<p><code>code</code>参数是上一步拿到的授权码；</p>\n<p><code>redirect_uri</code>参数是令牌颁发后的回调网址。</p>\n<p>{#_5__202}<strong>第 5 步骤</strong></p>\n<p>{#_204}<strong>参数说明</strong></p>\n<p>第 5 步骤中，认证服务器发送的HTTP回复，包含以下参数：</p>\n<ul>\n<li><code>access_token</code>：表示访问令牌，必选项。</li>\n<li><code>token_type</code>：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>\n<li><code>expires_in</code>：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>\n<li><code>refresh_token</code>：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>\n<li><code>scope</code>：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>\n</ul>\n<p>{#_214}<strong>示例</strong></p>\n<p>第 4 步骤中，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">HTTP/<span class=\"hljs-number\">1.1</span> <span class=\"hljs-number\">200</span> OK\nContent-Type: application/json;charset=UTF-<span class=\"hljs-number\">8</span>\nCache-Control: no-store\nPragma: no-cache\n\n{<span class=\"hljs-string\">&quot;access_token&quot;</span>:<span class=\"hljs-string\">&quot;ACCESS_TOKEN&quot;</span>,<span class=\"hljs-string\">&quot;token_type&quot;</span>:<span class=\"hljs-string\">&quot;bearer&quot;</span>,<span class=\"hljs-string\">&quot;expires_in&quot;</span>:<span class=\"hljs-number\">2592000</span>,<span class=\"hljs-string\">&quot;refresh_token&quot;</span>:<span class=\"hljs-string\">&quot;REFRESH_TOKEN&quot;</span>,<span class=\"hljs-string\">&quot;scope&quot;</span>:<span class=\"hljs-string\">&quot;read&quot;</span>,<span class=\"hljs-string\">&quot;uid&quot;</span>:<span class=\"hljs-number\">100101</span>,<span class=\"hljs-string\">&quot;info&quot;</span>:{...}\n} \n</code></div></pre>\n<p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。注意：HTTP头信息中明确指定不得缓存。</p>\n<h2><a id=\"t14Token_230Token_247\"></a>{#t14}{#Token_230}五、令牌（Token）传递方式</h2>\n<p>当客户端（第三方应用程序）拿到访问资源服务器的令牌时，便可以使用这个令牌进行资源访问了。</p>\n<p>在第三方应用程序拿到<code>access_token</code>后，如何发送给资源服务器这个问题并没有在 RFC6729 文件中定义，而是作为一个单独的 <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fwww.rfc-editor.org%2Frfc%2Frfc6750.txt\" title=\"RFC6750\" target=\"_blank\">RFC6750</a> 文件中独立定义了。这里做以下简单的介绍，主要有三种方式如下：</p>\n<p>1.URI Query Parameter</p>\n<p>2.Authorization Request Header Field</p>\n<p>3.Form-Encoded Body Parameter</p>\n<h3><a id=\"t1551__24151_260\"></a>{#t15}{#51__241}5.1、请求头参数传递</h3>\n<p>Authorization Request Header Field，因为在HTTP应用层协议中，专门有定义一个授权使用的Request Header，所以也可以使用这种方式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">GET /resource HTTP/<span class=\"hljs-number\">1.1</span>\nHost: server.example.com\nAuthorization: Bearer mF_9.B5f-<span class=\"hljs-number\">4.</span>1JqM \n</code></div></pre>\n<p>其中&quot;Bearer &quot;是固定的在access_token前面的头部信息。</p>\n<h3><a id=\"t1652__25352_272\"></a>{#t16}{#52__253}5.2、表单编码传递</h3>\n<p>使用 Request Body 这种方式，有一个额外的要求，就是 Request Header 的<code>Content-Type</code>必须是固定的<code>application/x-www-form-urlencoded</code>，此外还有一个限制就是 <strong>不可以使用 GET</strong> 访问，这个好理解，毕竟 GET 请求是不能携带 Request Body 的。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">POST /resource HTTP/<span class=\"hljs-number\">1.1</span>\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\n\naccess_token=mF_9.B5f-<span class=\"hljs-number\">4.</span>1JqM \n</code></div></pre>\n<h3><a id=\"t1753_URI__26553URI__284\"></a>{#t17}{#53_URI__265}5.3、URI 请求参数传递</h3>\n<p>URI Query Parameter，这种使用途径应该是最常见的一种方式，非常简单，比如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">GET /resource?access_token=mF_9.B5f-<span class=\"hljs-number\">4.</span>1JqM HTTP/<span class=\"hljs-number\">1.1</span>\nHost: server.example.com \n</code></div></pre>\n<p>在我们请求受保护的资源的 Url 后面追加一个 access_token 的参数即可。另外还有一点要求，就是 Client 需要设置以下 Request Header 的 <strong>Cache-Control:no-store</strong>，用来阻止 access_token 不会被 Web 中间件给 log 下来，属于安全防护方面的一个考虑。</p>\n<h3><a id=\"t1854__27654_295\"></a>{#t18}{#54__276}5.4、令牌的刷新</h3>\n<p>为了防止客户端使用一个令牌无限次数使用，令牌一般会有过期时间限制，当快要到期时，需要重新获取令牌，如果再重新走授权码的授权流程，对用户体验非常不好，于是 OAuth 2.0 允许用户自动更新令牌。</p>\n<p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">https:<span class=\"hljs-comment\">//b.com/oauth/token?grant_type=refresh_token&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;refresh_token=REFRESH_TOKEN </span>\n</code></div></pre>\n<p>上面 URL 中：</p>\n<p><code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，此处的值固定为<code>refresh_token</code>，必选项；</p>\n<p><code>client_id</code>参数和<code>client_secret</code>参数用于确认身份；</p>\n<p><code>refresh_token</code>参数就是用于更新令牌的令牌。</p>\n<p>B 网站验证通过以后，就会颁发新的令牌。</p>\n<p><strong>注意：</strong> 第三方应用服务器拿到刷新令牌必须存于服务器，通过后台进行重新获取新的令牌，以保障刷新令牌的保密性。</p>\n<h2><a id=\"t19OAuth2_298OAuth2_317\"></a>{#t19}{#OAuth2_298}六、OAuth2的安全问题</h2>\n<h3><a id=\"t2061_CSRF_30161CSRF_320\"></a>{#t20}{#61_CSRF_301}6.1、CSRF攻击</h3>\n<p>应用程序在早期使用 OAuth2 的时候爆发过不少相关的安全方面的漏洞，其实仔细分析后会发现大都都是没有严格遵循 OAuth2 的安全相关的指导造成的，相关的漏洞事件自行搜索。</p>\n<p>其实 OAuth2 在设计之初是已经做了很多安全方面的考虑，并且在 RFC6749 中加入了一些安全方面的规范指导。比如：</p>\n<p>1、要求 Authorization server 进行有效的客户端验证；</p>\n<p>2、client_serect，access_token，refresh_token，code等敏感信息的安全存储（不得泄露给第三方）、传输通道的安全性（TSL的要求）；</p>\n<p>3、维持 refresh_token 和第三方应用的绑定，刷新失效机制；</p>\n<p>4、维持 Authorization Code 和第三方应用的绑定，这也是state参数为什么是推荐的一点，以防止CSRF攻击；</p>\n<p>5、保证上述各种令牌信息的不可猜测行，以防止被猜测得到；安全无小事，这方面是要靠各方面（开放平台，第三方开发者）共同防范的。</p>\n<h3><a id=\"t2162__30962_336\"></a>{#t21}{#62__309}6.2、攻击流程</h3>\n<p>假设有用户张三，攻击者李四，第三方&quot;云冲印&quot;应用（它集成了第三方社交账号登录，并且允许用户将社交账号和&quot;云冲印&quot;中的账号进行绑定），以及 OAuth2 服务提供者 Google。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/b1a4f58a179a89687ebfc0203713e017.png\" alt=\"\" /></p>\n<p><strong>步骤1</strong></p>\n<p>攻击者李四登录&quot;云冲印&quot;网站，并且选择绑定自己的 Google 账号</p>\n<p><strong>步骤2</strong></p>\n<p>&quot;云冲印&quot;网站将李四重定向到 Google，由于他之前已经登录过 Google，所以 Google 直接向他显示是否授权&quot;云冲印&quot;访问的页面。</p>\n<p><strong>步骤3</strong></p>\n<p>李四在点击&quot;同意授权&quot;之后，截获 Google 服务器返回的含有<code>Authorization code</code>参数的HTTP响应。</p>\n<p><strong>步骤4</strong></p>\n<p>李四精心构造一个 Web 页面，它会触发&quot;云冲印&quot;网站向 Google 发起令牌申请的请求，而这个请求中的<code>Authorization Code</code>参数正是上一步截获到的 code。</p>\n<p><strong>步骤5</strong></p>\n<p>李四将这个 Web 页面放到互联网上，等待或者诱骗受害者张三来访问。</p>\n<p><strong>步骤6</strong></p>\n<p>张三之前登录了&quot;云冲印&quot;网站，只是没有把自己的账号和其他社交账号绑定起来。在张三访问了李四准备的这个 Web 页面，令牌申请流程在张三的浏览器里被顺利触发，&quot;云冲印&quot;网站从 Google 那里获取到<code>access_token</code>，但是这个 token 以及通过它进一步获取到的用户信息却都是攻击者李四的。</p>\n<p><strong>步骤7</strong></p>\n<p>&quot;云冲印&quot;网站将李四的 Google 账号同张三的&quot;云冲印&quot;账号关联绑定起来，从此以后，李四就可以用自己的 Google 账号通过 OAuth 登录到张三在 “云冲印” 网站中的账号，堂而皇之的冒充张三的身份执行各种操作。</p>\n<p>从整体上来看，本次 CSRF 攻击的时序图应该是下面这个样子的：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/9a3835545d31ef1167888721bd653ec8.png\" alt=\"\" /></p>\n<p>从上图中可以看出，造成 CSRF 攻击漏洞问题的关键点在于，OAuth2 的认证流程是分为好几步来完成的，在上一章节授权码模式流程中的流程图中的第 4步骤中，第三方应用在收到一个 GET 请求时，除了能知道当前用户的 cookie，以及 URL 中的<code>Authorization Code</code>之外，难以分辨出这个请求到底是用户本人的意愿，还是攻击者利用用户的身份伪造出来的请求。</p>\n<p>于是，攻击者就能使用移花接木的手段，提前准备一个含有自己的<code>Authorization Code</code>的请求，并让受害者的浏览器来接着完成后续的令牌申请流程。</p>\n<h3><a id=\"t2263__35163_378\"></a>{#t22}{#63__351}6.3、解决方案</h3>\n<p>要防止这样的攻击其实很容易，作为第三方应用的开发者，只需在 OAuth 认证过程中加入<code>state</code>参数，并验证它的参数值即可。具体细节如下：</p>\n<ul>\n<li>在将用户重定向到资源认证服务器授权界面的时候，为当前用户生成一个随机的字符串，并作为<code>state</code>参数加入到URL中，同时存储一份到 session 中。</li>\n<li>当第三方应用收到资源服务提供者返回的<code>Authorization Code</code>请求的时候，验证接收到的<code>state</code>参数值。如果是正确合法的请求，那么此时接收到的参数值应该和上一步提到的为该用户生成的<code>state</code>参数值（存于当前用户的 session 中）完全一致，否则就是异常请求。</li>\n<li><code>state</code>参数值需要具备下面几个特性：* 不可预测性：足够的随机，使得攻击者难以猜到正确的参数值* 关联性：<code>state</code>参数值和当前用户会话（user session）是相互关联的* 唯一性：每个用户，甚至每次请求生成的<code>state</code>参数值都是唯一的* 时效性：<code>state</code>参数一旦被使用则立即失效</li>\n</ul>\n<p><code>state</code>参数在 OAuth2 认证过程中不是必选参数，因此在早期第三方应用开发者在集成 OAuth2 认证的时候很容易会忽略它的存在，导致应用易受 CSRF 攻击。所以必须对这个安全问题重视起来。</p>\n<p>安全是双方的，需要第三方应用和资源服务提供商均要严格遵守安全规范。如 QQ 互联的 OAuth2 API 中，state 参数是强制必选的参数，授权接口是基于 HTTPS 的加密通道等；作为第三方开发者在使用消费这些服务的时候也应该重视注意安全中存在的漏洞。</p>\n<p>转自：<a href=\"https://blog.csdn.net/GJ_ia/article/details/128663296?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-128663296-blog-127730870.235%5Ev38%5Epc_relevant_sort_base1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-128663296-blog-127730870.235%5Ev38%5Epc_relevant_sort_base1&amp;utm_relevant_index=3\" title=\"OAuth 2.0 授权认证详解_oauth2.0_GJ_ia的博客-CSDN博客\" target=\"_blank\">OAuth 2.0 授权认证详解_oauth2.0_GJ_ia的博客-CSDN博客</a></p>\n', '​​​​​​一、认识OAuth2.0 {#content_views}\n-----------------------------------\n\n### {#t1}{#11_OAuth_20__3}1.1、OAuth 2.0 应用场景\n\nOAuth 2.0 （Open Authorization，开放授权）标准目前被广泛应用在++第三方登录场景++ 中，以下是虚拟出来的角色，阐述 OAuth2 能帮我们干什么，引用阮一峰这篇[理解OAuth 2.0](https://link.juejin.cn/?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2014%2F05%2Foauth_2_0.html \"理解OAuth 2.0\")中的例子：\n\n有一个\"云冲印\"的网站（客户端），可以将用户（资源拥有者）储存在Google（HTTP服务提供商）的照片，冲印出来。用户为了使用该服务，必须让\"云冲印\"读取自己储存在Google上的照片。\n\n问题是只有得到用户的授权，Google才会同意\"云冲印\"读取这些照片。那么，\"云冲印\"怎样获得用户的授权呢？\n\n传统方法是，用户将自己的Google用户名和密码，告诉\"云冲印\"，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点：\n\n1）\"云冲印\"为了后续的服务，会保存用户的密码，这样很不安全。\n\n2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。\n\n3）\"云冲印\"拥有了获取用户储存在Google所有资料的权力，用户没法限制\"云冲印\"获得授权的范围和有效期。\n\n4）用户只有修改密码，才能收回赋予\"云冲印\"的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。\n\n5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。\n\n### {#t2}{#12__15}1.2、名词概念\n\nOAuth 就是为了解决上面这些问题而诞生的。在详解 OAuth 之前，需要明确一些基本的概念，从上面场景中抽象出以下概念。\n\n**第三方应用程序**\n\n**Third-party application** ：第三方应用程序，本文中又称\"客户端\"（client），即上一节例子中的\"云冲印\"。\n\n**HTTP服务提供商**\n\n**HTTP service** ：HTTP服务提供商，本文中简称\"服务提供商\"，即上一节例子中的Google。\n\n**资源所有者**\n\n**Resource Owner**：资源所有者，本文中又称\"用户\"（user）。\n\n**用户代理**\n\n**User Agent**：用户代理，本文中就是指浏览器。\n\n**认证服务器**\n\n**Authorization server** ：认证服务器，即++服务提供商专门用来处理认证的服务器++。\n\n**资源服务器**\n\n**Resource server** ：资源服务器，即++服务提供商存放用户生成的资源的服务器++。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。\n\n知道了上面这些名词，就不难理解，OAuth的作用就是++让\"客户端\"安全可控地获取\"用户\"的授权，从而可以和\"服务商提供商\"进行互动。++\n\n{#t3}{#OAuth__45}二、OAuth 的授权认证流程\n--------------------------------\n\n### {#t4}{#21__48}2.1、认证思路\n\nOAuth 在\"客户端\"与\"服务提供商\"之间，设置了一个 **授权层** （authorization layer）。\"客户端\"不能直接登录\"服务提供商\"，只能登录授权层，以此将用户与客户端区分开来。++\"客户端\"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。++\n\n\"客户端\"登录授权层以后，\"服务提供商\"根据令牌的权限范围和有效期，向\"客户端\"开放用户储存的资料。\n\n### {#t5}{#22__54}2.2、认证流程\n\n官方 RFC 6749 文件中的 OAuth 2.0 流程图有点晦涩，优化了 一下：\n\n![](https://i-blog.csdnimg.cn/blog_migrate/ca456ad49e2b8ada819e5f09a05a0410.png)\n\n1）用户访问第三方应用程序（简称：客户端）以后，客户端要求用户给予授权。\n\n2）用户同意给予客户端授权。\n\n3）++客户端使用第 2 步获得的授权，向认证服务器申请令牌++。\n\n4）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。\n\n5）客户端使用令牌，向资源服务器申请获取资源。\n\n6）资源服务器确认令牌无误，同意向客户端开放资源。\n\n上述中的第 2 步 是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。\n\n{#t6}{#_69}三、四种授权模式\n-------------------\n\n上一小节可以得出用户对客户端的授权动作是核心，客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式：\n\n### {#t7}{#31_authorization_code_74}3.1、授权码模式（authorization code）\n\n授权码（authorization code）方式，指的是++第三方应用先申请一个授权码，然后再用该码获取令牌。++\n\n### {#t8}{#32_implicit_78}3.2、简化模式（implicit）\n\n有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，++允许直接向前端颁发令牌++。这种方式没有授权码这个中间步骤，所以称为（授权码）\"隐藏式\"（implicit）。\n\n### {#t9}{#33_resource_owner_password_credentials_82}3.3、密码模式（resource owner password credentials）\n\n如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为\"密码式\"（password）。\n\n### {#t10}{#34_client_credentials_86}3.4、客户端模式（client credentials）\n\n最后一种方式是凭证式（client credentials），++适用于没有前端的命令行应用，即在命令行下请求令牌。++\n\n{#t11}{#_90}四、授权码模式详解\n---------------------\n\n### {#t12}{#41__93}4.1、授权码模式流程\n\n授权码模式（authorization code）是功能最完整、流程最严密安全的授权模式。它的特点就是++通过客户端的**后台服务器**，与\"服务提供商\"的认证服务器进行互动。++\n\n注意这种方式适用于那些有后端的 Web 应用。++授权码通过前端传送，令牌则是储存在后端++，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。\n\n![](https://i-blog.csdnimg.cn/blog_migrate/b162ba0ab8877cc5dc79389b7c103a22.png)\n\n授权码模式流程如下：\n\n1）用户访问客户端，客户端将用户导向认证服务器。\n\n2）用户选择是否给予客户端授权。\n\n3）假设用户给予授权，认证服务器将用户导向客户端事先指定的\"重定向URI\"（redirection URI），同时附上一个授权码（每个用户的授权码不同）。\n\n4）客户端收到授权码，附上早先的\"重定向URI\"，向认证服务器申请令牌。这一步是在客户端的 **后台服务器** 上完成的，对用户不可见。\n\n5）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。\n\n从上述的流程描述可知，只有第 2 步需要用户进行授权操作，之后的流程都是在客户端的后台和认证服务器后台之前进行\"静默\"操作，对于用户来说是无感知的。\n\n下面是上面这些步骤所需要的参数。\n\n### {#t13}{#42__113}4.2、授权码模式流程的五个步骤\n\n{#_1__115}**第 1 步骤**\n\n{#_117}**参数说明**\n\n第 1 步骤中，客户端申请认证的URI，包含以下参数：\n\n* `response_type`：表示授权类型，**必选项**，此处的值固定为\"code\"\n* `client_id`：表示客户端的ID，**必选项**\n* `redirect_uri`：表示重定向URI，可选项\n* `scope`：表示申请的权限范围，可选项\n* `state`：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。\n\n{#_127}**示例**\n\nA 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接：\n\n```java\nhttps://b.com/oauth/authorize?response_type=code&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=read \n```\n\n上面 URL 中：\n\n`response_type`参数表示要求返回授权码（`code`）；\n\n++`client_id`参数让 B 网站知道是谁在请求；++\n\n`redirect_uri`参数是 B 网站接受或拒绝请求后的跳转网址；\n\n`scope`参数表示要求的授权范围（这里是只读）。\n\n{#_2__145}**第 2 步骤**\n\n第 2 步骤中，++用户跳转后，++ ++B 网站会要求用户登录，然后询问是否同意给予 A 网站授权++。\n\n{#_3__149}**第 3 步骤**\n\n{#_151}**参数说明**\n\n第 3 步骤中，服务器回应客户端的URI，包含以下参数：\n\n* `code`：表示授权码，**必选项** 。该码的有效期应该很短，++通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。++ 该码与客户端ID和重定向URI，是一一对应关系。\n* `state`：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。\n\n{#_158}**示例**\n\n在第 2 步骤用户表示同意之后，这时 B 网站就会跳回`redirect_uri`参数指定的网址。跳转时，会传回一个授权码，就像下面这样。\n\n```java\nhttps://a.com/callback?code=AUTHORIZATION_CODE \n```\n\n上面 URL 中，`code`参数就是授权码。\n\n{#_4__168}**第 4 步骤**\n\n{#_170}**参数说明**\n\n第 4 步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：\n\n* `grant_type`：表示使用的授权模式，**必选项**，此处的值固定为\"authorization_code\"。\n* `code`：表示上一步获得的授权码，**必选项**。\n* `redirect_uri`：表示重定向URI，**必选项**，且必须与A步骤中的该参数值保持一致。\n* `client_id`：表示客户端ID，**必选项**。\n\n{#_179}**示例**\n\n在第 3 步骤中，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。\n\n```java\nhttps://b.com/oauth/token?\n client_id=CLIENT_ID&\n client_secret=CLIENT_SECRET&\n grant_type=authorization_code&\n code=AUTHORIZATION_CODE&\n redirect_uri=CALLBACK_URL \n```\n\n上面 URL 中：\n\n`client_id`参数和`client_secret`参数用来让 B 确认 A 的身份（`client_secret`参数是保密的，因此只能在后端发请求）；\n\n`grant_type`参数的值是`AUTHORIZATION_CODE`，表示采用的授权方式是授权码；\n\n`code`参数是上一步拿到的授权码；\n\n`redirect_uri`参数是令牌颁发后的回调网址。\n\n{#_5__202}**第 5 步骤**\n\n{#_204}**参数说明**\n\n第 5 步骤中，认证服务器发送的HTTP回复，包含以下参数：\n\n* `access_token`：表示访问令牌，必选项。\n* `token_type`：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。\n* `expires_in`：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。\n* `refresh_token`：表示更新令牌，用来获取下一次的访问令牌，可选项。\n* `scope`：表示权限范围，如果与客户端申请的范围一致，此项可省略。\n\n{#_214}**示例**\n\n第 4 步骤中，B 网站收到请求以后，就会颁发令牌。具体做法是向`redirect_uri`指定的网址，发送一段 JSON 数据：\n\n```java\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n\n{\"access_token\":\"ACCESS_TOKEN\",\"token_type\":\"bearer\",\"expires_in\":2592000,\"refresh_token\":\"REFRESH_TOKEN\",\"scope\":\"read\",\"uid\":100101,\"info\":{...}\n} \n```\n\n上面 JSON 数据中，`access_token`字段就是令牌，A 网站在后端拿到了。注意：HTTP头信息中明确指定不得缓存。\n\n{#t14}{#Token_230}五、令牌（Token）传递方式\n---------------------------------\n\n当客户端（第三方应用程序）拿到访问资源服务器的令牌时，便可以使用这个令牌进行资源访问了。\n\n在第三方应用程序拿到`access_token`后，如何发送给资源服务器这个问题并没有在 RFC6729 文件中定义，而是作为一个单独的 [RFC6750](https://link.juejin.cn/?target=https%3A%2F%2Fwww.rfc-editor.org%2Frfc%2Frfc6750.txt \"RFC6750\") 文件中独立定义了。这里做以下简单的介绍，主要有三种方式如下：\n\n1.URI Query Parameter\n\n2.Authorization Request Header Field\n\n3.Form-Encoded Body Parameter\n\n### {#t15}{#51__241}5.1、请求头参数传递\n\nAuthorization Request Header Field，因为在HTTP应用层协议中，专门有定义一个授权使用的Request Header，所以也可以使用这种方式：\n\n```java\nGET /resource HTTP/1.1\nHost: server.example.com\nAuthorization: Bearer mF_9.B5f-4.1JqM \n```\n\n其中\"Bearer \"是固定的在access_token前面的头部信息。\n\n### {#t16}{#52__253}5.2、表单编码传递\n\n使用 Request Body 这种方式，有一个额外的要求，就是 Request Header 的`Content-Type`必须是固定的`application/x-www-form-urlencoded`，此外还有一个限制就是 **不可以使用 GET** 访问，这个好理解，毕竟 GET 请求是不能携带 Request Body 的。\n\n```java\nPOST /resource HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\n\naccess_token=mF_9.B5f-4.1JqM \n```\n\n### {#t17}{#53_URI__265}5.3、URI 请求参数传递\n\nURI Query Parameter，这种使用途径应该是最常见的一种方式，非常简单，比如：\n\n```java\nGET /resource?access_token=mF_9.B5f-4.1JqM HTTP/1.1\nHost: server.example.com \n```\n\n在我们请求受保护的资源的 Url 后面追加一个 access_token 的参数即可。另外还有一点要求，就是 Client 需要设置以下 Request Header 的 **Cache-Control:no-store**，用来阻止 access_token 不会被 Web 中间件给 log 下来，属于安全防护方面的一个考虑。\n\n### {#t18}{#54__276}5.4、令牌的刷新\n\n为了防止客户端使用一个令牌无限次数使用，令牌一般会有过期时间限制，当快要到期时，需要重新获取令牌，如果再重新走授权码的授权流程，对用户体验非常不好，于是 OAuth 2.0 允许用户自动更新令牌。\n\n具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。\n\n```java\nhttps://b.com/oauth/token?grant_type=refresh_token&client_id=CLIENT_ID&client_secret=CLIENT_SECRET&refresh_token=REFRESH_TOKEN \n```\n\n上面 URL 中：\n\n`grant_type`参数为`refresh_token`表示要求更新令牌，此处的值固定为`refresh_token`，必选项；\n\n`client_id`参数和`client_secret`参数用于确认身份；\n\n`refresh_token`参数就是用于更新令牌的令牌。\n\nB 网站验证通过以后，就会颁发新的令牌。\n\n**注意：** 第三方应用服务器拿到刷新令牌必须存于服务器，通过后台进行重新获取新的令牌，以保障刷新令牌的保密性。\n\n{#t19}{#OAuth2_298}六、OAuth2的安全问题\n--------------------------------\n\n### {#t20}{#61_CSRF_301}6.1、CSRF攻击\n\n应用程序在早期使用 OAuth2 的时候爆发过不少相关的安全方面的漏洞，其实仔细分析后会发现大都都是没有严格遵循 OAuth2 的安全相关的指导造成的，相关的漏洞事件自行搜索。\n\n其实 OAuth2 在设计之初是已经做了很多安全方面的考虑，并且在 RFC6749 中加入了一些安全方面的规范指导。比如：\n\n1、要求 Authorization server 进行有效的客户端验证；\n\n2、client_serect，access_token，refresh_token，code等敏感信息的安全存储（不得泄露给第三方）、传输通道的安全性（TSL的要求）；\n\n3、维持 refresh_token 和第三方应用的绑定，刷新失效机制；\n\n4、维持 Authorization Code 和第三方应用的绑定，这也是state参数为什么是推荐的一点，以防止CSRF攻击；\n\n5、保证上述各种令牌信息的不可猜测行，以防止被猜测得到；安全无小事，这方面是要靠各方面（开放平台，第三方开发者）共同防范的。\n\n### {#t21}{#62__309}6.2、攻击流程\n\n假设有用户张三，攻击者李四，第三方\"云冲印\"应用（它集成了第三方社交账号登录，并且允许用户将社交账号和\"云冲印\"中的账号进行绑定），以及 OAuth2 服务提供者 Google。\n\n![](https://i-blog.csdnimg.cn/blog_migrate/b1a4f58a179a89687ebfc0203713e017.png)\n\n**步骤1**\n\n攻击者李四登录\"云冲印\"网站，并且选择绑定自己的 Google 账号\n\n**步骤2**\n\n\"云冲印\"网站将李四重定向到 Google，由于他之前已经登录过 Google，所以 Google 直接向他显示是否授权\"云冲印\"访问的页面。\n\n**步骤3**\n\n李四在点击\"同意授权\"之后，截获 Google 服务器返回的含有`Authorization code`参数的HTTP响应。\n\n**步骤4**\n\n李四精心构造一个 Web 页面，它会触发\"云冲印\"网站向 Google 发起令牌申请的请求，而这个请求中的`Authorization Code`参数正是上一步截获到的 code。\n\n**步骤5**\n\n李四将这个 Web 页面放到互联网上，等待或者诱骗受害者张三来访问。\n\n**步骤6**\n\n张三之前登录了\"云冲印\"网站，只是没有把自己的账号和其他社交账号绑定起来。在张三访问了李四准备的这个 Web 页面，令牌申请流程在张三的浏览器里被顺利触发，\"云冲印\"网站从 Google 那里获取到`access_token`，但是这个 token 以及通过它进一步获取到的用户信息却都是攻击者李四的。\n\n**步骤7**\n\n\"云冲印\"网站将李四的 Google 账号同张三的\"云冲印\"账号关联绑定起来，从此以后，李四就可以用自己的 Google 账号通过 OAuth 登录到张三在 \"云冲印\" 网站中的账号，堂而皇之的冒充张三的身份执行各种操作。\n\n从整体上来看，本次 CSRF 攻击的时序图应该是下面这个样子的：\n\n![](https://i-blog.csdnimg.cn/blog_migrate/9a3835545d31ef1167888721bd653ec8.png)\n\n从上图中可以看出，造成 CSRF 攻击漏洞问题的关键点在于，OAuth2 的认证流程是分为好几步来完成的，在上一章节授权码模式流程中的流程图中的第 4步骤中，第三方应用在收到一个 GET 请求时，除了能知道当前用户的 cookie，以及 URL 中的`Authorization Code`之外，难以分辨出这个请求到底是用户本人的意愿，还是攻击者利用用户的身份伪造出来的请求。\n\n于是，攻击者就能使用移花接木的手段，提前准备一个含有自己的`Authorization Code`的请求，并让受害者的浏览器来接着完成后续的令牌申请流程。\n\n### {#t22}{#63__351}6.3、解决方案\n\n要防止这样的攻击其实很容易，作为第三方应用的开发者，只需在 OAuth 认证过程中加入`state`参数，并验证它的参数值即可。具体细节如下：\n\n* 在将用户重定向到资源认证服务器授权界面的时候，为当前用户生成一个随机的字符串，并作为`state`参数加入到URL中，同时存储一份到 session 中。\n* 当第三方应用收到资源服务提供者返回的`Authorization Code`请求的时候，验证接收到的`state`参数值。如果是正确合法的请求，那么此时接收到的参数值应该和上一步提到的为该用户生成的`state`参数值（存于当前用户的 session 中）完全一致，否则就是异常请求。\n* `state`参数值需要具备下面几个特性：\\* 不可预测性：足够的随机，使得攻击者难以猜到正确的参数值\\* 关联性：`state`参数值和当前用户会话（user session）是相互关联的\\* 唯一性：每个用户，甚至每次请求生成的`state`参数值都是唯一的\\* 时效性：`state`参数一旦被使用则立即失效\n\n`state`参数在 OAuth2 认证过程中不是必选参数，因此在早期第三方应用开发者在集成 OAuth2 认证的时候很容易会忽略它的存在，导致应用易受 CSRF 攻击。所以必须对这个安全问题重视起来。\n\n安全是双方的，需要第三方应用和资源服务提供商均要严格遵守安全规范。如 QQ 互联的 OAuth2 API 中，state 参数是强制必选的参数，授权接口是基于 HTTPS 的加密通道等；作为第三方开发者在使用消费这些服务的时候也应该重视注意安全中存在的漏洞。\n\n转自：[OAuth 2.0 授权认证详解_oauth2.0_GJ_ia的博客-CSDN博客](https://blog.csdn.net/GJ_ia/article/details/128663296?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-128663296-blog-127730870.235%5Ev38%5Epc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-128663296-blog-127730870.235%5Ev38%5Epc_relevant_sort_base1&utm_relevant_index=3 \"OAuth 2.0 授权认证详解_oauth2.0_GJ_ia的博客-CSDN博客\")\n', 2, 0, 1, 0, 0, 1, 'https://blog.csdn.net/fuhanghang/article/details/131394196', 1, NULL, NULL, '2025-04-27 14:51:27', '2025-04-27 22:34:14');
INSERT INTO `sys_article` VALUES (301, 1, 44, 'linux安装及管理程序', 'img/linux安装及管理程序.png', 'linux安装', '<br />\n<h4><a id=\"linux_2\"></a>linux安装及管理程序</h4>\n<ul>\n<li><a href=\"#_linux_1\">一 linux应用程序基础</a></li>\n<li>\n<ul>\n<li><a href=\"#1linux_2\">1.linux命令和应用程序的关系</a></li>\n<li><a href=\"#2linux_10\">2.linux应用程序的组成</a></li>\n<li><a href=\"#3_19\">3.软件包的封装模型</a></li>\n</ul>\n</li>\n<li><a href=\"#rpm_25\">二使用rpm软件包管理工具</a></li>\n<li>\n<ul>\n<li><a href=\"#1rpm_26\">1.rpm概述</a></li>\n<li><a href=\"#2rpm_36\">2.rpm命令的格式</a></li>\n<li><a href=\"#3rpm_42\">3.查询rpm软件包信息</a></li>\n<li>\n<ul>\n<li><a href=\"#1rpm_44\">（1）查询已安装的rpm信息</a></li>\n<li><a href=\"#2_rpm_64\">（2） 查询未安装rpm软件包的信息</a></li>\n<li><a href=\"#3rpm_70\">（3）安装，升级，卸载rpm软件包</a></li>\n<li><a href=\"#4rpm_85\">（4）维护rpm数据库</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#_97\">三，从源代码编译安装程序</a></li>\n<li>\n<ul>\n<li><a href=\"#1_98\">1源代码编译</a></li>\n<li><a href=\"#2_112\">2.编译安装的基本过程</a></li>\n</ul>\n</li>\n</ul>\n<br />\n<h2><a id=\"_linux_1_linux_content_views_26\"></a>{#_linux_1}一 linux应用程序基础 {#content_views}</h2>\n<h3><a id=\"1linux_21linux_29\"></a>{#1linux_2}1.linux命令和应用程序的关系</h3>\n<p>两者的区别如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>系统命令</th>\n<th>应用程序</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>文件位置</td>\n<td>一般在/bin和/sbin目录中，称为shell内部指令</td>\n<td>通常放在/usr/bin,/usr/sbin,/usr/local/bin,/usr/local/sbin等目录</td>\n</tr>\n<tr>\n<td>主要用途</td>\n<td>用于辅助操作系统本身的管理</td>\n<td>在操作系统之外另行安装，提供相对独立操作系统的功能</td>\n</tr>\n<tr>\n<td>适用环境</td>\n<td>命令只在字符操作界面中运行</td>\n<td>应用程序可能会用到图形界面</td>\n</tr>\n<tr>\n<td>运行格式</td>\n<td>一般包括命令字，选项，参数</td>\n<td>没有固定的执行格式</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"2linux_102linux_40\"></a>{#2linux_10}2.linux应用程序的组成</h3>\n<ul>\n<li>普通的可执行程序文件：一般保存在/usr/bin目录中，普通用户可执行</li>\n<li>服务器程序,管理程序文件：保存在/usr/sbin目录中，只有管理员可执行</li>\n<li>配置文件：保存在/etc目录中</li>\n<li>日志文件：保存在/var/log目录中</li>\n<li>关于应用程序的参考文档等数据：保存在/usr/share/doc//目录中</li>\n<li>执行文件及配置文件的man手册页：保存在/usr/share/man目录中</li>\n</ul>\n<h3><a id=\"3_193_49\"></a>{#3_19}3.软件包的封装模型</h3>\n<p>常见的软件包封装类型如下</p>\n<ul>\n<li>RPM软件包：扩展名为&quot;.rpm&quot;，只能在使用rpm（RPM package manager，rpm软件管理器）机制的linux系统上安装，rpm软件包一般针对特定版本的操作系统量身定制，依赖性强。</li>\n<li>DEB软件包：扩展名&quot;.deb&quot;，只能在使用DPKG（DebianPackage,Debian包管理器）机制的linux’系统中安装，安装DEB软件需使用dpkg命令</li>\n<li>源代码软件包：这种软件包是程序员开发完成的原始代码，一般被制作成&quot;.tar.gz&quot;或&quot;.tar.bz2&quot;等格式，安装源代码软件包需使用相对应的编译工具，如 Linux 中的 c语言编译器 gcc。</li>\n<li>附带安装程序的软件包:这种软件包的扩展名不一，但仍以 TarBa11 格式的居多。软件包中会提供用于安装的可执行程序或脚本文件，如 insta11.sh、setup 等，有时候会以&quot;.bin&quot;格式的单个安装文件形式出现。安装时只需运行安装文件就可以根据向导程序的提示完成安装操作。</li>\n</ul>\n<h2><a id=\"rpm_25rpm_58\"></a>{#rpm_25}二使用rpm软件包管理工具</h2>\n<h3><a id=\"1rpm_261rpm_61\"></a>{#1rpm_26}1.rpm概述</h3>\n<p>RPM软件包管理器通过建立统一的文件数据库，对在 Linux 操作系统中安装、卸载、升级的各种.rpm软件包进行详细的记录，并能够自动分析软件包之间的依赖关系，保持各应用程序在一个协调、有序的整体环境中运行。<br />\n使用 RPM机制封装的软件包文件拥有约定俗成的命名格式，一般使用&quot;软件名-软件版本-发布次数.操作系统类型,硬件架构类型.rpm&quot;的文件名形式，如&quot;bash-4.2.46-20.e17_2.x86_64.rpm&quot;。其中硬件平台通常为&quot;i386&quot;或&quot;i686&quot;等，表示适用于 ntel 公司的处理器，&quot;x86_64&quot;表示适用于 64 位的系统<br />\n查看光盘里的rpm包</p>\n<pre><code class=\"lang-prism\">[root@localhost ~]# mkdir /media/cdrom\n[root@localhost ~]# mount /dev/cdrom /media/cdrom    //挂载光盘\n[root@localhost ~]# cd /media/cdrom/Packages/       //光盘rpm软件包位置\n</code></pre>\n<h3><a id=\"2rpm_362rpm_73\"></a>{#2rpm_36}2.rpm命令的格式</h3>\n<p>用法：rpm [选项…]<br />\nrpm可以实现3类功能</p>\n<ul>\n<li>查询、验证 RPI 软件包的相关信息</li>\n<li>安装、升级、卸载 RPI 软件包。</li>\n<li>维护 RPI 数据库信息等综合管理操作。</li>\n</ul>\n<h3><a id=\"3rpm_423rpm_82\"></a>{#3rpm_42}3.查询rpm软件包信息</h3>\n<p>rpm 命令的查询功能主要通过&quot;-q&quot;选项实现，主要针对当前系统中已经安装的软件包;通过&quot;-qp选项可以针对尚未安装的 RPM软件包文件进行查询。根据所需查询的具体项目不同，还可以为这两个选页指定相关的子选项。</p>\n<h4><a id=\"1rpm_441rpm_86\"></a>{#1rpm_44}（1）查询已安装的rpm信息</h4>\n<p>不带子选项的&quot;-q&quot;选项可用于查询已知名称的软件包是否已经安装，需要使用准确的软件名作为参数(可以有多个)。结合不同的子选项使用时，可以实现更具体的查询。常用的几个子选项如下所述。<br />\n-qa:显示当前系统中以 RPM 方式安装的所有软件列表。<br />\n-qi:查看指定软件包的名称、版本、许可协议、用途描述等详细信息(-info)。<br />\n-ql:显示指定的软件包在当前系统中安装的所有目录、文件列表(-list)。<br />\n-qf:查看指定的文件或目录是由哪个软件包所安装的(一file)。</p>\n<blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/3b4c6314b7d04e02ac3b9f8bd94c27a8.jpeg#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>对于系统中已经安装的各种软件程序，如果不知道其中某个软件的用途，同样可以通过rpm 工具进行查询。例如 ssh 软件，可以执行&quot;rpm -qi openssh&quot;命令来了解 ssh 软件包的摘要信息，具体操作如下:</p>\n<blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/1195c8b1eeff4e9e8d293035c3463064.jpeg#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>当需要查看某个软件包安装的目录和文件清单时，可以使用&quot;-q1&quot;选项。例如，执行&quot;rpm -ql wget’命令可以列出 wget 软件包安装的目录和文件清单，具体操作如下:</p>\n<blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/48b693a0c3c547a79356d7ca079b3adb.jpeg#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>当需要知道系统中的某个文件是由哪一个软件包生成的时候，可以使用&quot;-qf&quot;选项。例如，执行以下操作可以获知 vim 编辑器程序是在安装 vim-enhanced 软件包时生成的。</p>\n<blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/decd3c1e3f4d4c309accdb14cc4ef0d5.jpeg#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h4><a id=\"2_rpm_642_rpm_104\"></a>{#2_rpm_64}（2） 查询未安装rpm软件包的信息</h4>\n<p>使用&quot;-qp&quot;选项时，必须以 RPI 软件包文件的路径作为参数(可以有多个)，而不是软件包名称。其相关的子选项与使用&quot;-q&quot;查询时类似，常用的两个查询选项如下所述。<br />\n-qpi:查看指定软件包的名称、版本、许可协议、用途描述等详细信息。<br />\n-qpl:查看该软件包准备要安装的所有目标目录、文件列表。<br />\n例如：</p>\n<blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/69bdf038b9574a31b119862ac0f24b05.jpeg#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h4><a id=\"3rpm_703rpm_112\"></a>{#3rpm_70}（3）安装，升级，卸载rpm软件包</h4>\n<p>使用 rpm命实现这些操作时，基本的命令选项如下所述。<br />\n-i：在当前系统中安装(Install)一个新的 RPM 软件包。<br />\n-e:卸载指定名称的软件包。<br />\n-U:检查并升级系统中的某个软件包，若该软件包原来并未安装，则等同于&quot;-i&quot;选项。<br />\n-F:检查并更新系统中的某个软件包，若该软件包原来并未安装，则放弃安装。<br />\n-h:在安装或升级软件包的过程中，以&quot;#&quot;号显示安装进度。<br />\n-v:显示软件安装过程中的详细信息。<br />\n-force:强制安装某个软件包，当需要替换已安装的软件包及文件，或者安装一个比当前使用的软件版本更旧的软件时，可以使用此选项。<br />\n-nodeps:在安装或升级、卸载一个软件包时，不检查与其他软件包的依赖关系。<br />\n<strong>安装操作如下：</strong><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/9e23da4e7c014078bdbb25f8cd2e365d.jpeg#pic_center\" alt=\"在这里插入图片描述\" /><br />\nethtool是 Linux 系统下的命令行工具，用于管理以太网网卡。能查网卡基本信息、链路状态，可设置速率、双工模式，控制唤醒功能，调整队列等参数，还能借助错误统计辅助诊断网络问题。<br />\n<strong>卸载软件包如下</strong><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/10bd1fdccdcb4bdcab06c2ca8a6c7310.jpeg#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"4rpm_854rpm_129\"></a>{#4rpm_85}（4）维护rpm数据库</h4>\n<p>下面维护 RPI 数据库的操作步骤。<br />\n重建 RPM 数据库<br />\nRPI 数据库用于记录在 Linux 操作系统中安装、卸载、升级应用程序的相关信息，由RPM 软件包管理系统自动完成维护，一般不需要用户干预。当 RPM数据库发生损坏(可能由误删文件、非法关机、病毒破坏等导致)，且 Linux 操作系统无法自动完成修复时，将导致无法使用 rpm 命令正常地安装、卸载及查询软件包。这时可以使用 rpm 命令的&quot;-rebuilddb&quot;或&quot;-initdb&quot;功能对 RPI 数据库进行重建，具体操作如下:</p>\n<pre><code class=\"lang-prism\">[root@localhost ~]# rpm --rebuilddb\n</code></pre>\n<p>或</p>\n<pre><code class=\"lang-prism\">[root@localhost ~]# rpm --initdb\n</code></pre>\n<h2><a id=\"_97_145\"></a>{#_97}三，从源代码编译安装程序</h2>\n<h3><a id=\"1_981_148\"></a>{#1_98}1源代码编译</h3>\n<p>我们用源码包的原因有以下几种：</p>\n<ul>\n<li>安装较新版本的应用程序时：:大多数的 Linux 发行版都提供了相当丰富的应用程序，而这些程序的版本往往滞后于该软件的最新源代码版本，因为大多数的开源软件总是以源代码的形式最先发布，之后才会逐渐出现.rpm、.deb 等二进制封装的版本。下载应用程序的最新源代码包并编译安装，可以在程序功能、安全补丁等方面得到及时更新</li>\n<li>当前安装的程序无法满足应用需求时：对于 RPM 格式封装的应用程序，一般只包含该软件所能实现的一小部分功能，而难以由用户自行修改、定制。通过对程序的源代码进行重新配置并编译安装后，可以定制更灵活、更丰富的功能。许多 Linux 服务器程序都采用源代码编译的方式进行安装，以获得更适于企业实际应用需求的服务</li>\n<li>为应用程序添加新的功能时：当需要利用现有的程序源代码进行适当的修改以便增加新的功能时必须释放出该软件的源代码，修改后再重新编译安装。<br />\n由此可得，源代码安装给使用者提供了更加灵活的程序定制途径。<br />\n编译源代码需要有相应的开发环境，对于自由软件来说，gcc和 make是最佳的编译工具。gcc 和make 是由 GNU 项目所贡献的功能强大的 c/c<ins>语言编译器，在全世界的自由软件开发者中广受欢迎<br />\n查看gcc和make工具的版本信息如下：<br />\ngcc工具默认是没有安装的所以要先安装gcc gcc-c</ins> 软件包</li>\n</ul>\n<blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/89a338a97514471bbc916fe464f5743b.jpeg#pic_center\" alt=\"在这里插入图片描述\" /><br />\nmake工具的查询<img src=\"https://i-blog.csdnimg.cn/direct/3d0359c954b84ccb96b85ecfe60a68b3.jpeg#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h3><a id=\"2_1122_163\"></a>{#2_112}2.编译安装的基本过程</h3>\n<p>编译安装的过程分为：<strong>解包，配置，编译，安装</strong><br />\n以apache软件为例，用源码包安装，Apache是运行在Linux操作系统下的 web 服务器软件，能够用于架设 web 服务器。执行下面的命令可以查看当前目录中上传的Apache服务的源代码安装包文件</p>\n<blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/dba6d460e307413cb8f9b5122f4a46a3.jpeg#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>对于从互联网中下载的软件包，建议使用 md5sum 命令工具检查MD5 校验和。例如，执行&quot;md5sum httpd-2.4.25.tar.gz&quot;操作后可计算出 httpd-2.4.25.tar.gz 软件包文件的 m5 校验和&quot;24fb8b9e36cf131d78caae864fea0f6a&quot;，操作如下所示。将其与软件官方提供的校验值进行比较，若相同则说明该软件包在网络传输过程中没有被非法改动;对于校验和不一致的软件包，应尽量不要使用，以免带来病毒、木马等不安全因素。</p>\n<blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/871bcaa35af147e7a5725810b0ecabe4.jpeg#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>在安装apache的配置时需要apr pcre等软件包的支持，这些是软件包的开发包（devel） ，以便提供相应的库和头文件，确保apache的安装顺利<br />\n先挂载光盘</p>\n<blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/30e7e68fb797452196eccd700cad6099.jpeg#pic_center\" alt=\"在这里插入图片描述\" /><br />\n安装头和库文件，这里用yum安装方便解决依赖关系<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/4f8339cf4ef14c01bcba200a14eb66a7.jpeg#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p><strong>解包</strong></p>\n<blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/6032a7acb5fb46e399881f24dc813096.jpeg#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p><strong>配置</strong><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/de5f390277a144618cecb6d11ecba49b.jpeg#pic_center\" alt=\"在这里插入图片描述\" /><br />\n<strong>编译</strong></p>\n<pre><code class=\"lang-prism\">[root@localhost ~]#   make\n</code></pre>\n<p><strong>安装</strong></p>\n<pre><code class=\"lang-prism\">[root@localhost ~]#   make install\n</code></pre>\n<p><strong>使用</strong><br />\n安装完成后需对文件进行配置调整：<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/589bde45bda346e4b636e9a4de88d3cf.jpeg#pic_center\" alt=\"在这里插入图片描述\" /><br />\n然后修改配置文件 httpd.conf 的第 195 行，将前面的’#\'去掉，保存并退出。最后启动 Apache，操作如下:<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/6ff72b03c214490b87e97b924c407256.jpeg#pic_center\" alt=\"在这里插入图片描述\" /><br />\n启动apache 并用curl命令访问127.0.0.1验证服务运行情况<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/72e1686184ce45fbb7ba6dce1f46d49c.jpeg#pic_center\" alt=\"在这里插入图片描述\" /><br />\n到这里就完成了，感谢大家的观看！！！</p>\n', '<br />\n\n#### linux安装及管理程序\n\n* [一 linux应用程序基础](#_linux_1)\n*\n  * [1.linux命令和应用程序的关系](#1linux_2)\n  * [2.linux应用程序的组成](#2linux_10)\n  * [3.软件包的封装模型](#3_19)\n* [二使用rpm软件包管理工具](#rpm_25)\n*\n  * [1.rpm概述](#1rpm_26)\n  * [2.rpm命令的格式](#2rpm_36)\n  * [3.查询rpm软件包信息](#3rpm_42)\n  *\n    * [（1）查询已安装的rpm信息](#1rpm_44)\n    * [（2） 查询未安装rpm软件包的信息](#2_rpm_64)\n    * [（3）安装，升级，卸载rpm软件包](#3rpm_70)\n    * [（4）维护rpm数据库](#4rpm_85)\n* [三，从源代码编译安装程序](#_97)\n*\n  * [1源代码编译](#1_98)\n  * [2.编译安装的基本过程](#2_112)\n\n<br />\n\n{#_linux_1}一 linux应用程序基础 {#content_views}\n-----------------------------------------\n\n### {#1linux_2}1.linux命令和应用程序的关系\n\n两者的区别如下：\n\n|      |             系统命令             |                           应用程序                           |\n|------|------------------------------|----------------------------------------------------------|\n| 文件位置 | 一般在/bin和/sbin目录中，称为shell内部指令 | 通常放在/usr/bin,/usr/sbin,/usr/local/bin,/usr/local/sbin等目录 |\n| 主要用途 | 用于辅助操作系统本身的管理                | 在操作系统之外另行安装，提供相对独立操作系统的功能                                |\n| 适用环境 | 命令只在字符操作界面中运行                | 应用程序可能会用到图形界面                                            |\n| 运行格式 | 一般包括命令字，选项，参数                | 没有固定的执行格式                                                |\n\n### {#2linux_10}2.linux应用程序的组成\n\n* 普通的可执行程序文件：一般保存在/usr/bin目录中，普通用户可执行\n* 服务器程序,管理程序文件：保存在/usr/sbin目录中，只有管理员可执行\n* 配置文件：保存在/etc目录中\n* 日志文件：保存在/var/log目录中\n* 关于应用程序的参考文档等数据：保存在/usr/share/doc//目录中\n* 执行文件及配置文件的man手册页：保存在/usr/share/man目录中\n\n### {#3_19}3.软件包的封装模型\n\n常见的软件包封装类型如下\n\n* RPM软件包：扩展名为\".rpm\"，只能在使用rpm（RPM package manager，rpm软件管理器）机制的linux系统上安装，rpm软件包一般针对特定版本的操作系统量身定制，依赖性强。\n* DEB软件包：扩展名\".deb\"，只能在使用DPKG（DebianPackage,Debian包管理器）机制的linux\'系统中安装，安装DEB软件需使用dpkg命令\n* 源代码软件包：这种软件包是程序员开发完成的原始代码，一般被制作成\".tar.gz\"或\".tar.bz2\"等格式，安装源代码软件包需使用相对应的编译工具，如 Linux 中的 c语言编译器 gcc。\n* 附带安装程序的软件包:这种软件包的扩展名不一，但仍以 TarBa11 格式的居多。软件包中会提供用于安装的可执行程序或脚本文件，如 insta11.sh、setup 等，有时候会以\".bin\"格式的单个安装文件形式出现。安装时只需运行安装文件就可以根据向导程序的提示完成安装操作。\n\n{#rpm_25}二使用rpm软件包管理工具\n----------------------\n\n### {#1rpm_26}1.rpm概述\n\nRPM软件包管理器通过建立统一的文件数据库，对在 Linux 操作系统中安装、卸载、升级的各种.rpm软件包进行详细的记录，并能够自动分析软件包之间的依赖关系，保持各应用程序在一个协调、有序的整体环境中运行。  \n使用 RPM机制封装的软件包文件拥有约定俗成的命名格式，一般使用\"软件名-软件版本-发布次数.操作系统类型,硬件架构类型.rpm\"的文件名形式，如\"bash-4.2.46-20.e17_2.x86_64.rpm\"。其中硬件平台通常为\"i386\"或\"i686\"等，表示适用于 ntel 公司的处理器，\"x86_64\"表示适用于 64 位的系统  \n查看光盘里的rpm包\n\n```prism language-bash\n[root@localhost ~]# mkdir /media/cdrom\n[root@localhost ~]# mount /dev/cdrom /media/cdrom    //挂载光盘\n[root@localhost ~]# cd /media/cdrom/Packages/       //光盘rpm软件包位置\n```\n\n### {#2rpm_36}2.rpm命令的格式\n\n用法：rpm \\[选项...\\]  \nrpm可以实现3类功能\n\n* 查询、验证 RPI 软件包的相关信息\n* 安装、升级、卸载 RPI 软件包。\n* 维护 RPI 数据库信息等综合管理操作。\n\n### {#3rpm_42}3.查询rpm软件包信息\n\nrpm 命令的查询功能主要通过\"-q\"选项实现，主要针对当前系统中已经安装的软件包;通过\"-qp选项可以针对尚未安装的 RPM软件包文件进行查询。根据所需查询的具体项目不同，还可以为这两个选页指定相关的子选项。\n\n#### {#1rpm_44}（1）查询已安装的rpm信息\n\n不带子选项的\"-q\"选项可用于查询已知名称的软件包是否已经安装，需要使用准确的软件名作为参数(可以有多个)。结合不同的子选项使用时，可以实现更具体的查询。常用的几个子选项如下所述。  \n-qa:显示当前系统中以 RPM 方式安装的所有软件列表。  \n-qi:查看指定软件包的名称、版本、许可协议、用途描述等详细信息(-info)。  \n-ql:显示指定的软件包在当前系统中安装的所有目录、文件列表(-list)。  \n-qf:查看指定的文件或目录是由哪个软件包所安装的(一file)。\n> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3b4c6314b7d04e02ac3b9f8bd94c27a8.jpeg#pic_center)\n\n对于系统中已经安装的各种软件程序，如果不知道其中某个软件的用途，同样可以通过rpm 工具进行查询。例如 ssh 软件，可以执行\"rpm -qi openssh\"命令来了解 ssh 软件包的摘要信息，具体操作如下:\n> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1195c8b1eeff4e9e8d293035c3463064.jpeg#pic_center)\n\n当需要查看某个软件包安装的目录和文件清单时，可以使用\"-q1\"选项。例如，执行\"rpm -ql wget\'命令可以列出 wget 软件包安装的目录和文件清单，具体操作如下:\n> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/48b693a0c3c547a79356d7ca079b3adb.jpeg#pic_center)\n\n当需要知道系统中的某个文件是由哪一个软件包生成的时候，可以使用\"-qf\"选项。例如，执行以下操作可以获知 vim 编辑器程序是在安装 vim-enhanced 软件包时生成的。\n> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/decd3c1e3f4d4c309accdb14cc4ef0d5.jpeg#pic_center)\n\n#### {#2_rpm_64}（2） 查询未安装rpm软件包的信息\n\n使用\"-qp\"选项时，必须以 RPI 软件包文件的路径作为参数(可以有多个)，而不是软件包名称。其相关的子选项与使用\"-q\"查询时类似，常用的两个查询选项如下所述。  \n-qpi:查看指定软件包的名称、版本、许可协议、用途描述等详细信息。  \n-qpl:查看该软件包准备要安装的所有目标目录、文件列表。  \n例如：\n> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/69bdf038b9574a31b119862ac0f24b05.jpeg#pic_center)\n\n#### {#3rpm_70}（3）安装，升级，卸载rpm软件包\n\n使用 rpm命实现这些操作时，基本的命令选项如下所述。  \n-i：在当前系统中安装(Install)一个新的 RPM 软件包。  \n-e:卸载指定名称的软件包。  \n-U:检查并升级系统中的某个软件包，若该软件包原来并未安装，则等同于\"-i\"选项。  \n-F:检查并更新系统中的某个软件包，若该软件包原来并未安装，则放弃安装。  \n-h:在安装或升级软件包的过程中，以\"#\"号显示安装进度。  \n-v:显示软件安装过程中的详细信息。  \n-force:强制安装某个软件包，当需要替换已安装的软件包及文件，或者安装一个比当前使用的软件版本更旧的软件时，可以使用此选项。  \n-nodeps:在安装或升级、卸载一个软件包时，不检查与其他软件包的依赖关系。  \n**安装操作如下：**   \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9e23da4e7c014078bdbb25f8cd2e365d.jpeg#pic_center)  \nethtool是 Linux 系统下的命令行工具，用于管理以太网网卡。能查网卡基本信息、链路状态，可设置速率、双工模式，控制唤醒功能，调整队列等参数，还能借助错误统计辅助诊断网络问题。  \n**卸载软件包如下**   \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/10bd1fdccdcb4bdcab06c2ca8a6c7310.jpeg#pic_center)\n\n#### {#4rpm_85}（4）维护rpm数据库\n\n下面维护 RPI 数据库的操作步骤。  \n重建 RPM 数据库  \nRPI 数据库用于记录在 Linux 操作系统中安装、卸载、升级应用程序的相关信息，由RPM 软件包管理系统自动完成维护，一般不需要用户干预。当 RPM数据库发生损坏(可能由误删文件、非法关机、病毒破坏等导致)，且 Linux 操作系统无法自动完成修复时，将导致无法使用 rpm 命令正常地安装、卸载及查询软件包。这时可以使用 rpm 命令的\"-rebuilddb\"或\"-initdb\"功能对 RPI 数据库进行重建，具体操作如下:\n\n```prism language-bash\n[root@localhost ~]# rpm --rebuilddb\n```\n\n或\n\n```prism language-bash\n[root@localhost ~]# rpm --initdb\n```\n\n{#_97}三，从源代码编译安装程序\n------------------\n\n### {#1_98}1源代码编译\n\n我们用源码包的原因有以下几种：\n\n* 安装较新版本的应用程序时：:大多数的 Linux 发行版都提供了相当丰富的应用程序，而这些程序的版本往往滞后于该软件的最新源代码版本，因为大多数的开源软件总是以源代码的形式最先发布，之后才会逐渐出现.rpm、.deb 等二进制封装的版本。下载应用程序的最新源代码包并编译安装，可以在程序功能、安全补丁等方面得到及时更新\n* 当前安装的程序无法满足应用需求时：对于 RPM 格式封装的应用程序，一般只包含该软件所能实现的一小部分功能，而难以由用户自行修改、定制。通过对程序的源代码进行重新配置并编译安装后，可以定制更灵活、更丰富的功能。许多 Linux 服务器程序都采用源代码编译的方式进行安装，以获得更适于企业实际应用需求的服务\n* 为应用程序添加新的功能时：当需要利用现有的程序源代码进行适当的修改以便增加新的功能时必须释放出该软件的源代码，修改后再重新编译安装。  \n  由此可得，源代码安装给使用者提供了更加灵活的程序定制途径。  \n  编译源代码需要有相应的开发环境，对于自由软件来说，gcc和 make是最佳的编译工具。gcc 和make 是由 GNU 项目所贡献的功能强大的 c/c++语言编译器，在全世界的自由软件开发者中广受欢迎  \n  查看gcc和make工具的版本信息如下：  \n  gcc工具默认是没有安装的所以要先安装gcc gcc-c++ 软件包\n\n> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/89a338a97514471bbc916fe464f5743b.jpeg#pic_center)  \n> make工具的查询![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3d0359c954b84ccb96b85ecfe60a68b3.jpeg#pic_center)\n\n### {#2_112}2.编译安装的基本过程\n\n编译安装的过程分为：**解包，配置，编译，安装**   \n以apache软件为例，用源码包安装，Apache是运行在Linux操作系统下的 web 服务器软件，能够用于架设 web 服务器。执行下面的命令可以查看当前目录中上传的Apache服务的源代码安装包文件\n> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dba6d460e307413cb8f9b5122f4a46a3.jpeg#pic_center)\n\n对于从互联网中下载的软件包，建议使用 md5sum 命令工具检查MD5 校验和。例如，执行\"md5sum httpd-2.4.25.tar.gz\"操作后可计算出 httpd-2.4.25.tar.gz 软件包文件的 m5 校验和\"24fb8b9e36cf131d78caae864fea0f6a\"，操作如下所示。将其与软件官方提供的校验值进行比较，若相同则说明该软件包在网络传输过程中没有被非法改动;对于校验和不一致的软件包，应尽量不要使用，以免带来病毒、木马等不安全因素。\n> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/871bcaa35af147e7a5725810b0ecabe4.jpeg#pic_center)\n\n在安装apache的配置时需要apr pcre等软件包的支持，这些是软件包的开发包（devel） ，以便提供相应的库和头文件，确保apache的安装顺利  \n先挂载光盘\n> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/30e7e68fb797452196eccd700cad6099.jpeg#pic_center)  \n> 安装头和库文件，这里用yum安装方便解决依赖关系  \n> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4f8339cf4ef14c01bcba200a14eb66a7.jpeg#pic_center)\n\n**解包**\n> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6032a7acb5fb46e399881f24dc813096.jpeg#pic_center)\n\n**配置**   \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/de5f390277a144618cecb6d11ecba49b.jpeg#pic_center)  \n**编译**\n\n```prism language-bash\n[root@localhost ~]#   make\n```\n\n**安装**\n\n```prism language-bash\n[root@localhost ~]#   make install\n```\n\n**使用**   \n安装完成后需对文件进行配置调整：  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/589bde45bda346e4b636e9a4de88d3cf.jpeg#pic_center)  \n然后修改配置文件 httpd.conf 的第 195 行，将前面的\'#\'去掉，保存并退出。最后启动 Apache，操作如下:  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6ff72b03c214490b87e97b924c407256.jpeg#pic_center)  \n启动apache 并用curl命令访问127.0.0.1验证服务运行情况  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/72e1686184ce45fbb7ba6dce1f46d49c.jpeg#pic_center)  \n到这里就完成了，感谢大家的观看！！！\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/king05yh/article/details/147423957?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-04-28 16:42:35', '2025-04-28 18:07:49');
INSERT INTO `sys_article` VALUES (302, 1, 39, '用 DeepSeek 打造你的超强代码助手', 'img/用 DeepSeek 打造你的超强代码助手.png', 'DeepSeek ', '<h3><a id=\"DeepSeek_Engineer__1\"></a>DeepSeek Engineer 是啥？</h3>\n<p>简单来说，<strong>DeepSeek Engineer</strong> 是一个基于命令行的智能助手。它能帮你完成这些事：</p>\n<ul>\n<li><strong>快速读文件内容</strong>：比如你有个配置文件，直接用命令把它加载进助手，后续所有操作都可以基于这个文件。</li>\n<li><strong>自动改文件</strong>：它不仅能提建议，还可以直接生成差异表（diff），甚至自动应用修改。</li>\n<li><strong>智能代码生成</strong>：比如你让它生成代码片段，它会按照指定格式和规则直接返回。</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/7f28e0203e7440a2a5b0b3594223af6d.png\" alt=\"在这里插入图片描述\" /></p>\n<p>更重要的是，这一切都是通过 DeepSeek 的强大 API 来实现的。想象一下，你有个贴身助手，不仅能听懂你的代码需求，还能直接动手帮你写！</p>\n<hr />\n<h3><a id=\"_19_15\"></a>{#_19}核心功能拆解</h3>\n<p>我们先来看 DeepSeek Engineer 的几个核心能力，让你更好地理解它的强大之处。</p>\n<h4><a id=\"1__DeepSeek__241__DeepSeek__19\"></a>{#1__DeepSeek__24}1. 自动配置 DeepSeek 客户端</h4>\n<p>启动这个工具时，你只需要准备一个 <code>.env</code> 文件，里面写上你的 API Key，比如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">DEEPSEEK_API_KEY=your_api_key_here\n\n</code></div></pre>\n<p>然后它会自动帮你连接到 DeepSeek 的服务器（地址通过环境变量配置）。接下来，所有的对话和操作都走这个 API，让你体验到类似 GPT 的流畅交互。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/29e47b92c95546f4915797929ae9d5d9.png\" alt=\"在这里插入图片描述\" /></p>\n<hr />\n<h4><a id=\"2__402__34\"></a>{#2__40}2. 数据模型：严格又灵活</h4>\n<p>DeepSeek Engineer 使用了 <strong>Pydantic</strong> 来定义和管理数据模型，这保证了所有操作都很安全且清晰。比如，它的模型包括以下几个部分：</p>\n<ul>\n<li><strong>FileToCreate</strong>：描述新建或更新的文件。</li>\n<li><strong>FileToEdit</strong>：定义某个文件里需要替换的代码片段。</li>\n<li><strong>AssistantResponse</strong>：用来结构化处理助手返回的对话内容和文件操作。</li>\n</ul>\n<p>具体来说，如果你想改文件内容，可以让它返回一个 JSON 格式的修改建议，类似这样：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">{\n  <span class=\"hljs-string\">&quot;file&quot;</span>: <span class=\"hljs-string\">&quot;example.py&quot;</span>,\n  <span class=\"hljs-string\">&quot;changes&quot;</span>: [\n    {\n      <span class=\"hljs-string\">&quot;original&quot;</span>: <span class=\"hljs-string\">&quot;print(&#x27;Hello&#x27;)&quot;</span>,\n      <span class=\"hljs-string\">&quot;replacement&quot;</span>: <span class=\"hljs-string\">&quot;print(&#x27;Hello, DeepSeek!&#x27;)&quot;</span>\n    }\n  ]\n}\n\n</code></div></pre>\n<p>这种方式既直观又安全，你完全可以放心地应用这些修改。</p>\n<hr />\n<h4><a id=\"3__Prompt_673__Prompt_61\"></a>{#3__Prompt_67}3. 强大的系统 Prompt</h4>\n<p>DeepSeek Engineer 背后有一个设计得非常好的系统 Prompt，它会引导对话始终输出结构化的 JSON 数据，同时还能支持文件创建和编辑操作。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/70a89d4247074e7f8b41f7ee32a33bec.png\" alt=\"在这里插入图片描述\" /></p>\n<p>这个设计的好处是，开发者不用担心助手回复出错或格式混乱。所有的响应都像程序接口一样，清晰、标准。</p>\n<hr />\n<h4><a id=\"4__Helper__784__Helper__71\"></a>{#4__Helper__78}4. 常用 Helper 函数</h4>\n<p>工具中还提供了一些实用的函数，专门用来操作文件和内容：</p>\n<ul>\n<li><strong><code>read_local_file</code></strong>：快速读取本地文件内容，返回成字符串。</li>\n<li><strong><code>create_file</code></strong>：帮你新建或覆盖文件。</li>\n<li><strong><code>show_diff_table</code></strong>：生成一个漂亮的差异表，展示文件修改前后的对比。</li>\n<li><strong><code>apply_diff_edit</code></strong>：直接应用代码片段级别的修改。</li>\n</ul>\n<p>比如，你想更新一个文件里的某段代码，只需输入以下命令：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">/add path/to/file\n\n</code></div></pre>\n<p>DeepSeek 会把这个文件的内容加载进来，你可以继续对话，让它生成修改建议并直接应用到文件中。</p>\n<hr />\n<h4><a id=\"5__985__91\"></a>{#5__98}5. 交互式会话</h4>\n<p>运行主程序（比如 <code>python3 main.py</code>），你会进入一个交互式的命令行界面。这里你可以随时输入请求、加载文件，或者让助手生成代码。</p>\n<p>完整操作流程可以是这样的：</p>\n<ol>\n<li>\n<p>启动工具：```<br />\npython3 main.py</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">\n</code></div></pre>\n</li>\n<li>\n<p>加载一个文件：```<br />\n/add example.py</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">\n</code></div></pre>\n</li>\n<li>\n<p>让助手修改内容：```<br />\n请把函数 <code>foo</code> 改成返回值为整数。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">\n</code></div></pre>\n</li>\n<li>\n<p>查看生成的建议并确认应用。</p>\n</li>\n</ol>\n<p>是不是很贴心？</p>\n<hr />\n<h3><a id=\"_125_124\"></a>{#_125}与其他工具的对比</h3>\n<p>市面上其实有不少类似的代码助手，比如 GitHub Copilot、TabNine 等。那么 DeepSeek Engineer 和它们相比有什么特别之处呢？我们通过下表来简单对比一下：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>DeepSeek Engineer</th>\n<th>GitHub Copilot</th>\n<th>TabNine</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>文件内容读取</td>\n<td>✅ 支持</td>\n<td>❌ 不支持</td>\n<td>❌ 不支持</td>\n</tr>\n<tr>\n<td>文件修改和应用</td>\n<td>✅ 支持</td>\n<td>❌ 不支持</td>\n<td>❌ 不支持</td>\n</tr>\n<tr>\n<td>JSON 响应结构化</td>\n<td>✅ 内置支持</td>\n<td>❌ 不支持</td>\n<td>❌ 不支持</td>\n</tr>\n<tr>\n<td>离线使用</td>\n<td>❌ 需要联网</td>\n<td>❌ 需要联网</td>\n<td>✅ 部分支持</td>\n</tr>\n<tr>\n<td>灵活性和可定制性</td>\n<td>✅ 可配置 Prompt</td>\n<td>❌ 不支持</td>\n<td>❌ 不支持</td>\n</tr>\n</tbody>\n</table>\n<p>可以看出，DeepSeek Engineer 更加注重文件操作和开发流程的实际需求，非常适合需要精确控制和定制化的场景。</p>\n<hr />\n<h3><a id=\"_142_140\"></a>{#_142}如何快速上手？</h3>\n<p>最后，说点大家最关心的：怎么用？</p>\n<ol>\n<li>\n<p><strong>准备环境</strong></p>\n<ul>\n<li>\n<p>安装依赖：```<br />\npip install -r requirements.txt</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">\n</code></div></pre>\n</li>\n<li>\n<p>配置 API Key：创建 <code>.env</code> 文件，写入你的 Key。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>启动工具</strong></p>\n<ul>\n<li>\n<p>直接运行主程序：```<br />\npython3 main.py</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">\n</code></div></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>体验功能</strong></p>\n<ul>\n<li>\n<p>用 <code>/add</code> 命令加载文件：```<br />\n/add your_file.py</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">\n</code></div></pre>\n</li>\n<li>\n<p>提出需求，让助手生成代码或修改建议。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>探索更多用法</strong></p>\n<ul>\n<li>修改配置，试试用不同的环境变量自定义连接方式。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3><a id=\"__AI_176__AI_181\"></a>{#__AI_176}如何零基础入门 / 学习AI大模型？</h3>\n<p>大模型时代，火爆出圈的LLM大模型让程序员们开始重新评估自己的本领。 “<code>AI会取代那些行业？</code>”&quot;<code>谁的饭碗又将不保了？</code>&quot;等问题热议不断。</p>\n<p>不如成为<code>「掌握AI工具的技术人」</code>，毕竟AI时代，<strong>谁先尝试，谁就能占得先机！</strong></p>\n<p>想正式转到一些新兴的 AI 行业，不仅需要系统的学习AI大模型。同时也要跟已有的技能结合，辅助编程提效，或上手实操应用，增加自己的职场竞争力。</p>\n<p><strong>但是LLM相关的内容很多，现在网上的老课程老教材关于LLM又太少。所以现在小白入门就只能靠自学，学习成本和门槛很高</strong></p>\n<p>那么我作为一名热心肠的互联网老兵，<strong>我意识到有很多经验和知识值得分享给大家，希望可以帮助到更多学习大模型的人！<strong>至于能学习到多少就看你的学习毅力和能力了 。</strong> <code>我已将重要的AI大模型资料包括AI大模型入门学习思维导图、精品AI大模型学习书籍手册、视频教程、实战学习等录播视频免费分享出来。</code></strong></p>\n<p><strong>这份完整版的大模型 AI 学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【<code>保证100%免费</code>】</strong><br />\n<img src=\"https://i-blog.csdnimg.cn/img_convert/081da29992e52fdd6785e11039fba33c.jpeg\" alt=\"\" /></p>\n<p>👉 <strong><code>福利来袭</code><a href=\"https://mp.weixin.qq.com/s/zHr-AIrnRe1xGnel0X_8Lw\" target=\"_blank\">CSDN大礼包：《2025最全AI大模型学习资源包》免费分享，安全可点</a></strong> 👈</p>\n<h5><a id=\"httpsblogcsdnnetpython12345_articledetails145053759spm1001201430015501AGI_193httpsblogcsdnnetpython12345_articledetails145053759spm1001201430015501AGI_198\"></a>{#httpsblogcsdnnetpython12345_articledetails145053759spm1001201430015501AGI_193}<a href=\"https://blog.csdn.net/python12345_/article/details/145053759?spm=1001.2014.3001.5501\" target=\"_blank\"></a>全套AGI大模型学习大纲+路线</h5>\n<p><strong>AI大模型时代的学习之旅：从基础到前沿，掌握人工智能的核心技能！</strong></p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/931f5844f5f5f234502114beb1e96a8f.webp?x-oss-process=image/format,png\" alt=\"read-normal-img\" /></p>\n<h5><a id=\"httpsblogcsdnnetpython12345_articledetails145053759spm1001201430015501640AI_199httpsblogcsdnnetpython12345_articledetails145053759spm1001201430015501640AI_204\"></a>{#httpsblogcsdnnetpython12345_articledetails145053759spm1001201430015501640AI_199}<a href=\"https://blog.csdn.net/python12345_/article/details/145053759?spm=1001.2014.3001.5501\" target=\"_blank\"></a>640套AI大模型报告合集</h5>\n<p>这套包含640份报告的合集，涵盖了AI大模型的理论研究、技术实现、行业应用等多个方面。无论您是科研人员、工程师，还是对AI大模型感兴趣的爱好者，这套报告合集都将为您提供宝贵的信息和启示。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/2e31d1fa52b8492bba48e79fb6af88ad.jpeg\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/fd4cfd7bc88f4bb494dddc33eeaeef44.jpeg\" alt=\"在这里插入图片描述\" /></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/9645369170d94871be669f4ae97a2427.jpeg\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/aed1a6d84457483689f4f781e8611504.jpeg\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>👉学会后的收获：👈</strong><br />\n• <strong>基于大模型全栈工程实现</strong>（前端、后端、产品经理、设计、数据分析等），通过这门课可获得不同能力；</p>\n<p>• <strong>能够利用大模型解决相关实际项目需求</strong>： 大数据时代，越来越多的企业和机构需要处理海量数据，利用大模型技术可以更好地处理这些数据，提高数据分析和决策的准确性。因此，掌握大模型应用开发技能，可以让程序员更好地应对实际项目需求；</p>\n<p>• 基于大模型和企业数据AI应用开发，<strong>实现大模型理论、掌握GPU算力、硬件、LangChain开发框架和项目实战技能</strong>， 学会Fine-tuning垂直训练大模型（数据准备、数据蒸馏、大模型部署）一站式掌握；</p>\n<p>• <strong>能够完成时下热门大模型垂直领域模型训练能力，提高程序员的编码能力</strong>： 大模型应用开发需要掌握机器学习算法、深度学习框架等技术，这些技术的掌握可以提高程序员的编码能力和分析能力，让程序员更加熟练地编写高质量的代码。</p>\n<p>👉 <strong><code>福利来袭</code><a href=\"https://mp.weixin.qq.com/s/zHr-AIrnRe1xGnel0X_8Lw\" target=\"_blank\">CSDN大礼包：《2025最全AI大模型学习资源包》免费分享，安全可点</a></strong> 👈</p>\n<p><img src=\"https://img-blog.csdnimg.cn/direct/e2c57b566ffe4451861ff9c6db375266.jpeg#pic_center\" alt=\"img\" /></p>\n<p><strong>这份完整版的大模型 AI 学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【<code>保证100%免费</code>】</strong><br />\n<img src=\"https://i-blog.csdnimg.cn/img_convert/081da29992e52fdd6785e11039fba33c.jpeg\" alt=\"\" /><br />\n<strong>作为普通人，入局大模型时代需要持续学习和实践，不断提高自己的技能和认知水平，同时也需要有责任感和伦理意识，为人工智能的健康发展贡献力量。</strong></p>\n', '\n### DeepSeek Engineer 是啥？\n\n简单来说，**DeepSeek Engineer** 是一个基于命令行的智能助手。它能帮你完成这些事：\n\n* **快速读文件内容**：比如你有个配置文件，直接用命令把它加载进助手，后续所有操作都可以基于这个文件。\n* **自动改文件**：它不仅能提建议，还可以直接生成差异表（diff），甚至自动应用修改。\n* **智能代码生成**：比如你让它生成代码片段，它会按照指定格式和规则直接返回。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7f28e0203e7440a2a5b0b3594223af6d.png)\n\n更重要的是，这一切都是通过 DeepSeek 的强大 API 来实现的。想象一下，你有个贴身助手，不仅能听懂你的代码需求，还能直接动手帮你写！\n\n*** ** * ** ***\n\n### {#_19}核心功能拆解\n\n我们先来看 DeepSeek Engineer 的几个核心能力，让你更好地理解它的强大之处。\n\n#### {#1__DeepSeek__24}1. 自动配置 DeepSeek 客户端\n\n启动这个工具时，你只需要准备一个 `.env` 文件，里面写上你的 API Key，比如：\n\n```java\nDEEPSEEK_API_KEY=your_api_key_here\n\n```\n\n然后它会自动帮你连接到 DeepSeek 的服务器（地址通过环境变量配置）。接下来，所有的对话和操作都走这个 API，让你体验到类似 GPT 的流畅交互。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/29e47b92c95546f4915797929ae9d5d9.png)\n\n*** ** * ** ***\n\n#### {#2__40}2. 数据模型：严格又灵活\n\nDeepSeek Engineer 使用了 **Pydantic** 来定义和管理数据模型，这保证了所有操作都很安全且清晰。比如，它的模型包括以下几个部分：\n\n* **FileToCreate**：描述新建或更新的文件。\n* **FileToEdit**：定义某个文件里需要替换的代码片段。\n* **AssistantResponse**：用来结构化处理助手返回的对话内容和文件操作。\n\n具体来说，如果你想改文件内容，可以让它返回一个 JSON 格式的修改建议，类似这样：\n\n```java\n{\n  \"file\": \"example.py\",\n  \"changes\": [\n    {\n      \"original\": \"print(\'Hello\')\",\n      \"replacement\": \"print(\'Hello, DeepSeek!\')\"\n    }\n  ]\n}\n\n```\n\n这种方式既直观又安全，你完全可以放心地应用这些修改。\n\n*** ** * ** ***\n\n#### {#3__Prompt_67}3. 强大的系统 Prompt\n\nDeepSeek Engineer 背后有一个设计得非常好的系统 Prompt，它会引导对话始终输出结构化的 JSON 数据，同时还能支持文件创建和编辑操作。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/70a89d4247074e7f8b41f7ee32a33bec.png)\n\n这个设计的好处是，开发者不用担心助手回复出错或格式混乱。所有的响应都像程序接口一样，清晰、标准。\n\n*** ** * ** ***\n\n#### {#4__Helper__78}4. 常用 Helper 函数\n\n工具中还提供了一些实用的函数，专门用来操作文件和内容：\n\n* **`read_local_file`**：快速读取本地文件内容，返回成字符串。\n* **`create_file`**：帮你新建或覆盖文件。\n* **`show_diff_table`**：生成一个漂亮的差异表，展示文件修改前后的对比。\n* **`apply_diff_edit`**：直接应用代码片段级别的修改。\n\n比如，你想更新一个文件里的某段代码，只需输入以下命令：\n\n```java\n/add path/to/file\n\n```\n\nDeepSeek 会把这个文件的内容加载进来，你可以继续对话，让它生成修改建议并直接应用到文件中。\n\n*** ** * ** ***\n\n#### {#5__98}5. 交互式会话\n\n运行主程序（比如 `python3 main.py`），你会进入一个交互式的命令行界面。这里你可以随时输入请求、加载文件，或者让助手生成代码。\n\n完整操作流程可以是这样的：\n\n1. 启动工具：\\`\\`\\`  \n   python3 main.py\n\n   ```java\n\n   ```\n\n2. 加载一个文件：\\`\\`\\`  \n   /add example.py\n\n   ```java\n\n   ```\n\n3. 让助手修改内容：\\`\\`\\`  \n   请把函数 `foo` 改成返回值为整数。\n\n   ```java\n\n   ```\n\n4. 查看生成的建议并确认应用。\n\n是不是很贴心？\n\n*** ** * ** ***\n\n### {#_125}与其他工具的对比\n\n市面上其实有不少类似的代码助手，比如 GitHub Copilot、TabNine 等。那么 DeepSeek Engineer 和它们相比有什么特别之处呢？我们通过下表来简单对比一下：\n\n|     功能     | DeepSeek Engineer | GitHub Copilot | TabNine |\n|------------|-------------------|----------------|---------|\n| 文件内容读取     | ✅ 支持              | ❌ 不支持          | ❌ 不支持   |\n| 文件修改和应用    | ✅ 支持              | ❌ 不支持          | ❌ 不支持   |\n| JSON 响应结构化 | ✅ 内置支持            | ❌ 不支持          | ❌ 不支持   |\n| 离线使用       | ❌ 需要联网            | ❌ 需要联网         | ✅ 部分支持  |\n| 灵活性和可定制性   | ✅ 可配置 Prompt      | ❌ 不支持          | ❌ 不支持   |\n\n可以看出，DeepSeek Engineer 更加注重文件操作和开发流程的实际需求，非常适合需要精确控制和定制化的场景。\n\n*** ** * ** ***\n\n### {#_142}如何快速上手？\n\n最后，说点大家最关心的：怎么用？\n\n1. **准备环境**\n\n   * 安装依赖：\\`\\`\\`  \n     pip install -r requirements.txt\n\n     ```java\n\n     ```\n\n   * 配置 API Key：创建 `.env` 文件，写入你的 Key。\n\n2. **启动工具**\n\n   * 直接运行主程序：\\`\\`\\`  \n     python3 main.py\n\n     ```java\n\n     ```\n\n3. **体验功能**\n\n   * 用 `/add` 命令加载文件：\\`\\`\\`  \n     /add your_file.py\n\n     ```java\n\n     ```\n\n   * 提出需求，让助手生成代码或修改建议。\n\n4. **探索更多用法**\n\n   * 修改配置，试试用不同的环境变量自定义连接方式。\n\n*** ** * ** ***\n\n### {#__AI_176}如何零基础入门 / 学习AI大模型？\n\n大模型时代，火爆出圈的LLM大模型让程序员们开始重新评估自己的本领。 \"`AI会取代那些行业？`\"\"`谁的饭碗又将不保了？`\"等问题热议不断。\n\n不如成为`「掌握AI工具的技术人」`，毕竟AI时代，**谁先尝试，谁就能占得先机！**\n\n想正式转到一些新兴的 AI 行业，不仅需要系统的学习AI大模型。同时也要跟已有的技能结合，辅助编程提效，或上手实操应用，增加自己的职场竞争力。\n\n**但是LLM相关的内容很多，现在网上的老课程老教材关于LLM又太少。所以现在小白入门就只能靠自学，学习成本和门槛很高**\n\n那么我作为一名热心肠的互联网老兵，**我意识到有很多经验和知识值得分享给大家，希望可以帮助到更多学习大模型的人！**至于能学习到多少就看你的学习毅力和能力了 。** `我已将重要的AI大模型资料包括AI大模型入门学习思维导图、精品AI大模型学习书籍手册、视频教程、实战学习等录播视频免费分享出来。`**\n\n**这份完整版的大模型 AI 学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【`保证100%免费`】**   \n![](https://i-blog.csdnimg.cn/img_convert/081da29992e52fdd6785e11039fba33c.jpeg)\n\n👉 **`福利来袭`[CSDN大礼包：《2025最全AI大模型学习资源包》免费分享，安全可点](https://mp.weixin.qq.com/s/zHr-AIrnRe1xGnel0X_8Lw)** 👈\n\n##### {#httpsblogcsdnnetpython12345_articledetails145053759spm1001201430015501AGI_193}[](https://blog.csdn.net/python12345_/article/details/145053759?spm=1001.2014.3001.5501)全套AGI大模型学习大纲+路线\n\n**AI大模型时代的学习之旅：从基础到前沿，掌握人工智能的核心技能！**\n\n![read-normal-img](https://i-blog.csdnimg.cn/img_convert/931f5844f5f5f234502114beb1e96a8f.webp?x-oss-process=image/format,png)\n\n##### {#httpsblogcsdnnetpython12345_articledetails145053759spm1001201430015501640AI_199}[](https://blog.csdn.net/python12345_/article/details/145053759?spm=1001.2014.3001.5501)640套AI大模型报告合集\n\n这套包含640份报告的合集，涵盖了AI大模型的理论研究、技术实现、行业应用等多个方面。无论您是科研人员、工程师，还是对AI大模型感兴趣的爱好者，这套报告合集都将为您提供宝贵的信息和启示。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2e31d1fa52b8492bba48e79fb6af88ad.jpeg)  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fd4cfd7bc88f4bb494dddc33eeaeef44.jpeg)\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9645369170d94871be669f4ae97a2427.jpeg)  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aed1a6d84457483689f4f781e8611504.jpeg)\n\n**👉学会后的收获：👈**   \n• **基于大模型全栈工程实现**（前端、后端、产品经理、设计、数据分析等），通过这门课可获得不同能力；\n\n• **能够利用大模型解决相关实际项目需求**： 大数据时代，越来越多的企业和机构需要处理海量数据，利用大模型技术可以更好地处理这些数据，提高数据分析和决策的准确性。因此，掌握大模型应用开发技能，可以让程序员更好地应对实际项目需求；\n\n• 基于大模型和企业数据AI应用开发，**实现大模型理论、掌握GPU算力、硬件、LangChain开发框架和项目实战技能**， 学会Fine-tuning垂直训练大模型（数据准备、数据蒸馏、大模型部署）一站式掌握；\n\n• **能够完成时下热门大模型垂直领域模型训练能力，提高程序员的编码能力**： 大模型应用开发需要掌握机器学习算法、深度学习框架等技术，这些技术的掌握可以提高程序员的编码能力和分析能力，让程序员更加熟练地编写高质量的代码。\n\n👉 **`福利来袭`[CSDN大礼包：《2025最全AI大模型学习资源包》免费分享，安全可点](https://mp.weixin.qq.com/s/zHr-AIrnRe1xGnel0X_8Lw)** 👈\n\n![img](https://img-blog.csdnimg.cn/direct/e2c57b566ffe4451861ff9c6db375266.jpeg#pic_center)\n\n**这份完整版的大模型 AI 学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【`保证100%免费`】**   \n![](https://i-blog.csdnimg.cn/img_convert/081da29992e52fdd6785e11039fba33c.jpeg)  \n**作为普通人，入局大模型时代需要持续学习和实践，不断提高自己的技能和认知水平，同时也需要有责任感和伦理意识，为人工智能的健康发展贡献力量。**\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/zhishi0000/article/details/146395609?spm=1000.2115.3001.10525', 0, NULL, NULL, '2025-05-15 16:45:42', '2025-05-15 17:57:22');
INSERT INTO `sys_article` VALUES (304, 1, 40, '【优选算法 | 双指针】双指针大揭秘：如何用两根指针优化你的代码', 'img/【优选算法  双指针】双指针大揭秘：如何用两根指针优化你的代码.png', '双指针', '<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">算法</th>\n<th style=\"text-align:center\">相关知识点</th>\n<th style=\"text-align:center\">可以通过点击</th>\n<th style=\"text-align:center\">以下链接进行学习</th>\n<th style=\"text-align:center\">一起加油！</th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<blockquote>\n<p>在本篇文章中，我们将深入探索双指针算法的奥秘。从基础概念到实际应用，带你全面了解如何利用两根指针高效解决各种编程问题。无论你是刚接触算法的新人，还是希望提升代码性能的老手，双指针都是你不可忽视的利器！</p>\n</blockquote>\n<p>🌈个人主页：<a href=\"https://blog.csdn.net/2302_79177254?type=blog\" target=\"_blank\">是店小二呀</a><br />\n🌈C/C++专栏：<a href=\"https://blog.csdn.net/2302_79177254/category_12498683.html?spm=1001.2014.3001.5482\" target=\"_blank\">C语言</a>\\ <a href=\"https://blog.csdn.net/2302_79177254/category_12596619.html\" target=\"_blank\">C++</a><br />\n🌈初/高阶数据结构专栏： <a href=\"https://blog.csdn.net/2302_79177254/category_12596619.html\" target=\"_blank\">初阶数据结构</a>\\ <a href=\"https://blog.csdn.net/2302_79177254/category_12773774.html?spm=1001.2014.3001.5482\" target=\"_blank\">高阶数据结构</a><br />\n🌈Linux专栏： <a href=\"https://blog.csdn.net/2302_79177254/category_12742437.html\" target=\"_blank\">Linux</a><br />\n🌈算法专栏：<a href=\"https://blog.csdn.net/2302_79177254/category_12889122.html\" target=\"_blank\">算法</a><br />\n🌈Mysql专栏:<a href=\"https://blog.csdn.net/2302_79177254/category_12955608.html\" target=\"_blank\">Mysql</a></p>\n<p>🌈你可知:无人扶我青云志 我自踏雪至山巅 !</p>\n<br />\n<h4><a id=\"_19\"></a>文章目录</h4>\n<ul>\n<li>\n<ul>\n<li><a href=\"#font_colorcornflowerblue283font_23\">283.移动零[数组划分]</a></li>\n<li><a href=\"#font_colorcornflowerblue1089font_81\">1089.复写零[遍历角度]</a></li>\n<li><a href=\"#font_colorcornflowerblue202font_199\">202.快乐数[快慢指针]</a></li>\n<li><a href=\"#font_colorcornflowerblue11font_289\">11.盛水最多容器[对撞指针、单调性]</a></li>\n<li><a href=\"#font_colorcornflowerblue611font_396\">611.有效三角形的个数[对撞指针、单调性]</a></li>\n<li><a href=\"#font_colorcornflowerblue179sfont_486\">179.和为s的两个数字[对撞指针、单调性]</a></li>\n<li><a href=\"#font_colorcornflowerblue15font_535\">15.三数之和[对撞指针、单调性]</a></li>\n<li><a href=\"#font_colorcornflowerblue18Plusfont_629\">18.四数之和(三数之和Plus)[对撞指针、单调性]</a></li>\n</ul>\n</li>\n</ul>\n<br />\n<h3><a id=\"font_colorcornflowerblue283font_23283_content_views_33\"></a>{#font_colorcornflowerblue283font_23}283.移动零[数组划分] {#content_views}</h3>\n<p>【<strong>题目展示</strong> 】：<a href=\"https://leetcode.cn/problems/move-zeroes/description/\" target=\"_blank\">283.移动零</a></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/6326e66e61434c3897f28c58d8606efe.png\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>输入:[0, 1, 0, 3, 12]</p>\n<p>输出:[1, 3, 12, 0, 0]</p>\n</blockquote>\n<p>【<strong>算法思路</strong>】</p>\n<p>这类问题可以分为数组划分或者叫数组分块，并且使用双指针算法。这里提供<strong>指针作用、具体步骤、部分设计</strong>，三个方面的解析。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/a385f34aa9b34ea79a7a67268a3d270a.png\" alt=\"在这里插入图片描述\" /></p>\n<p>1.<strong>指针作用</strong>：</p>\n<blockquote>\n<ul>\n<li>【cur】:从左往右扫码数组，遍历数组</li>\n<li>【dest】:已处理的区间内，非零元素的最后一个位置</li>\n</ul>\n</blockquote>\n<p>2.<strong>具体步骤</strong>:</p>\n<blockquote>\n<ol>\n<li>cur从前往后遍历的过程中:</li>\n<li>【<strong>遇到0元素</strong>】:cur++;</li>\n<li>【<strong>遇到非零元素</strong>】:swap(<ins>des,cur); cur</ins>;</li>\n</ol>\n</blockquote>\n<p>3.<strong>区域划分</strong>：这里需要保证[0, dest]是非0，[dest + 1, cur - 1]是0这个设计。dest设置为-1使得[0, dest]一开始不存在。最后通过cur遍历通过中，使用swap函数，将数据进行划分。</p>\n<p>【<strong>代码展示</strong>】：</p>\n<pre><code class=\"lang-prism\">class Solution\n {\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) \n    {\n        for(int cur = 0, dest = -1; cur &lt; nums.size(); cur++)\n        {\n            if(nums[cur]) swap(nums[cur],nums[++dest]);\n        }\n    }\n};\n</code></pre>\n<p>【<strong>个人思考</strong>】:遇到数组分块等类似题目，可以借助双指针进行数组划分，通过swap交换将不需要的数据排除该区间</p>\n<p>【<strong>小扩展</strong>】:快排里面最核心的一步，也是通过tmp进行数组的划分</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/7d539998bb6c4e3484a02674004b9f48.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<p>那么可以按照[0, tmp]、[tmp, cur -1]、[cur, n -1]来划分，代码是类似的</p>\n<hr />\n<h3><a id=\"font_colorcornflowerblue1089font_811089_85\"></a>{#font_colorcornflowerblue1089font_81}1089.复写零[遍历角度]</h3>\n<p>【<strong>题目展示</strong> 】：<a href=\"https://leetcode.cn/problems/duplicate-zeros/description/\" target=\"_blank\">1089.复写零</a></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/d8f96ee7c3864fd58ae8f4843fc580c9.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<blockquote>\n<ul>\n<li>输入：[1,0,2,3,0,4,5,0]</li>\n<li>输出：[1,0,0,2,3,0,0,4]</li>\n</ul>\n</blockquote>\n<p>【<strong>问题解析</strong>】：</p>\n<p><strong>1.从左到右遍历不行</strong></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/83b3cb6547844fc68a6ebbf0e01f5628.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<p>cur需要判断的数据被dest覆盖，原因在于dest在cur之后进行了操作。如果是’删除等于val值’这类题目中，dest始终保持在cur前面，因此不会出现数据被覆盖的情况。</p>\n<p><strong>2.转化角度</strong></p>\n<p>如果从左往右遍历会出现数据覆盖的情况，可以尝试从右往左进行覆盖，从结果的最后一个数字开始，按逆序遍历。</p>\n<p>【<strong>算法思路</strong>】</p>\n<p><strong>步骤分为两个阶段</strong>：</p>\n<ol>\n<li><strong>定位结果的最后一个元素</strong><br />\n可以使用双指针法遍历数组，此过程中无需修改数据，只需找到结果中的最后一个有效元素，并确定 <code>dest</code> 与 <code>cur</code> 应指向的位置。</li>\n<li><strong>从右往左进行覆盖</strong><br />\n在确定了结果末尾位置后，再从右向左逐步覆盖数据。</li>\n</ol>\n<p><strong>1.第一步:找到最后一个&quot;复写&quot;的数</strong></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/a36284b9465d4e228a13064f21a6ca5d.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/f1a6d5896f4f4886bec4b6e3c2644d9f.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<p>通过推导输入与输出元素的位置关系，我们发现 <code>cur</code> 指向最后一个有效元素（例如数字 4），而 <code>dest</code> 指向数组的末尾。如果保留原始的两个 0 元素，则 <code>cur</code> 与 <code>dest</code> 之间相差 2，这表明 0 元素的数量会影响 <code>dest</code> 和 <code>cur</code> 的移动步幅。</p>\n<p><strong>2.推导位置出现特殊情况</strong></p>\n<p>如果数组中不存在 0 元素，两个指针会同时向前移动。虽然既可以用 <code>cur &lt; n</code> 也可以用 <code>dest &gt; n - 1</code> 作为循环判断条件，但考虑到只有当 <code>cur &gt; n</code> 时才能确保遍历完整个流程，其范围更广。因此，作为循环的终止条件，通常只需判断 <code>dest &gt; n - 1</code> 来 break 循环即可。</p>\n<p><strong>3.第二步：移动数据</strong></p>\n<blockquote>\n<ul>\n<li>\n<p>【<strong>遇到非零元素</strong> 】:交换数据<code> arr[dest--] = arr[cur];</code></p>\n</li>\n<li>\n<p>【<strong>遇到零元素</strong> 】: 重复两次<code>arr[dest--] = 0;</code></p>\n</li>\n</ul>\n</blockquote>\n<p>【<strong>特殊情况处理</strong>】</p>\n<p>这里需要进行特殊处理：当 <code>dest</code> 达到 <code>n</code> 时，可能会导致数据覆盖，从而引发越界访问。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/fda75c3b330c45fdafaf27be7ac31f2a.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<pre><code class=\"lang-prism\">//2.特殊情况处理,处理完也是需要对位置进行移动的\n        if(dest == n)\n        {\n            arr[n - 1] = 0;\n            dest -= 2;\n            cur--;\n        }\n</code></pre>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/5aadf0c733b74beead0014d25802ed90.png\" alt=\"在这里插入图片描述\" /></p>\n<p>【<strong>代码展示</strong>】：</p>\n<pre><code class=\"lang-prism\">class Solution {\npublic:\n    void duplicateZeros(vector&lt;int&gt;&amp; arr) \n    {\n        //1.先找到最后一个位置\n        int cur = 0, dest = -1, n = arr.size();\n        while(cur &lt; n)\n        {\n            if(arr[cur] == 0) dest+=2;\n            else dest++;\n            if(dest &gt;= n - 1) break;\n            cur++;\n        }\n        \n        //2.特殊情况处理,处理完也是需要对位置进行移动的\n        if(dest == n)\n        {\n            arr[n - 1] = 0;\n            dest -= 2;\n            cur--;\n        }\n\n        //3.开始数据处理\n        while(cur &gt;= 0)\n        {\n            if(arr[cur]) arr[dest--] = arr[cur];\n\n            if(arr[cur] == 0)\n            {\n                arr[dest--] = 0;\n                arr[dest--] = 0;\n            }\n\n            cur--;\n        }\n    }\n};\n</code></pre>\n<p>【<strong>个人思考</strong>】:在需要判断和修改数组元素的问题中，通常会想到双指针方法。但若从左到右遍历，可能会导致数据覆盖，从而影响结果。对此，不妨尝试调整遍历方向，说不定会带来意想不到的优化效果。</p>\n<hr />\n<h3><a id=\"font_colorcornflowerblue202font_199202_195\"></a>{#font_colorcornflowerblue202font_199}202.快乐数[快慢指针]</h3>\n<p>【<strong>题目展示</strong> 】：<a href=\"https://leetcode.cn/problems/happy-number/description/\" target=\"_blank\">202.快乐数</a></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/88327bc26c3f410aa9d179cd98397280.png\" alt=\"image-20240514185851149\" /></p>\n<blockquote>\n<p>示例 1：</p>\n<ul>\n<li>输入：n = 19</li>\n<li>输出：true</li>\n</ul>\n<p>解释：</p>\n<ul>\n<li>12 + 92 = 82</li>\n<li>82 + 22 = 68</li>\n<li>62 + 82 = 100</li>\n<li>12 + 02 + 02 = 1</li>\n</ul>\n<p>示例 2：</p>\n<ul>\n<li>输入：n = 2</li>\n<li>输出：false</li>\n</ul>\n</blockquote>\n<p><strong>【算法思路】</strong></p>\n<p><strong>1.是否为闭环</strong></p>\n<p>如果题目中没有提示&quot;重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1&quot;，那么我们必须额外判断以下三种情况，以确保程序能够正确终止：</p>\n<blockquote>\n<ul>\n<li>【<strong>情况一</strong>】:一直在 1中死循环，即1-&gt;1-&gt;1</li>\n<li>【<strong>情况二</strong>】:在历史的数据中死循环，但始终变不到1</li>\n<li>【<strong>情况三</strong>】：单路线不断变化新数字，不是死循环</li>\n</ul>\n</blockquote>\n<p><strong>2.闭环会限制变化的范围</strong></p>\n<p>因此，我们需要判断该数在变化过程中是否会形成闭环。形成闭环意味着至少会重复出现一次相同的数，此时数值变化的范围已被锁定。</p>\n<p><strong>3.证明鸽巢原理:</strong></p>\n<p><strong>鸽巢原理</strong>:n个巢，n + 1个鸽，至少有一个巢，里面的鸽数大于1，必有一个重复。那么意味着，只需要确定了[1, n]范围，就说明到n + 1必有一个重复的。而这个最大的n，是可以通过一个最大数去推。</p>\n<p><strong>数据范围</strong> :<code>1 &lt;= n &lt;= 231 - 1</code>,选一个更大的数<code>9999999999</code>。通过变化的最大值9^2 * 10 = 810，那么变化的区间在[1, 810]之间。这里是通过最大数推导出可能的最大变化范围，但实际最大值 810 本身并不包含在内。</p>\n<p>根据鸽巢原理，当一个数变化到811次之后，必然会形成一个循环。**当形成一个闭环时，可以使用我们的快慢指针解决。**因为1形成的闭环，里面全是1。</p>\n<p>【<strong>具体步骤</strong>】：</p>\n<ul>\n<li>\n<p>当快慢指针相遇，相遇位置的值是1，那么这个数一定是快乐数</p>\n</li>\n<li>\n<p>当快慢指针相遇，相遇位置的值不是1，那么这个数不是快乐数</p>\n</li>\n</ul>\n<p>【<strong>代码展示</strong>】：</p>\n<pre><code class=\"lang-prism\">class Solution \n{\npublic:\n\n    int sum(int n)\n    {\n        int ret = 0;\n        while(n)\n        {\n            int tmp = n % 10;\n            ret += tmp * tmp;\n            n/=10;\n        }\n        return ret;\n    }\n    bool isHappy(int n) \n    {\n        //定义快慢指针\n        int slow = n;\n        int fast = sum(n);\n        while(slow != fast)\n        {\n            slow = sum(slow);\n            fast = sum(sum(fast));\n        }\n        return slow == 1;\n    }\n};\n</code></pre>\n<p>【<strong>个人思考</strong>】:在这个问题中，我们需要根据需求特性判断是否形成闭环，而闭环的判断条件就是是否出现重复数。最初，这个思路并不容易想到，但可以借助鸽巢原理，通过数据的最大值来推导可能的变化范围。**因此，在求解范围时，可以考虑是否能利用数据的最大值来确定 n的界限。**闭环会限制变化的范围。</p>\n<hr />\n<h3><a id=\"font_colorcornflowerblue11font_28911_281\"></a>{#font_colorcornflowerblue11font_289}11.盛水最多容器[对撞指针、单调性]</h3>\n<p>【<strong>题目展示</strong> 】：盛水最多容器</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/a203efcf5f1c4a68b40282fe41522595.png\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<ul>\n<li>输入：[1,8,6,2,5,4,8,3,7]</li>\n<li>输出：49</li>\n<li>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49</li>\n</ul>\n</blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/3ebbdc35775143bdac04472311ebb938.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<p>【<strong>题目解析</strong>】：</p>\n<p><strong>1.解法一:暴力求解(会超时)</strong></p>\n<p>枚举出能构成的所有容器，找出其中容积最⼤的值，直接两层for循环，枚举能构成容器的体积，求得最大值。</p>\n<p>代码展示:</p>\n<pre><code class=\"lang-prism\">class Solution \n{\npublic:\n	int maxArea(vector&lt;int&gt;&amp; height) \n	{\n		int n = height.size();\n		int ret = 0;\n		// 两层 for 枚举出所有可能出现的情况\n	for (int i = 0; i &lt; n; i++)\n    {\n		for (int j = i + 1; j &lt; n; j++) \n			{\n				// 计算容积，找出最⼤的那⼀个\n				ret = max(ret, min(height[i], height[j]) * (j - i));\n				}\n		}\n    return ret;\n}\n};\n</code></pre>\n<p><strong>2.解法二:对撞指针</strong></p>\n<p>【<strong>算法思路</strong>】</p>\n<p>首先，我们需要理解如何计算容器的体积。通过设置 <code>left</code> 和 <code>right</code> 两个指针，分别指向容器的左边和右边，然后根据短板效应来决定水的高度，即水的高度由两边中较短的那块木板决定。</p>\n<p>公式：</p>\n<pre><code class=\"lang-prism\">int v =  min(higth[left], higth[right]) * (right - left);\n</code></pre>\n<p>这里 <code>v</code> 代表容器的体积，其中有两个变量控制体积：<code>height</code> 和 <code>width</code>。<code>height</code> 是水的高度，<code>width</code> 是容器的宽度。</p>\n<p>假设左边木板比右边木板短（即短板在左边），我们可以从这里分析水的容积变化。(这步骤可以暂时省去很多考虑)</p>\n<p><strong>容积变化的分析</strong>：</p>\n<ol>\n<li><strong>容器的宽度会变小</strong><br />\n无论我们如何调整左或右边界，容器的宽度始终会减小（<code>wide ↓</code>），这意味着容积的变化必然受到宽度减少的影响。</li>\n<li><strong>移动左边界（短木板）</strong><br />\n改变左边界(短木板)，由于左边界较小，新的水面高度不确定，但是不会超过右边界的高度，因此容器的容积可能会增大，导致<code>v（未知） = w↓ * h（未知，可以增大）</code></li>\n<li><strong>移动右边界（长木板）</strong><br />\n由于右边界较大，无论有边界移动到哪里，新的水面高度一定不会超过左边界，意味着当前高度h不变，由于宽度不断变小，对于容积一定会变小的。<code>v↓ = w↓ * h（↓ 或者 不变）</code></li>\n</ol>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/f76777ada1ca4166875fbfea60f3756d.png\" alt=\"在这里插入图片描述\" /></p>\n<p>当我们移动短木板，这里因为h的不确定性，导致了容积可大可小。对此，当我们记录完一个区间的体积，<strong>将短木板往长木板靠拢，不间断判断下一个边界情况，不断刷新最大的容积</strong>。</p>\n<p>【<strong>代码展示</strong>】：</p>\n<pre><code class=\"lang-prism\">class Solution \n{\npublic:\n    int maxArea(vector&lt;int&gt;&amp; height) \n    {\n        //需要取最小的数据\n        int left = 0;\n        int right = height.size() - 1;\n        int ret = 0;\n        while(left &lt; right)\n        {\n            //算体积\n            int v = min(height[left],height[right])*(right - left);\n            \n            //更新最大的体积\n            ret = max(ret, v);\n            \n            if(height[left] &lt;= height[right])  left++;\n            else right--;\n        }\n        return ret;\n    }\n};\n</code></pre>\n<p>【<strong>个人思考</strong>】：<strong>遇到这类涉及公式计算最值的问题时，可以利用单调性来简化分析</strong>。关键在于如何选择移动边界：移动长木板时，容积必然减小，而移动短木板时，容积变化不确定，但有可能增大。</p>\n<p>本质上，<strong>问题的核心是利用单调性，从大到小向内枚举，逐步更新容积</strong>。每次移动边界时，更新容积并与当前最大值进行比较，最终得到最大的容积。</p>\n<hr />\n<h3><a id=\"font_colorcornflowerblue611font_396611_385\"></a>{#font_colorcornflowerblue611font_396}611.有效三角形的个数[对撞指针、单调性]</h3>\n<p>【<strong>题目展示</strong> 】：<a href=\"https://leetcode.cn/problems/valid-triangle-number/\" target=\"_blank\">611.有效三角形的个数</a></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/9ae0408c18954864a4cf6fe137320a9b.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<blockquote>\n<ul>\n<li>\n<p>输入: nums = [2,2,3,4]</p>\n</li>\n<li>\n<p>输出: 3<br />\n解释:有效的组合是:</p>\n</li>\n<li>\n<p>2,3,4 (使用第一个 2)</p>\n</li>\n<li>\n<p>2,3,4 (使用第二个 2)</p>\n</li>\n<li>\n<p>2,2,3</p>\n</li>\n</ul>\n</blockquote>\n<p>【<strong>算法思路</strong>】</p>\n<p><strong>1.数学知识：如何通过三个数，判断是否能构成三角形</strong></p>\n<pre><code class=\"lang-prism\">只需要两边之和大于第三边\n    a + b &gt; c\n    a + c &gt; b\n    b + c &gt; a\n</code></pre>\n<p><strong>2.解法一：暴力解法</strong></p>\n<p>通过暴力枚举法，可以使用三层for循环遍历所有可能的三角形数据，记录并筛选出符合条件的组合。</p>\n<pre><code class=\"lang-prism\">	 for(i = 0; i &lt; n; i++)\n        for(j = i + 1; j &lt; n; j++)\n            for(k = j + 1; k &lt; n; k++)\n                check(i, j , k);\n</code></pre>\n<p>通过数学优化，当<code>a &lt;= b &lt;= c</code>时，判断三角形成立只需验证<code>a + b &gt; c</code>。因为在这种情况下，<code>c</code>是最大的，<code>a + c</code>和<code>b + c</code>必然大于另一个边。优化步骤：首先对数组进行排序，得到有序数组。</p>\n<p><strong>时间复杂度</strong></p>\n<p>没有进行优化，三层for循环的时间复杂度就是<code>O(3N^3^)</code>。如果进行了优化，时间复杂度就是<code>O(NlogN + N^3^)</code>。虽然时间复杂度是取主要影响的变量，但是不管如何，这里进行了优化的情况下，时间复杂度是得到了优化，同时处理数据方面也是得到改善。</p>\n<p><strong>2.解法二:对撞指针</strong></p>\n<blockquote>\n<p>提示：借鉴上次容积问题的思路，**当根据公式或表达式判断条件时，可以利用单调性优化。**通过固定最大数，并使用<code>left</code>和<code>right</code>指针指向左右两端，避免枚举。类似容积问题，从左到右或从右到左的差异源自数据大小顺序，影响判断条件的判断效率。</p>\n</blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/894250985bd84c7b8f356e3f2301f1bc.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<p>通过设置两个变量作为边界，首先判断<code>a + b</code>是否大于<code>c</code>。如果<code>a + b &gt; c</code>，那么从左到右时，<code>a + b</code>会始终大于<code>c</code>，无需再继续枚举；从右到左时，<code>a + b</code>的大小关系不确定，因此需要保留这个操作进行整体判断。如果<code>a + b &lt;= c</code>，则从右到左会使<code>b</code>变小，导致无法满足条件，因此需要移动<code>left</code>，使得<code>a + b</code>不断逼近并超过<code>c</code>。在此过程中，<code>left</code>和<code>right</code>会不断调整，因此需要在循环内进行相应的更新。</p>\n<p>这里的 <code>sum += right - left</code> 表示以 <code>right</code> 为边界时，所有满足条件的组合数量。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/326457348abe41f881799232c987de54.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<p>【<strong>代码展示</strong>】：</p>\n<pre><code class=\"lang-prism\">class Solution \n{\npublic:\n    int triangleNumber(vector&lt;int&gt;&amp; nums)\n    {\n      sort(nums.begin(), nums.end());\n        int n = nums.size();\n        int sum = 0;\n        for(int i = n - 1; i &gt;=2; i--)\n        {\n            int left = 0, right = i - 1;\n            while(left &lt; right)\n            {\n                if(nums[left] + nums[right] &gt; nums[i]) \n                {\n                    sum+=right - left;\n                    right--;\n                }\n                else left++;\n            }\n        }\n        return sum;\n    }\n};\n</code></pre>\n<hr />\n<h3><a id=\"font_colorcornflowerblue179sfont_486179s_468\"></a>{#font_colorcornflowerblue179sfont_486}179.和为s的两个数字[对撞指针、单调性]</h3>\n<p>【<strong>题目展示</strong> 】：<a href=\"https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/\" target=\"_blank\">179.和为s的两个数字(原题目)</a>)</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/29bdc0503e114843aea79f54d21c8990.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<blockquote>\n<ul>\n<li>输入：price = [3, 9, 12, 15], target = 18</li>\n<li>输出：[3,15] 或者 [15,3]</li>\n</ul>\n</blockquote>\n<p>【<strong>算法思路</strong>】</p>\n<p>这道题属于基础题，主要考察双指针法在单调性匹配中的应用。关键是判断 <code>left + right == target</code>。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/af8df8b29e59448793dd35c8fcc8915e.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<p>对于 <code>left + right ? target</code>，共有三种情况。通过利用单调性，依据 <code>left</code> 和 <code>right</code> 指向的数据关系，调整它们的位置以达到目标。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/9e4caf3d12204d00963ce7c8ac970790.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<p>【<strong>代码展示</strong>】</p>\n<pre><code class=\"lang-prism\">class Solution \n{\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; price, int target) \n    {\n        int left = 0, right = price.size() - 1;\n        \n        while(left &lt; right)\n        {\n            int sum = price[left] + price[right];\n\n            //连续判断还是写else if分支语句\n            if(sum &gt; target) right--;\n            else if(sum &lt; target) left++;\n            else return {price[left], price[right]};\n        }\n        //为了照护编译器，通过返回-1\n        return {-1, -1};\n    }\n};\n</code></pre>\n<hr />\n<h3><a id=\"font_colorcornflowerblue15font_53515_513\"></a>{#font_colorcornflowerblue15font_535}15.三数之和[对撞指针、单调性]</h3>\n<p>【<strong>题目展示</strong> 】：<a href=\"https://leetcode.cn/problems/3sum/description/\" target=\"_blank\">15.三数之和</a></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/45abe5a2e65b4053ad2990a16d55408a.png\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"lang-prism\">输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n</code></pre>\n<p>首先分析题目给出的信息，注意到题目没有明确说明是否允许重复三元组。因此，需要通过实例来推断是否存在重复三元组的情况。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/39d73a845176457a92a2dfc207ba2c58.png\" alt=\"在这里插入图片描述\" /></p>\n<p>题目中说明三元组的顺序不重要，因此我们关注的是数据是否重复。通过例子 <code>[-1, 0, 1]</code>、<code>[0, 1, -1]</code> 和 <code>[-1, 1, 0]</code>，我们可以发现这些是重复的三元组。为了简化判断，可以统一将三元组排序为 [-1, 0, 1]，通过排序来优化，<strong>避免不必要的重复判断</strong>。</p>\n<p><strong>3.解法一:排序 + 暴力枚举 + 利用set去重:时间复杂度O(N<sup>3</sup>)</strong></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/f7387b2994b74db29e653800a3c1e4b4.png\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>4.解法二:对撞指针</strong></p>\n<p>根据题目需求，我们需要统计满足 <code>nums[a] + nums[left] + nums[right] == 0</code> 的三元组。可以将其转化为 <code>nums[left] + nums[right] = -nums[a]</code>，这意味着当 <code>nums[left] + nums[right]</code> 等于 <code>nums[a]</code> 的相反数时，条件成立。通过固定一个数值并移动两个边界，我们能够减少不必要的枚举次数。</p>\n<p>【<strong>个人思考</strong>】：这个问题和两数之和的单调性问题类似，只需固定一个数并让另两个数的和等于目标值，之后通过调整左右指针来查找所有满足条件的组合。</p>\n<p>【<strong>细节问题</strong>】</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/2ef326a50e8d4c729481ad88d1772d3e.png\" alt=\"在这里插入图片描述\" /></p>\n<p>如果使用 <code>set</code> 来去重，则需要额外的时间来插入和查找每个元素，时间复杂度为 <code>O(log n)</code>。我们通过排序的方法，将<code>[-1, 0, 1]、[0, 1, -1]、[-1, 1, 0]</code>重复的数据统一变成了<code>[-1, 0, 1]</code>的形式，但是重复的数据，我们是不需要的。固定一个数，当<code>left</code>和<code>right</code>指向位置符合要求后，就需要考虑重复问题，进行去重操作。当然不止<code>left</code>和<code>right</code>需要去重，固定的数据也需要完成去重操作，避免越界<code>[0, 0, 0, 0]</code>。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/8cd619ffefe24de8bffbd0ea07fa7c5c.png\" alt=\"在这里插入图片描述\" /></p>\n<p>【<strong>代码展示</strong>】</p>\n<pre><code class=\"lang-prism\">class Solution\n{\n    public:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) \n    {\n        vector&lt;vector&lt;int&gt;&gt; v;\n\n        // -3 -2 -1\n        //排序下\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        for(int i = 0; i &lt; n - 2 ;  )\n        {\n            \n            //不存在 nums[]+nums[] = minPositive_nums[i]\n            if(nums[i] &gt; 0) break;\n\n            int left = i + 1, right =  n - 1;\n            int target = -nums[i];\n\n            while(left &lt; right)\n            {\n                int sum = nums[left] + nums[right];\n                if(sum &gt; target) right--;\n                else if(sum &lt; target) left++;\n                else\n                {\n                    //初始化列表自动转为vector&lt;int&gt;类型\n                    v.push_back({nums[left], nums[right], nums[i]});\n                    left++;right--;\n                    //去重判断\n                    while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++;\n                    while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;\n                }\n            }\n\n            //去重操作\n            //这里会到导致判断时，造成越界访问\n            //while(nums[i] == nums[i + 1]) i++;\n            i++;\n            ///关于越界访问，需要判断循环逻辑是否有问题。\n            while(i &lt; n &amp;&amp; nums[i] == nums[i - 1]) i++;\n        }\n        return v;\n    }\n</code></pre>\n<hr />\n<h3><a id=\"font_colorcornflowerblue18Plusfont_62918Plus_605\"></a>{#font_colorcornflowerblue18Plusfont_629}18.四数之和(三数之和Plus)[对撞指针、单调性]</h3>\n<p>【<strong>题目展示</strong> 】：<a href=\"https://leetcode.cn/problems/4sum/submissions/597939657/\" target=\"_blank\">18.四数之和</a></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/68ebff45d7c44065b5e1ad9b49d52712.png\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"lang-prism\">输入：nums = [1,0,-1,0,-2,2], target = 0\n输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n</code></pre>\n<p>【<strong>算法思路</strong>】</p>\n<p>这里同样的，按照题目要求可以得到一个表达式<code>nums[a] + nums[b] + nums[left] + nums[right] == target</code>,按照我们熟悉的解法，我们是通过固定一个数，以left和right两个数作为边界向内进行查找。但是这里多出了一个数，那么不妨可以这样<code> nums[b] + nums[left] + nums[right] == target - nums[a]</code>，跟三数之和题目不是一样了吗？这里多次一个数的意义，就是多了一层循环。</p>\n<p><strong>1.解法一:排序 + 暴力枚举 + 利用set去重 时间复杂度O(N<sup>4</sup>)</strong></p>\n<p><strong>2.解法二:对撞指针</strong></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/0538fb10d81c48a19edbdefc3b7d1fdd.png\" alt=\"外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传\" /></p>\n<p>【<strong>问题：栈溢出</strong>】</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/9737a09a647d49ab8145d2ed4e08b400.png\" alt=\"在这里插入图片描述\" /></p>\n<p>对此这里需要考虑数据的范围将<code>dest</code>和<code>target</code>类型转化为<code>long long</code></p>\n<p>【<strong>代码展示</strong>】</p>\n<pre><code class=\"lang-prism\">class Solution \n{\n    public:\n    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) \n    {\n        //-4 - 3 -2 -1\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        vector&lt;vector&lt;int&gt;&gt; v;\n        for(int i = 0; i &lt; n - 3;)\n        {\n            for(int j = i + 1; j &lt; n - 2;)\n            {\n                //新的目标数\n                long long dest = (long long)target - nums[i] - nums[j];\n                int left = j + 1, right = n - 1;\n                while(left &lt; right)\n                {\n                    int sum = nums[left] + nums[right];\n                    if(sum &gt; dest) right--;\n                    else if(sum &lt; dest) left++;\n                    else\n                    {\n                        v.push_back({nums[i], nums[j], nums[left], nums[right]});\n                        left++;right--;\n                        //去重操作\n                        while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++;\n                        while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;\n                    }\n                }\n                j++;\n                while(j &lt; n - 2 &amp;&amp; nums[j] == nums[j - 1])  j++;\n            }\n            i++;\n            while(i &lt; n - 3 &amp;&amp; nums[i] == nums[i - 1])  i++;\n        }\n        return v;\n    }\n};\n</code></pre>\n', '\n\n| 算法 | 相关知识点 | 可以通过点击 | 以下链接进行学习 | 一起加油！ |\n|:--:|:-----:|:------:|:--------:|:-----:|\n\n> 在本篇文章中，我们将深入探索双指针算法的奥秘。从基础概念到实际应用，带你全面了解如何利用两根指针高效解决各种编程问题。无论你是刚接触算法的新人，还是希望提升代码性能的老手，双指针都是你不可忽视的利器！\n\n\n🌈个人主页：[是店小二呀](https://blog.csdn.net/2302_79177254?type=blog)  \n🌈C/C++专栏：[C语言](https://blog.csdn.net/2302_79177254/category_12498683.html?spm=1001.2014.3001.5482)\\\\ [C++](https://blog.csdn.net/2302_79177254/category_12596619.html)  \n🌈初/高阶数据结构专栏： [初阶数据结构](https://blog.csdn.net/2302_79177254/category_12596619.html)\\\\ [高阶数据结构](https://blog.csdn.net/2302_79177254/category_12773774.html?spm=1001.2014.3001.5482)  \n🌈Linux专栏： [Linux](https://blog.csdn.net/2302_79177254/category_12742437.html)  \n🌈算法专栏：[算法](https://blog.csdn.net/2302_79177254/category_12889122.html)  \n🌈Mysql专栏:[Mysql](https://blog.csdn.net/2302_79177254/category_12955608.html)\n\n🌈你可知:无人扶我青云志 我自踏雪至山巅 !\n\n<br />\n\n#### 文章目录\n\n*\n  * [283.移动零\\[数组划分\\]](#font_colorcornflowerblue283font_23)\n  * [1089.复写零\\[遍历角度\\]](#font_colorcornflowerblue1089font_81)\n  * [202.快乐数\\[快慢指针\\]](#font_colorcornflowerblue202font_199)\n  * [11.盛水最多容器\\[对撞指针、单调性\\]](#font_colorcornflowerblue11font_289)\n  * [611.有效三角形的个数\\[对撞指针、单调性\\]](#font_colorcornflowerblue611font_396)\n  * [179.和为s的两个数字\\[对撞指针、单调性\\]](#font_colorcornflowerblue179sfont_486)\n  * [15.三数之和\\[对撞指针、单调性\\]](#font_colorcornflowerblue15font_535)\n  * [18.四数之和(三数之和Plus)\\[对撞指针、单调性\\]](#font_colorcornflowerblue18Plusfont_629)\n\n<br />\n\n### {#font_colorcornflowerblue283font_23}283.移动零\\[数组划分\\] {#content_views}\n\n【**题目展示** 】：[283.移动零](https://leetcode.cn/problems/move-zeroes/description/)\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6326e66e61434c3897f28c58d8606efe.png)\n> 输入:\\[0, 1, 0, 3, 12\\]\n>\n> 输出:\\[1, 3, 12, 0, 0\\]\n\n【**算法思路**】\n\n这类问题可以分为数组划分或者叫数组分块，并且使用双指针算法。这里提供**指针作用、具体步骤、部分设计**，三个方面的解析。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a385f34aa9b34ea79a7a67268a3d270a.png)\n\n1.**指针作用**：\n> * 【cur】:从左往右扫码数组，遍历数组\n> * 【dest】:已处理的区间内，非零元素的最后一个位置\n\n2.**具体步骤**:\n> 1. cur从前往后遍历的过程中:\n> 2. 【**遇到0元素**】:cur++;\n> 3. 【**遇到非零元素**】:swap(++des,cur); cur++;\n\n3.**区域划分**：这里需要保证\\[0, dest\\]是非0，\\[dest + 1, cur - 1\\]是0这个设计。dest设置为-1使得\\[0, dest\\]一开始不存在。最后通过cur遍历通过中，使用swap函数，将数据进行划分。\n\n【**代码展示**】：\n\n```prism language-cpp\nclass Solution\n {\npublic:\n    void moveZeroes(vector<int>& nums) \n    {\n        for(int cur = 0, dest = -1; cur < nums.size(); cur++)\n        {\n            if(nums[cur]) swap(nums[cur],nums[++dest]);\n        }\n    }\n};\n```\n\n【**个人思考**】:遇到数组分块等类似题目，可以借助双指针进行数组划分，通过swap交换将不需要的数据排除该区间\n\n【**小扩展**】:快排里面最核心的一步，也是通过tmp进行数组的划分\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/7d539998bb6c4e3484a02674004b9f48.png)\n\n那么可以按照\\[0, tmp\\]、\\[tmp, cur -1\\]、\\[cur, n -1\\]来划分，代码是类似的\n\n*** ** * ** ***\n\n### {#font_colorcornflowerblue1089font_81}1089.复写零\\[遍历角度\\]\n\n【**题目展示** 】：[1089.复写零](https://leetcode.cn/problems/duplicate-zeros/description/)\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/d8f96ee7c3864fd58ae8f4843fc580c9.png)\n> * 输入：\\[1,0,2,3,0,4,5,0\\]\n> * 输出：\\[1,0,0,2,3,0,0,4\\]\n\n【**问题解析**】：\n\n**1.从左到右遍历不行**\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/83b3cb6547844fc68a6ebbf0e01f5628.png)\n\ncur需要判断的数据被dest覆盖，原因在于dest在cur之后进行了操作。如果是\'删除等于val值\'这类题目中，dest始终保持在cur前面，因此不会出现数据被覆盖的情况。\n\n**2.转化角度**\n\n如果从左往右遍历会出现数据覆盖的情况，可以尝试从右往左进行覆盖，从结果的最后一个数字开始，按逆序遍历。\n\n【**算法思路**】\n\n**步骤分为两个阶段**：\n\n1. **定位结果的最后一个元素**   \n   可以使用双指针法遍历数组，此过程中无需修改数据，只需找到结果中的最后一个有效元素，并确定 `dest` 与 `cur` 应指向的位置。\n2. **从右往左进行覆盖**   \n   在确定了结果末尾位置后，再从右向左逐步覆盖数据。\n\n**1.第一步:找到最后一个\"复写\"的数**\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/a36284b9465d4e228a13064f21a6ca5d.png)\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/f1a6d5896f4f4886bec4b6e3c2644d9f.png)\n\n通过推导输入与输出元素的位置关系，我们发现 `cur` 指向最后一个有效元素（例如数字 4），而 `dest` 指向数组的末尾。如果保留原始的两个 0 元素，则 `cur` 与 `dest` 之间相差 2，这表明 0 元素的数量会影响 `dest` 和 `cur` 的移动步幅。\n\n**2.推导位置出现特殊情况**\n\n如果数组中不存在 0 元素，两个指针会同时向前移动。虽然既可以用 `cur < n` 也可以用 `dest > n - 1` 作为循环判断条件，但考虑到只有当 `cur > n` 时才能确保遍历完整个流程，其范围更广。因此，作为循环的终止条件，通常只需判断 `dest > n - 1` 来 break 循环即可。\n\n**3.第二步：移动数据**\n> * 【**遇到非零元素** 】:交换数据` arr[dest--] = arr[cur];`\n>\n> * 【**遇到零元素** 】: 重复两次`arr[dest--] = 0;`\n\n【**特殊情况处理**】\n\n这里需要进行特殊处理：当 `dest` 达到 `n` 时，可能会导致数据覆盖，从而引发越界访问。\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/fda75c3b330c45fdafaf27be7ac31f2a.png)\n\n```prism language-cpp\n//2.特殊情况处理,处理完也是需要对位置进行移动的\n        if(dest == n)\n        {\n            arr[n - 1] = 0;\n            dest -= 2;\n            cur--;\n        }\n```\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5aadf0c733b74beead0014d25802ed90.png)\n\n【**代码展示**】：\n\n```prism language-cpp\nclass Solution {\npublic:\n    void duplicateZeros(vector<int>& arr) \n    {\n        //1.先找到最后一个位置\n        int cur = 0, dest = -1, n = arr.size();\n        while(cur < n)\n        {\n            if(arr[cur] == 0) dest+=2;\n            else dest++;\n            if(dest >= n - 1) break;\n            cur++;\n        }\n        \n        //2.特殊情况处理,处理完也是需要对位置进行移动的\n        if(dest == n)\n        {\n            arr[n - 1] = 0;\n            dest -= 2;\n            cur--;\n        }\n\n        //3.开始数据处理\n        while(cur >= 0)\n        {\n            if(arr[cur]) arr[dest--] = arr[cur];\n\n            if(arr[cur] == 0)\n            {\n                arr[dest--] = 0;\n                arr[dest--] = 0;\n            }\n\n            cur--;\n        }\n    }\n};\n```\n\n【**个人思考**】:在需要判断和修改数组元素的问题中，通常会想到双指针方法。但若从左到右遍历，可能会导致数据覆盖，从而影响结果。对此，不妨尝试调整遍历方向，说不定会带来意想不到的优化效果。\n\n*** ** * ** ***\n\n### {#font_colorcornflowerblue202font_199}202.快乐数\\[快慢指针\\]\n\n【**题目展示** 】：[202.快乐数](https://leetcode.cn/problems/happy-number/description/)\n\n![image-20240514185851149](https://i-blog.csdnimg.cn/direct/88327bc26c3f410aa9d179cd98397280.png)\n> 示例 1：\n>\n> * 输入：n = 19\n> * 输出：true\n>\n> 解释：\n>\n> * 12 + 92 = 82\n> * 82 + 22 = 68\n> * 62 + 82 = 100\n> * 12 + 02 + 02 = 1\n>\n> 示例 2：\n>\n> * 输入：n = 2\n> * 输出：false\n\n**【算法思路】**\n\n**1.是否为闭环**\n\n如果题目中没有提示\"重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1\"，那么我们必须额外判断以下三种情况，以确保程序能够正确终止：\n> * 【**情况一**】:一直在 1中死循环，即1-\\>1-\\>1\n> * 【**情况二**】:在历史的数据中死循环，但始终变不到1\n> * 【**情况三**】：单路线不断变化新数字，不是死循环\n\n**2.闭环会限制变化的范围**\n\n因此，我们需要判断该数在变化过程中是否会形成闭环。形成闭环意味着至少会重复出现一次相同的数，此时数值变化的范围已被锁定。\n\n**3.证明鸽巢原理:**\n\n**鸽巢原理**:n个巢，n + 1个鸽，至少有一个巢，里面的鸽数大于1，必有一个重复。那么意味着，只需要确定了\\[1, n\\]范围，就说明到n + 1必有一个重复的。而这个最大的n，是可以通过一个最大数去推。\n\n**数据范围** :`1 <= n <= 231 - 1`,选一个更大的数`9999999999`。通过变化的最大值9\\^2 \\* 10 = 810，那么变化的区间在\\[1, 810\\]之间。这里是通过最大数推导出可能的最大变化范围，但实际最大值 810 本身并不包含在内。\n\n根据鸽巢原理，当一个数变化到811次之后，必然会形成一个循环。\\*\\*当形成一个闭环时，可以使用我们的快慢指针解决。\\*\\*因为1形成的闭环，里面全是1。\n\n【**具体步骤**】：\n\n* 当快慢指针相遇，相遇位置的值是1，那么这个数一定是快乐数\n\n* 当快慢指针相遇，相遇位置的值不是1，那么这个数不是快乐数\n\n【**代码展示**】：\n\n```prism language-cpp\nclass Solution \n{\npublic:\n\n    int sum(int n)\n    {\n        int ret = 0;\n        while(n)\n        {\n            int tmp = n % 10;\n            ret += tmp * tmp;\n            n/=10;\n        }\n        return ret;\n    }\n    bool isHappy(int n) \n    {\n        //定义快慢指针\n        int slow = n;\n        int fast = sum(n);\n        while(slow != fast)\n        {\n            slow = sum(slow);\n            fast = sum(sum(fast));\n        }\n        return slow == 1;\n    }\n};\n```\n\n【**个人思考**】:在这个问题中，我们需要根据需求特性判断是否形成闭环，而闭环的判断条件就是是否出现重复数。最初，这个思路并不容易想到，但可以借助鸽巢原理，通过数据的最大值来推导可能的变化范围。\\*\\*因此，在求解范围时，可以考虑是否能利用数据的最大值来确定 n的界限。\\*\\*闭环会限制变化的范围。\n\n*** ** * ** ***\n\n### {#font_colorcornflowerblue11font_289}11.盛水最多容器\\[对撞指针、单调性\\]\n\n【**题目展示** 】：盛水最多容器\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a203efcf5f1c4a68b40282fe41522595.png)\n> * 输入：\\[1,8,6,2,5,4,8,3,7\\]\n> * 输出：49\n> * 解释：图中垂直线代表输入数组 \\[1,8,6,2,5,4,8,3,7\\]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/3ebbdc35775143bdac04472311ebb938.png)\n\n【**题目解析**】：\n\n**1.解法一:暴力求解(会超时)**\n\n枚举出能构成的所有容器，找出其中容积最⼤的值，直接两层for循环，枚举能构成容器的体积，求得最大值。\n\n代码展示:\n\n```prism language-cpp\nclass Solution \n{\npublic:\n	int maxArea(vector<int>& height) \n	{\n		int n = height.size();\n		int ret = 0;\n		// 两层 for 枚举出所有可能出现的情况\n	for (int i = 0; i < n; i++)\n    {\n		for (int j = i + 1; j < n; j++) \n			{\n				// 计算容积，找出最⼤的那⼀个\n				ret = max(ret, min(height[i], height[j]) * (j - i));\n				}\n		}\n    return ret;\n}\n};\n```\n\n**2.解法二:对撞指针**\n\n【**算法思路**】\n\n首先，我们需要理解如何计算容器的体积。通过设置 `left` 和 `right` 两个指针，分别指向容器的左边和右边，然后根据短板效应来决定水的高度，即水的高度由两边中较短的那块木板决定。\n\n公式：\n\n```prism language-cpp\nint v =  min(higth[left], higth[right]) * (right - left);\n```\n\n这里 `v` 代表容器的体积，其中有两个变量控制体积：`height` 和 `width`。`height` 是水的高度，`width` 是容器的宽度。\n\n假设左边木板比右边木板短（即短板在左边），我们可以从这里分析水的容积变化。(这步骤可以暂时省去很多考虑)\n\n**容积变化的分析**：\n\n1. **容器的宽度会变小**   \n   无论我们如何调整左或右边界，容器的宽度始终会减小（`wide ↓`），这意味着容积的变化必然受到宽度减少的影响。\n2. **移动左边界（短木板）**   \n   改变左边界(短木板)，由于左边界较小，新的水面高度不确定，但是不会超过右边界的高度，因此容器的容积可能会增大，导致`v（未知） = w↓ * h（未知，可以增大）`\n3. **移动右边界（长木板）**   \n   由于右边界较大，无论有边界移动到哪里，新的水面高度一定不会超过左边界，意味着当前高度h不变，由于宽度不断变小，对于容积一定会变小的。`v↓ = w↓ * h（↓ 或者 不变）`\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f76777ada1ca4166875fbfea60f3756d.png)\n\n当我们移动短木板，这里因为h的不确定性，导致了容积可大可小。对此，当我们记录完一个区间的体积，**将短木板往长木板靠拢，不间断判断下一个边界情况，不断刷新最大的容积**。\n\n【**代码展示**】：\n\n```prism language-cpp\nclass Solution \n{\npublic:\n    int maxArea(vector<int>& height) \n    {\n        //需要取最小的数据\n        int left = 0;\n        int right = height.size() - 1;\n        int ret = 0;\n        while(left < right)\n        {\n            //算体积\n            int v = min(height[left],height[right])*(right - left);\n            \n            //更新最大的体积\n            ret = max(ret, v);\n            \n            if(height[left] <= height[right])  left++;\n            else right--;\n        }\n        return ret;\n    }\n};\n```\n\n【**个人思考**】：**遇到这类涉及公式计算最值的问题时，可以利用单调性来简化分析**。关键在于如何选择移动边界：移动长木板时，容积必然减小，而移动短木板时，容积变化不确定，但有可能增大。\n\n本质上，**问题的核心是利用单调性，从大到小向内枚举，逐步更新容积**。每次移动边界时，更新容积并与当前最大值进行比较，最终得到最大的容积。\n\n*** ** * ** ***\n\n### {#font_colorcornflowerblue611font_396}611.有效三角形的个数\\[对撞指针、单调性\\]\n\n【**题目展示** 】：[611.有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/9ae0408c18954864a4cf6fe137320a9b.png)\n> * 输入: nums = \\[2,2,3,4\\]\n> * 输出: 3\n> 解释:有效的组合是:\n>\n> * 2,3,4 (使用第一个 2)\n> * 2,3,4 (使用第二个 2)\n> * 2,2,3\n\n【**算法思路**】\n\n**1.数学知识：如何通过三个数，判断是否能构成三角形**\n\n```prism language-cpp\n只需要两边之和大于第三边\n    a + b > c\n    a + c > b\n    b + c > a\n```\n\n**2.解法一：暴力解法**\n\n通过暴力枚举法，可以使用三层for循环遍历所有可能的三角形数据，记录并筛选出符合条件的组合。\n\n```prism language-cpp\n	 for(i = 0; i < n; i++)\n        for(j = i + 1; j < n; j++)\n            for(k = j + 1; k < n; k++)\n                check(i, j , k);\n```\n\n通过数学优化，当`a <= b <= c`时，判断三角形成立只需验证`a + b > c`。因为在这种情况下，`c`是最大的，`a + c`和`b + c`必然大于另一个边。优化步骤：首先对数组进行排序，得到有序数组。\n\n**时间复杂度**\n\n没有进行优化，三层for循环的时间复杂度就是`O(3N^3^)`。如果进行了优化，时间复杂度就是`O(NlogN + N^3^)`。虽然时间复杂度是取主要影响的变量，但是不管如何，这里进行了优化的情况下，时间复杂度是得到了优化，同时处理数据方面也是得到改善。\n\n**2.解法二:对撞指针**\n> 提示：借鉴上次容积问题的思路，\\*\\*当根据公式或表达式判断条件时，可以利用单调性优化。\\*\\*通过固定最大数，并使用`left`和`right`指针指向左右两端，避免枚举。类似容积问题，从左到右或从右到左的差异源自数据大小顺序，影响判断条件的判断效率。\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/894250985bd84c7b8f356e3f2301f1bc.png)\n\n通过设置两个变量作为边界，首先判断`a + b`是否大于`c`。如果`a + b > c`，那么从左到右时，`a + b`会始终大于`c`，无需再继续枚举；从右到左时，`a + b`的大小关系不确定，因此需要保留这个操作进行整体判断。如果`a + b <= c`，则从右到左会使`b`变小，导致无法满足条件，因此需要移动`left`，使得`a + b`不断逼近并超过`c`。在此过程中，`left`和`right`会不断调整，因此需要在循环内进行相应的更新。\n\n这里的 `sum += right - left` 表示以 `right` 为边界时，所有满足条件的组合数量。\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/326457348abe41f881799232c987de54.png)\n\n【**代码展示**】：\n\n```prism language-cpp\nclass Solution \n{\npublic:\n    int triangleNumber(vector<int>& nums)\n    {\n      sort(nums.begin(), nums.end());\n        int n = nums.size();\n        int sum = 0;\n        for(int i = n - 1; i >=2; i--)\n        {\n            int left = 0, right = i - 1;\n            while(left < right)\n            {\n                if(nums[left] + nums[right] > nums[i]) \n                {\n                    sum+=right - left;\n                    right--;\n                }\n                else left++;\n            }\n        }\n        return sum;\n    }\n};\n```\n\n*** ** * ** ***\n\n### {#font_colorcornflowerblue179sfont_486}179.和为s的两个数字\\[对撞指针、单调性\\]\n\n【**题目展示** 】：[179.和为s的两个数字(原题目)](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/))\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/29bdc0503e114843aea79f54d21c8990.png)\n> * 输入：price = \\[3, 9, 12, 15\\], target = 18\n> * 输出：\\[3,15\\] 或者 \\[15,3\\]\n\n【**算法思路**】\n\n这道题属于基础题，主要考察双指针法在单调性匹配中的应用。关键是判断 `left + right == target`。\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/af8df8b29e59448793dd35c8fcc8915e.png)\n\n对于 `left + right ? target`，共有三种情况。通过利用单调性，依据 `left` 和 `right` 指向的数据关系，调整它们的位置以达到目标。\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/9e4caf3d12204d00963ce7c8ac970790.png)\n\n【**代码展示**】\n\n```prism language-cpp\nclass Solution \n{\npublic:\n    vector<int> twoSum(vector<int>& price, int target) \n    {\n        int left = 0, right = price.size() - 1;\n        \n        while(left < right)\n        {\n            int sum = price[left] + price[right];\n\n            //连续判断还是写else if分支语句\n            if(sum > target) right--;\n            else if(sum < target) left++;\n            else return {price[left], price[right]};\n        }\n        //为了照护编译器，通过返回-1\n        return {-1, -1};\n    }\n};\n```\n\n*** ** * ** ***\n\n### {#font_colorcornflowerblue15font_535}15.三数之和\\[对撞指针、单调性\\]\n\n【**题目展示** 】：[15.三数之和](https://leetcode.cn/problems/3sum/description/)\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/45abe5a2e65b4053ad2990a16d55408a.png)\n\n```prism language-cpp\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n```\n\n首先分析题目给出的信息，注意到题目没有明确说明是否允许重复三元组。因此，需要通过实例来推断是否存在重复三元组的情况。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/39d73a845176457a92a2dfc207ba2c58.png)\n\n题目中说明三元组的顺序不重要，因此我们关注的是数据是否重复。通过例子 `[-1, 0, 1]`、`[0, 1, -1]` 和 `[-1, 1, 0]`，我们可以发现这些是重复的三元组。为了简化判断，可以统一将三元组排序为 \\[-1, 0, 1\\]，通过排序来优化，**避免不必要的重复判断**。\n\n**3.解法一:排序 + 暴力枚举 + 利用set去重:时间复杂度O(N^3^)**\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f7387b2994b74db29e653800a3c1e4b4.png)\n\n**4.解法二:对撞指针**\n\n根据题目需求，我们需要统计满足 `nums[a] + nums[left] + nums[right] == 0` 的三元组。可以将其转化为 `nums[left] + nums[right] = -nums[a]`，这意味着当 `nums[left] + nums[right]` 等于 `nums[a]` 的相反数时，条件成立。通过固定一个数值并移动两个边界，我们能够减少不必要的枚举次数。\n\n【**个人思考**】：这个问题和两数之和的单调性问题类似，只需固定一个数并让另两个数的和等于目标值，之后通过调整左右指针来查找所有满足条件的组合。\n\n【**细节问题**】\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2ef326a50e8d4c729481ad88d1772d3e.png)\n\n如果使用 `set` 来去重，则需要额外的时间来插入和查找每个元素，时间复杂度为 `O(log n)`。我们通过排序的方法，将`[-1, 0, 1]、[0, 1, -1]、[-1, 1, 0]`重复的数据统一变成了`[-1, 0, 1]`的形式，但是重复的数据，我们是不需要的。固定一个数，当`left`和`right`指向位置符合要求后，就需要考虑重复问题，进行去重操作。当然不止`left`和`right`需要去重，固定的数据也需要完成去重操作，避免越界`[0, 0, 0, 0]`。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8cd619ffefe24de8bffbd0ea07fa7c5c.png)\n\n【**代码展示**】\n\n```prism language-cpp\nclass Solution\n{\n    public:\n    vector<vector<int>> threeSum(vector<int>& nums) \n    {\n        vector<vector<int>> v;\n\n        // -3 -2 -1\n        //排序下\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        for(int i = 0; i < n - 2 ;  )\n        {\n            \n            //不存在 nums[]+nums[] = minPositive_nums[i]\n            if(nums[i] > 0) break;\n\n            int left = i + 1, right =  n - 1;\n            int target = -nums[i];\n\n            while(left < right)\n            {\n                int sum = nums[left] + nums[right];\n                if(sum > target) right--;\n                else if(sum < target) left++;\n                else\n                {\n                    //初始化列表自动转为vector<int>类型\n                    v.push_back({nums[left], nums[right], nums[i]});\n                    left++;right--;\n                    //去重判断\n                    while(left < right && nums[left] == nums[left - 1]) left++;\n                    while(left < right && nums[right] == nums[right + 1]) right--;\n                }\n            }\n\n            //去重操作\n            //这里会到导致判断时，造成越界访问\n            //while(nums[i] == nums[i + 1]) i++;\n            i++;\n            ///关于越界访问，需要判断循环逻辑是否有问题。\n            while(i < n && nums[i] == nums[i - 1]) i++;\n        }\n        return v;\n    }\n```\n\n*** ** * ** ***\n\n### {#font_colorcornflowerblue18Plusfont_629}18.四数之和(三数之和Plus)\\[对撞指针、单调性\\]\n\n【**题目展示** 】：[18.四数之和](https://leetcode.cn/problems/4sum/submissions/597939657/)\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/68ebff45d7c44065b5e1ad9b49d52712.png)\n\n```prism language-cpp\n输入：nums = [1,0,-1,0,-2,2], target = 0\n输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n```\n\n【**算法思路**】\n\n这里同样的，按照题目要求可以得到一个表达式`nums[a] + nums[b] + nums[left] + nums[right] == target`,按照我们熟悉的解法，我们是通过固定一个数，以left和right两个数作为边界向内进行查找。但是这里多出了一个数，那么不妨可以这样` nums[b] + nums[left] + nums[right] == target - nums[a]`，跟三数之和题目不是一样了吗？这里多次一个数的意义，就是多了一层循环。\n\n**1.解法一:排序 + 暴力枚举 + 利用set去重 时间复杂度O(N^4^)**\n\n**2.解法二:对撞指针**\n\n![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://i-blog.csdnimg.cn/direct/0538fb10d81c48a19edbdefc3b7d1fdd.png)\n\n【**问题：栈溢出**】\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9737a09a647d49ab8145d2ed4e08b400.png)\n\n对此这里需要考虑数据的范围将`dest`和`target`类型转化为`long long`\n\n【**代码展示**】\n\n```prism language-cpp\nclass Solution \n{\n    public:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) \n    {\n        //-4 - 3 -2 -1\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        vector<vector<int>> v;\n        for(int i = 0; i < n - 3;)\n        {\n            for(int j = i + 1; j < n - 2;)\n            {\n                //新的目标数\n                long long dest = (long long)target - nums[i] - nums[j];\n                int left = j + 1, right = n - 1;\n                while(left < right)\n                {\n                    int sum = nums[left] + nums[right];\n                    if(sum > dest) right--;\n                    else if(sum < dest) left++;\n                    else\n                    {\n                        v.push_back({nums[i], nums[j], nums[left], nums[right]});\n                        left++;right--;\n                        //去重操作\n                        while(left < right && nums[left] == nums[left - 1]) left++;\n                        while(left < right && nums[right] == nums[right + 1]) right--;\n                    }\n                }\n                j++;\n                while(j < n - 2 && nums[j] == nums[j - 1])  j++;\n            }\n            i++;\n            while(i < n - 3 && nums[i] == nums[i - 1])  i++;\n        }\n        return v;\n    }\n};\n```\n\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/2302_79177254/article/details/147440344?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-05-16 16:47:04', '2025-05-16 17:56:49');
INSERT INTO `sys_article` VALUES (306, 1, 20, 'C盘清理技巧以及临时文件的一些清理方法', 'img/C盘清理技巧以及临时文件的一些清理方法.png', 'C盘清理', '<br />\n<h4><a id=\"_2\"></a>文章目录</h4>\n<ul>\n<li><a href=\"#C_1\">C盘清理技巧以及临时文件的一些清理方法</a></li>\n<li>\n<ul>\n<li><a href=\"#C_3\">前言：为什么C盘需要定期清理？</a></li>\n<li><a href=\"#C_18\">一、C盘爆满的常见原因</a></li>\n<li><a href=\"#C_33\">二、几种主要的C盘清理方法</a></li>\n<li>\n<ul>\n<li><a href=\"#1__35\">1. 清理临时文件</a></li>\n<li><a href=\"#2_Windows_64\">2. 使用Windows内置磁盘清理工具</a></li>\n<li><a href=\"#3__88\">3. 开启存储感知自动清理</a></li>\n<li><a href=\"#4__109\">4. 清理系统还原点和旧的系统备份</a></li>\n<li><a href=\"#5__121\">5. 移动或删除个人文件</a></li>\n<li><a href=\"#6__141\">6. 优化桌面文件存储位置</a></li>\n<li><a href=\"#7__157\">7. 调整虚拟内存和休眠文件设置</a></li>\n<li><a href=\"#_178\">休眠功能开启时：</a></li>\n<li><a href=\"#_185\">休眠功能关闭时：</a></li>\n<li><a href=\"#8__193\">8. 清理浏览器缓存</a></li>\n<li><a href=\"#9__212\">9. 定期清空回收站</a></li>\n<li><a href=\"#10__226\">10. 更改新内容保存位置</a></li>\n</ul>\n</li>\n<li><a href=\"#_237\">三、专业清理工具推荐</a></li>\n<li>\n<ul>\n<li><a href=\"#Revo_Uninstaller_272\">Revo Uninstaller详细介绍</a></li>\n<li>\n<ul>\n<li><a href=\"#_276\">软件界面</a></li>\n<li><a href=\"#_279\">主要功能</a></li>\n<li><a href=\"#_308\">使用方法</a></li>\n<li><a href=\"#Revo_Uninstaller_340\">Revo Uninstaller与常规卸载的区别</a></li>\n<li><a href=\"#_351\">使用技巧</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#_381\">四、注意事项</a></li>\n<li><a href=\"#_393\">总结</a></li>\n</ul>\n</li>\n</ul>\n<br />\n<h2><a id=\"C_1C_content_views_36\"></a>{#C_1}C盘清理技巧以及临时文件的一些清理方法 {#content_views}</h2>\n<h3><a id=\"C_3C_39\"></a>{#C_3}前言：为什么C盘需要定期清理？</h3>\n<p>在Windows系统中，C盘作为系统盘承载着操作系统的运行和各种软件的安装。随着时间的推移，系统和应用不断产生临时文件、缓存和日志，这些文件会逐渐积累占用大量C盘空间。当C盘空间不足时，不仅会影响系统性能和运行速度，还可能导致以下问题：</p>\n<ul>\n<li>系统运行缓慢、频繁卡顿</li>\n<li>无法安装重要的Windows更新</li>\n<li>程序无响应或启动失败</li>\n<li>系统崩溃和蓝屏</li>\n<li>无法存储新文件</li>\n<li>系统启动速度变慢</li>\n</ul>\n<p>那么，为什么Windows默认将系统安装在C盘呢？这其实是一个历史传统。在早期的计算机时代，A盘和B盘被保留给软盘驱动器使用，因此系统默认安装在C盘，这一传统一直延续至今。虽然现在可以自定义安装路径，但大多数软件仍默认安装在C盘，而且许多系统文件和配置也必须存放在C盘。</p>\n<p>接下来，我们将详细介绍如何有效清理C盘，释放宝贵的空间资源。</p>\n<h3><a id=\"C_18C_54\"></a>{#C_18}一、C盘爆满的常见原因</h3>\n<p>在进行C盘清理前，首先要了解C盘空间被占用的主要原因：</p>\n<ol>\n<li><strong>系统文件和更新</strong>：Windows操作系统文件、系统更新文件和补丁会占用大量空间</li>\n<li><strong>程序和应用软件</strong>：默认安装在C盘的软件，特别是大型软件如Adobe套件、游戏等</li>\n<li><strong>用户数据</strong>：桌面、文档、下载等默认保存在C盘的个人文件</li>\n<li><strong>临时文件和缓存</strong>：系统和应用产生的各类临时文件、缓存文件</li>\n<li><strong>虚拟内存和休眠文件</strong>：pagefile.sys（虚拟内存）和hiberfil.sys（休眠文件）</li>\n<li><strong>浏览器缓存和历史记录</strong>：各种浏览器产生的缓存文件和历史记录</li>\n<li><strong>系统还原点和备份</strong>：系统自动创建的还原点和备份文件</li>\n<li><strong>回收站文件</strong>：已删除但未清空回收站的文件</li>\n</ol>\n<p>了解了这些原因，我们就能有针对性地进行清理工作。</p>\n<h3><a id=\"C_33C_69\"></a>{#C_33}二、几种主要的C盘清理方法</h3>\n<h4><a id=\"1__351__71\"></a>{#1__35}1. 清理临时文件</h4>\n<p>临时文件是C盘中最容易积累且可以安全删除的文件之一。Windows系统中存在两类临时文件夹：</p>\n<ul>\n<li><strong>用户临时文件夹</strong>：存储当前用户相关的临时文件</li>\n<li><strong>系统临时文件夹</strong>：存储系统级的临时文件</li>\n</ul>\n<p><strong>清理方法：</strong></p>\n<ol>\n<li>按下<code>Win + R</code>组合键，打开&quot;运行&quot;对话框</li>\n<li>输入<code>%temp%</code>并按回车，打开用户临时文件夹</li>\n<li>按<code>Ctrl + A</code>全选所有文件，然后按<code>Ctrl + D</code>键删除这些文件\n<ul>\n<li>如果有文件无法删除（正在被使用），可以跳过这些文件</li>\n</ul>\n</li>\n<li>再次打开&quot;运行&quot;对话框，输入<code>temp</code>并按回车</li>\n<li>同样地，删除此文件夹中的所有文件</li>\n</ol>\n<p>临时文件夹的区别</p>\n<table>\n<thead>\n<tr>\n<th>特征</th>\n<th>%temp%文件夹</th>\n<th>temp文件夹</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>作用范围</td>\n<td>用户特定</td>\n<td>系统级</td>\n</tr>\n<tr>\n<td>位置</td>\n<td>C:\\Users\\用户名\\AppData\\Local\\Temp</td>\n<td>C:\\Windows\\Temp</td>\n</tr>\n<tr>\n<td>访问方式</td>\n<td>通过运行命令和文件资源管理器</td>\n<td>通过运行命令和文件资源管理器</td>\n</tr>\n<tr>\n<td>权限要求</td>\n<td>不需要管理员权限即可修改</td>\n<td>需要管理员权限才能删除文件</td>\n</tr>\n<tr>\n<td>使用者</td>\n<td>已安装的应用程序、浏览器、用户进程等</td>\n<td>Windows系统和服务</td>\n</tr>\n</tbody>\n</table>\n<h4><a id=\"2_Windows_642_Windows_97\"></a>{#2_Windows_64}2. 使用Windows内置磁盘清理工具</h4>\n<p>Windows提供了一个强大的内置工具来清理磁盘空间------磁盘清理工具。它可以帮助识别和删除各种不必要的文件。</p>\n<p><strong>操作步骤：</strong></p>\n<ol>\n<li>在任务栏搜索框中输入&quot;磁盘清理&quot;并选择打开</li>\n<li>选择要清理的驱动器（通常为C盘），然后点击&quot;确定&quot;</li>\n<li>工具将扫描驱动器并显示可以删除的文件类型</li>\n<li>勾选想要删除的文件类型，例如：\n<ul>\n<li>下载的程序文件</li>\n<li>临时Internet文件</li>\n<li>DirectX着色器缓存</li>\n<li>传递优化文件</li>\n<li>回收站</li>\n<li>临时文件</li>\n<li>缩略图</li>\n</ul>\n</li>\n<li>点击&quot;清理系统文件&quot;获取更多清理选项</li>\n<li>再次勾选需要删除的文件，然后点击&quot;确定&quot;</li>\n<li>在确认窗口中选择&quot;删除文件&quot;开始清理<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/71581c396e094932bda357b8daf61fe9.png\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<blockquote>\n<p><strong>注意</strong>：如果你最近10天内升级了Windows，&quot;以前版本的Windows&quot;也会列为可删除的系统文件。删除它会节省大量空间，但你将无法回滚到之前的Windows版本。</p>\n</blockquote>\n<h4><a id=\"3__883__121\"></a>{#3__88}3. 开启存储感知自动清理</h4>\n<p>存储感知是Windows 10引入并在Windows 11中增强的功能，它可以自动清理临时文件、回收站内的文件和其他不必要的内容，为系统释放空间。</p>\n<p><strong>开启存储感知：</strong></p>\n<ol>\n<li>点击&quot;开始&quot;→&quot;设置&quot;→&quot;系统&quot;→&quot;存储&quot;</li>\n<li>在&quot;存储管理&quot;下找到&quot;存储感知&quot;选项</li>\n<li>将开关切换到&quot;开启&quot;状态</li>\n<li>点击&quot;存储感知&quot;进入详细配置页面</li>\n<li>可以设置以下选项：\n<ul>\n<li>自动运行存储感知的频率（每天、每周、每月）</li>\n<li>何时删除回收站中的文件</li>\n<li>何时删除下载文件夹中的文件</li>\n<li>是否删除云内容的本地副本</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/4bfb701005e243c89569f00c89119141.png\" alt=\"在这里插入图片描述\" /></p>\n<p>存储感知是一种便捷的自动清理解决方案，特别适合不想手动清理系统的用户。</p>\n<h4><a id=\"4__1094__141\"></a>{#4__109}4. 清理系统还原点和旧的系统备份</h4>\n<p>系统还原点和备份文件能在系统出现问题时帮助你恢复，但它们也会占用大量存储空间。如果系统稳定运行，可以考虑清理一些旧的还原点。</p>\n<p><strong>清理系统还原点：</strong></p>\n<ol>\n<li>右键点击&quot;此电脑&quot;，选择&quot;属性&quot;</li>\n<li>点击&quot;系统保护&quot;</li>\n<li>在&quot;系统属性&quot;窗口中，选择C盘，然后点击&quot;配置&quot;</li>\n<li>点击&quot;删除&quot;删除所有还原点，或调整&quot;最大使用空间&quot;滑块减少分配给还原点的空间</li>\n<li>点击&quot;应用&quot;和&quot;确定&quot;保存更改</li>\n</ol>\n<h4><a id=\"5__1215__153\"></a>{#5__121}5. 移动或删除个人文件</h4>\n<p>个人文件如视频、音乐、照片和文档可能占用大量C盘空间。找出并移动这些大文件是释放C盘空间的有效方法。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li>从任务栏打开&quot;文件资源管理器&quot; 也可以使用 <code>Win + E</code>快捷键快速打开</li>\n<li>在左侧菜单的&quot;此电脑&quot;下选择不同文件夹查看内容</li>\n<li>点击&quot;查看&quot;选项卡，选择&quot;详细信息&quot;视图</li>\n<li>右键点击空白处，选择&quot;排序方式&quot;&gt;“大小”，将最大文件显示在顶部</li>\n<li>确定不再需要的文件可以删除，或将重要文件移动到外部存储设备</li>\n</ol>\n<p><strong>移动文件到其他驱动器：</strong></p>\n<ol>\n<li>将外部存储设备（如U盘或SD卡）连接到电脑</li>\n<li>打开&quot;文件资源管理器&quot;，找到要移动的文件</li>\n<li>选择文件，点击&quot;剪切&quot;</li>\n<li>导航到外部存储设备位置，点击&quot;粘贴&quot;</li>\n</ol>\n<h4><a id=\"6__1416__172\"></a>{#6__141}6. 优化桌面文件存储位置</h4>\n<p>许多用户习惯将文件保存在桌面上，但可能不知道桌面文件实际上是存储在C盘的。重新定位桌面文件夹可以帮助释放C盘空间。</p>\n<p><strong>移动桌面文件夹位置：</strong></p>\n<ol>\n<li>右键点击桌面上的&quot;桌面&quot;文件夹</li>\n<li>选择&quot;属性&quot;</li>\n<li>切换到&quot;位置&quot;选项卡</li>\n<li>点击&quot;移动&quot;，选择一个新位置（如D盘或E盘）</li>\n<li>点击&quot;应用&quot;，系统会询问是否将现有文件也迁移，点击&quot;是&quot;</li>\n</ol>\n<p>同样的方法也适用于&quot;文档&quot;、“下载”、“图片”、&quot;视频&quot;和&quot;音乐&quot;等用户文件夹。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/433c268e0d64498ba3043157c6dd2cf5.png\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"7__1577__188\"></a>{#7__157}7. 调整虚拟内存和休眠文件设置</h4>\n<p>虚拟内存和休眠文件可能占用大量C盘空间。通过调整这些设置，也可以节省不少空间。</p>\n<p><strong>调整虚拟内存设置：</strong></p>\n<ol>\n<li>右键点击&quot;此电脑&quot;，选择&quot;属性&quot;</li>\n<li>点击&quot;高级系统设置&quot;</li>\n<li>在&quot;性能&quot;下，点击&quot;设置&quot;</li>\n<li>切换到&quot;高级&quot;选项卡，点击&quot;虚拟内存&quot;中的&quot;更改&quot;</li>\n<li>取消勾选&quot;自动管理所有驱动器的分页文件大小&quot;</li>\n<li>选择C盘，点击&quot;无分页文件&quot;</li>\n<li>选择其他驱动器（如D盘），点击&quot;系统管理的大小&quot;</li>\n<li>点击&quot;设置&quot;，然后点击&quot;确定&quot;</li>\n</ol>\n<p><strong>关闭休眠功能：</strong></p>\n<ol>\n<li>以管理员身份打开命令提示符（按下<code>Win + X</code>，选择&quot;命令提示符(管理员)&quot;）</li>\n<li>输入以下命令并按回车：<code>powercfg -h off</code></li>\n<li>关闭窗口</li>\n</ol>\n<blockquote>\n<h4><a id=\"_178_209\"></a>{#_178}休眠功能开启时：</h4>\n<ol>\n<li><strong>磁盘空间使用</strong>：系统会在C盘创建一个大小约等于物理内存(RAM)的hiberfil.sys文件，用于存储内存内容</li>\n<li><strong>完全关机选项</strong>：关机菜单中会有&quot;休眠&quot;选项，允许将当前工作状态保存后完全断电</li>\n<li><strong>快速启动功能</strong>：启用休眠后，Windows的&quot;快速启动&quot;功能也可使用（这是一种混合休眠模式）</li>\n<li><strong>电源消耗</strong>：休眠状态下计算机完全断电，不消耗电力（与睡眠模式不同）</li>\n<li><strong>恢复速度</strong>：从休眠状态恢复比完全关机后重启要快，但比从睡眠状态恢复要慢</li>\n</ol>\n<h4><a id=\"_185_217\"></a>{#_185}休眠功能关闭时：</h4>\n<ol>\n<li><strong>节省磁盘空间</strong>：没有hiberfil.sys文件，可释放相当于RAM大小的硬盘空间</li>\n<li><strong>没有休眠选项</strong>：关机菜单中不会显示休眠选项</li>\n<li><strong>快速启动受限</strong>：无法使用依赖休眠功能的快速启动特性</li>\n<li><strong>系统更新</strong>：某些系统更新可能更顺畅，因为没有休眠文件占用空间或可能引起的冲突<br />\n<strong>对于大多数现代计算机，如果磁盘空间充足且偶尔需要保存工作状态再断电，建议保持休眠功能开启。如果磁盘空间紧张或追求&quot;纯净&quot;关机，可以考虑关闭它。</strong></li>\n</ol>\n</blockquote>\n<h4><a id=\"8__1938__225\"></a>{#8__193}8. 清理浏览器缓存</h4>\n<p>浏览器保存的缓存文件可能占用大量空间。定期清理这些缓存可以释放C盘空间。</p>\n<p><strong>Google Chrome清理步骤：</strong></p>\n<ol>\n<li>打开Chrome浏览器</li>\n<li>点击右上角的三点菜单，选择&quot;更多工具&quot;→&quot;清除浏览数据&quot;</li>\n<li>选择&quot;所有时间&quot;，并勾选&quot;缓存的图像和文件&quot;</li>\n<li>点击&quot;清除数据&quot;</li>\n</ol>\n<p><strong>Microsoft Edge清理步骤：</strong></p>\n<ol>\n<li>打开Edge浏览器</li>\n<li>点击右上角的三点菜单，选择&quot;设置&quot;</li>\n<li>在&quot;隐私、搜索和服务&quot;中，找到&quot;清除浏览数据&quot;</li>\n<li>点击&quot;选择要清除的内容&quot;</li>\n<li>勾选&quot;缓存的图像和文件&quot;，然后点击&quot;立即清除&quot;</li>\n</ol>\n<h4><a id=\"9__2129__244\"></a>{#9__212}9. 定期清空回收站</h4>\n<p>回收站中的文件虽然已被&quot;删除&quot;，但实际上仍然占用着C盘空间。回收站中的文件越多，占用的空间就越大。</p>\n<p><strong>清空回收站：</strong></p>\n<ol>\n<li>右键点击桌面上的&quot;回收站&quot;图标</li>\n<li>选择&quot;清空回收站&quot;</li>\n<li>在确认对话框中点击&quot;是&quot;</li>\n</ol>\n<blockquote>\n<p><strong>提示</strong>：可以设置回收站自动清空，方法是右键点击回收站，选择&quot;属性&quot;，然后勾选&quot;不将文件移动到回收站。删除文件时直接删除&quot;选项。</p>\n</blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/797cc47be3fb43468d3735ac012e1415.png\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"10__22610__258\"></a>{#10__226}10. 更改新内容保存位置</h4>\n<p>将新文件保存到其他驱动器可以预防C盘空间不足问题，避免以后反复移动文件的麻烦。</p>\n<p><strong>更改新内容保存位置：</strong></p>\n<ol>\n<li>点击&quot;开始&quot;→&quot;设置&quot;→&quot;系统&quot;→&quot;存储&quot;</li>\n<li>在Windows 11中，点击&quot;高级存储设置&quot;→&quot;保存新建内容位置&quot;（在Windows 10中，向下滚动找到&quot;更改新内容保存位置&quot;）</li>\n<li>为每种内容类型（文档、音乐、图片、视频等）选择一个驱动器</li>\n<li>点击&quot;应用&quot;保存更改</li>\n</ol>\n<h3><a id=\"_237_269\"></a>{#_237}三、专业清理工具推荐</h3>\n<p>除了系统内置工具，还有一些专业的清理工具可以帮助您更全面、深入地清理系统：</p>\n<ol>\n<li>\n<p><strong>CCleaner</strong></p>\n<ul>\n<li><strong>优点</strong>：界面简洁，操作简单，功能全面</li>\n<li><strong>特点</strong>：可清理各种临时文件、浏览器缓存、注册表错误等</li>\n<li><strong>适用人群</strong>：普通用户</li>\n</ul>\n</li>\n<li>\n<p><strong>Wise Disk Cleaner</strong></p>\n<ul>\n<li><strong>优点</strong>：深度清理能力强，支持磁盘碎片整理</li>\n<li><strong>特点</strong>：可自定义清理选项，支持定期自动清理</li>\n<li><strong>适用人群</strong>：需要定期清理的用户</li>\n</ul>\n</li>\n<li>\n<p><strong>BleachBit</strong></p>\n<ul>\n<li><strong>优点</strong>：开源软件，没有广告和捆绑软件</li>\n<li><strong>特点</strong>：支持深度清理系统和应用程序临时文件</li>\n<li><strong>适用人群</strong>：关注隐私的进阶用户</li>\n</ul>\n</li>\n<li>\n<p><strong>Glary Utilities</strong></p>\n<ul>\n<li><strong>优点</strong>：集成多种功能，不仅限于磁盘清理</li>\n<li><strong>特点</strong>：提供一键优化功能，界面友好</li>\n<li><strong>适用人群</strong>：希望全面优化系统的用户</li>\n</ul>\n</li>\n<li>\n<p><strong>Windows优化大师/金山毒霸C盘瘦身工具</strong></p>\n<ul>\n<li><strong>优点</strong>：针对中文用户优化，操作简单</li>\n<li><strong>特点</strong>：提供大文件专清、C盘瘦身、微信/QQ专清等功能</li>\n<li><strong>适用人群</strong>：需要针对特定软件清理的中文用户</li>\n</ul>\n</li>\n<li>\n<p><strong>Revo Uninstaller(推荐）</strong></p>\n<ul>\n<li><strong>优点</strong>：彻底卸载软件，清理残留文件和注册表项，释放C盘空间</li>\n<li><strong>特点</strong>：提供多种卸载模式，支持批量卸载和强制卸载</li>\n<li><strong>适用人群</strong>：需要彻底清理已安装软件的用户</li>\n<li><strong>版本</strong>：提供免费版和专业版，还有注册表清理专用工具</li>\n</ul>\n</li>\n</ol>\n<h4><a id=\"Revo_Uninstaller_272Revo_Uninstaller_305\"></a>{#Revo_Uninstaller_272}Revo Uninstaller详细介绍</h4>\n<p>Revo Uninstaller是一款强大的软件卸载和系统清理工具，它不仅能卸载软件，还能扫描并清理卸载后的残留文件、文件夹和注册表项，从而彻底释放C盘空间。</p>\n<h5><a id=\"_276_309\"></a>{#_276}软件界面</h5>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/8a91b765ec8a461888098da59683f4a4.png\" alt=\"在这里插入图片描述\" /></p>\n<h5><a id=\"_279_313\"></a>{#_279}主要功能</h5>\n<ol>\n<li>\n<p><strong>高级卸载功能</strong></p>\n<ul>\n<li><strong>标准卸载</strong>：使用软件自带的卸载程序卸载软件</li>\n<li><strong>高级卸载</strong>：卸载软件后扫描并删除残留的文件和注册表项</li>\n<li><strong>强制卸载</strong>：适用于已损坏或无法正常卸载的软件</li>\n<li><strong>批量卸载</strong>：一次性卸载多个程序，节省时间</li>\n</ul>\n</li>\n<li>\n<p><strong>监控系统变更</strong></p>\n<ul>\n<li>实时监控软件安装过程中的系统变更</li>\n<li>记录新建的文件、文件夹和注册表项</li>\n<li>在卸载时可以完全恢复到安装前状态</li>\n</ul>\n</li>\n<li>\n<p><strong>日志数据库</strong></p>\n<ul>\n<li>包含常用软件的卸载信息和残留文件位置</li>\n<li>可以更彻底地清理特定软件的残留</li>\n</ul>\n</li>\n<li>\n<p><strong>系统工具</strong></p>\n<ul>\n<li>自动启动管理器：管理开机启动项</li>\n<li>垃圾文件清理：清理浏览器缓存、临时文件等</li>\n<li>Windows工具管理器：快速访问系统工具</li>\n</ul>\n</li>\n<li>\n<p><strong>专业版独有功能</strong>（Pro版本）</p>\n<ul>\n<li>实时安装监控</li>\n<li>多级备份系统</li>\n<li>批量卸载工具</li>\n<li>浏览器扩展管理器</li>\n<li>高级扫描算法</li>\n</ul>\n</li>\n</ol>\n<h5><a id=\"_308_343\"></a>{#_308}使用方法</h5>\n<p><strong>基本卸载流程：</strong></p>\n<ol>\n<li>打开Revo Uninstaller</li>\n<li>在程序列表中找到要卸载的软件</li>\n<li>右键点击或选择左侧的&quot;卸载&quot;按钮</li>\n<li>选择卸载模式（适中、高级、安全）<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/9b79a44d102a4d6185fecff2a444d0f8.png\" alt=\"在这里插入图片描述\" /></li>\n<li>程序会先运行软件自带的卸载程序</li>\n<li>卸载完成后，Revo会自动扫描残留文件和注册表项</li>\n<li>勾选要删除的残留项，点击&quot;删除&quot;</li>\n<li>完成清理</li>\n</ol>\n<p><strong>强制卸载模式：</strong></p>\n<ol>\n<li>在Revo Uninstaller中找不到要卸载的程序时，使用&quot;强制卸载&quot;功能</li>\n<li>点击工具栏中的&quot;强制卸载&quot;按钮</li>\n<li>通过浏览找到程序的安装文件夹或可执行文件</li>\n<li>选择扫描模式（适中、高级、安全）</li>\n<li>程序会扫描与该软件相关的所有文件和注册表项</li>\n<li>勾选要删除的项目，点击&quot;删除&quot;</li>\n</ol>\n<p><strong>批量卸载</strong>（Pro版本）：</p>\n<ol>\n<li>点击&quot;工具&quot;菜单中的&quot;批量卸载&quot;</li>\n<li>勾选要卸载的多个程序</li>\n<li>点击&quot;卸载选中项&quot;</li>\n<li>程序会依次卸载所选软件并清理残留</li>\n</ol>\n<h5><a id=\"Revo_Uninstaller_340Revo_Uninstaller_373\"></a>{#Revo_Uninstaller_340}Revo Uninstaller与常规卸载的区别</h5>\n<table>\n<thead>\n<tr>\n<th>功能对比</th>\n<th>Windows控制面板卸载</th>\n<th>Revo Uninstaller</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>卸载方式</td>\n<td>仅运行软件自带卸载程序</td>\n<td>软件自带卸载+残留扫描清理</td>\n</tr>\n<tr>\n<td>残留清理</td>\n<td>不清理残留</td>\n<td>全面清理文件和注册表残留</td>\n</tr>\n<tr>\n<td>强制卸载</td>\n<td>不支持</td>\n<td>支持（适用于已损坏的程序）</td>\n</tr>\n<tr>\n<td>批量卸载</td>\n<td>不支持</td>\n<td>支持（Pro版本）</td>\n</tr>\n<tr>\n<td>安装监控</td>\n<td>不支持</td>\n<td>支持（Pro版本）</td>\n</tr>\n<tr>\n<td>历史备份</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n</tbody>\n</table>\n<h5><a id=\"_351_384\"></a>{#_351}使用技巧</h5>\n<ol>\n<li>\n<p><strong>选择合适的扫描模式</strong></p>\n<ul>\n<li><strong>安全模式</strong>：只删除与软件直接相关的项目，适合初学者</li>\n<li><strong>适中模式</strong>：扫描范围更广，能删除大部分残留，适合普通用户</li>\n<li><strong>高级模式</strong>：最彻底的扫描，需要一定的技术知识，适合高级用户</li>\n</ul>\n</li>\n<li>\n<p><strong>使用Hunter模式</strong></p>\n<ul>\n<li>开启Hunter模式（瞄准镜图标）可以直接瞄准桌面或任务栏上的程序图标进行卸载</li>\n<li>特别适合卸载找不到的小程序或工具栏</li>\n</ul>\n</li>\n<li>\n<p><strong>利用安装监控</strong>（Pro版本）</p>\n<ul>\n<li>安装新软件前开启安装监控</li>\n<li>记录安装过程中的所有系统变更</li>\n<li>卸载时可以完全恢复到安装前状态</li>\n</ul>\n</li>\n<li>\n<p><strong>定期清理注册表</strong></p>\n<ul>\n<li>使用Revo Registry Cleaner功能定期清理注册表</li>\n<li>可以修复损坏的注册表项，提高系统性能</li>\n</ul>\n</li>\n</ol>\n<p>Revo Uninstaller是清理C盘空间的有效工具，尤其适合通过彻底卸载不需要的软件来释放空间。与一般的卸载方式相比，它能够更彻底地清理软件残留，防止C盘被无用文件占用。</p>\n<p>选择清理工具时，建议考虑以下因素：</p>\n<ul>\n<li>清理效果和系统兼容性</li>\n<li>操作难易程度</li>\n<li>安全性和隐私保护</li>\n<li>是否带有额外的优化功能</li>\n</ul>\n<h3><a id=\"_381_414\"></a>{#_381}四、注意事项</h3>\n<p>在清理C盘时，需要注意以下几点：</p>\n<ol>\n<li><strong>备份重要数据</strong>：在进行任何清理操作前，备份重要文件和数据，防止误删</li>\n<li><strong>谨慎删除系统文件</strong>：不要删除不了解的系统文件，特别是Windows目录下的文件</li>\n<li><strong>避免使用&quot;一键清理&quot;工具</strong>：除非你确切了解其清理内容，否则不要使用第三方的&quot;一键清理&quot;功能</li>\n<li><strong>定期清理</strong>：建立定期清理的习惯，避免垃圾文件长期堆积</li>\n<li><strong>选择合适的软件安装位置</strong>：安装新软件时，尽量选择非C盘的位置</li>\n<li><strong>关注大文件</strong>：优先处理那些占用空间大的文件，如视频、游戏、虚拟机文件等</li>\n<li><strong>不要过度清理缓存</strong>：某些缓存文件有助于提高系统和应用的运行速度，不要过度清理</li>\n</ol>\n<h3><a id=\"_393_426\"></a>{#_393}总结</h3>\n<p>C盘作为系统盘，其空间状态直接影响计算机的整体性能。通过本文介绍的各种清理技巧，您可以有效释放C盘空间，提升系统运行效率。</p>\n<p>定期维护C盘不仅能让电脑运行更顺畅，还能延长硬件寿命。建议养成良好的电脑使用习惯：</p>\n<ul>\n<li>定期清理临时文件和系统缓存</li>\n<li>合理规划文件存储位置</li>\n<li>谨慎选择软件安装位置</li>\n<li>保持桌面整洁</li>\n<li>关注大文件的存储位置</li>\n</ul>\n<p>最后，记住一个原则：清理是为了让系统运行得更好，而不仅仅是为了释放空间。在清理的同时，也要保留系统和应用正常运行所需的必要文件。希望这篇文章能帮助您更有效地管理C盘空间，让电脑保持最佳状态！</p>\n', '<br />\n\n#### 文章目录\n\n* [C盘清理技巧以及临时文件的一些清理方法](#C_1)\n*\n  * [前言：为什么C盘需要定期清理？](#C_3)\n  * [一、C盘爆满的常见原因](#C_18)\n  * [二、几种主要的C盘清理方法](#C_33)\n  *\n    * [1. 清理临时文件](#1__35)\n    * [2. 使用Windows内置磁盘清理工具](#2_Windows_64)\n    * [3. 开启存储感知自动清理](#3__88)\n    * [4. 清理系统还原点和旧的系统备份](#4__109)\n    * [5. 移动或删除个人文件](#5__121)\n    * [6. 优化桌面文件存储位置](#6__141)\n    * [7. 调整虚拟内存和休眠文件设置](#7__157)\n    * [休眠功能开启时：](#_178)\n    * [休眠功能关闭时：](#_185)\n    * [8. 清理浏览器缓存](#8__193)\n    * [9. 定期清空回收站](#9__212)\n    * [10. 更改新内容保存位置](#10__226)\n  * [三、专业清理工具推荐](#_237)\n  *\n    * [Revo Uninstaller详细介绍](#Revo_Uninstaller_272)\n    *\n      * [软件界面](#_276)\n      * [主要功能](#_279)\n      * [使用方法](#_308)\n      * [Revo Uninstaller与常规卸载的区别](#Revo_Uninstaller_340)\n      * [使用技巧](#_351)\n  * [四、注意事项](#_381)\n  * [总结](#_393)\n\n<br />\n\n{#C_1}C盘清理技巧以及临时文件的一些清理方法 {#content_views}\n------------------------------------------\n\n### {#C_3}前言：为什么C盘需要定期清理？\n\n在Windows系统中，C盘作为系统盘承载着操作系统的运行和各种软件的安装。随着时间的推移，系统和应用不断产生临时文件、缓存和日志，这些文件会逐渐积累占用大量C盘空间。当C盘空间不足时，不仅会影响系统性能和运行速度，还可能导致以下问题：\n\n* 系统运行缓慢、频繁卡顿\n* 无法安装重要的Windows更新\n* 程序无响应或启动失败\n* 系统崩溃和蓝屏\n* 无法存储新文件\n* 系统启动速度变慢\n\n那么，为什么Windows默认将系统安装在C盘呢？这其实是一个历史传统。在早期的计算机时代，A盘和B盘被保留给软盘驱动器使用，因此系统默认安装在C盘，这一传统一直延续至今。虽然现在可以自定义安装路径，但大多数软件仍默认安装在C盘，而且许多系统文件和配置也必须存放在C盘。\n\n接下来，我们将详细介绍如何有效清理C盘，释放宝贵的空间资源。\n\n### {#C_18}一、C盘爆满的常见原因\n\n在进行C盘清理前，首先要了解C盘空间被占用的主要原因：\n\n1. **系统文件和更新**：Windows操作系统文件、系统更新文件和补丁会占用大量空间\n2. **程序和应用软件**：默认安装在C盘的软件，特别是大型软件如Adobe套件、游戏等\n3. **用户数据**：桌面、文档、下载等默认保存在C盘的个人文件\n4. **临时文件和缓存**：系统和应用产生的各类临时文件、缓存文件\n5. **虚拟内存和休眠文件**：pagefile.sys（虚拟内存）和hiberfil.sys（休眠文件）\n6. **浏览器缓存和历史记录**：各种浏览器产生的缓存文件和历史记录\n7. **系统还原点和备份**：系统自动创建的还原点和备份文件\n8. **回收站文件**：已删除但未清空回收站的文件\n\n了解了这些原因，我们就能有针对性地进行清理工作。\n\n### {#C_33}二、几种主要的C盘清理方法\n\n#### {#1__35}1. 清理临时文件\n\n临时文件是C盘中最容易积累且可以安全删除的文件之一。Windows系统中存在两类临时文件夹：\n\n* **用户临时文件夹**：存储当前用户相关的临时文件\n* **系统临时文件夹**：存储系统级的临时文件\n\n**清理方法：**\n\n1. 按下`Win + R`组合键，打开\"运行\"对话框\n2. 输入`%temp%`并按回车，打开用户临时文件夹\n3. 按`Ctrl + A`全选所有文件，然后按`Ctrl + D`键删除这些文件\n   * 如果有文件无法删除（正在被使用），可以跳过这些文件\n4. 再次打开\"运行\"对话框，输入`temp`并按回车\n5. 同样地，删除此文件夹中的所有文件\n\n临时文件夹的区别\n\n|  特征  |              %temp%文件夹               |      temp文件夹      |\n|------|--------------------------------------|-------------------|\n| 作用范围 | 用户特定                                 | 系统级               |\n| 位置   | C:\\\\Users\\\\用户名\\\\AppData\\\\Local\\\\Temp | C:\\\\Windows\\\\Temp |\n| 访问方式 | 通过运行命令和文件资源管理器                       | 通过运行命令和文件资源管理器    |\n| 权限要求 | 不需要管理员权限即可修改                         | 需要管理员权限才能删除文件     |\n| 使用者  | 已安装的应用程序、浏览器、用户进程等                   | Windows系统和服务      |\n\n#### {#2_Windows_64}2. 使用Windows内置磁盘清理工具\n\nWindows提供了一个强大的内置工具来清理磁盘空间------磁盘清理工具。它可以帮助识别和删除各种不必要的文件。\n\n**操作步骤：**\n\n1. 在任务栏搜索框中输入\"磁盘清理\"并选择打开\n2. 选择要清理的驱动器（通常为C盘），然后点击\"确定\"\n3. 工具将扫描驱动器并显示可以删除的文件类型\n4. 勾选想要删除的文件类型，例如：\n   * 下载的程序文件\n   * 临时Internet文件\n   * DirectX着色器缓存\n   * 传递优化文件\n   * 回收站\n   * 临时文件\n   * 缩略图\n5. 点击\"清理系统文件\"获取更多清理选项\n6. 再次勾选需要删除的文件，然后点击\"确定\"\n7. 在确认窗口中选择\"删除文件\"开始清理  \n   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/71581c396e094932bda357b8daf61fe9.png)\n\n> **注意**：如果你最近10天内升级了Windows，\"以前版本的Windows\"也会列为可删除的系统文件。删除它会节省大量空间，但你将无法回滚到之前的Windows版本。\n\n#### {#3__88}3. 开启存储感知自动清理\n\n存储感知是Windows 10引入并在Windows 11中增强的功能，它可以自动清理临时文件、回收站内的文件和其他不必要的内容，为系统释放空间。\n\n**开启存储感知：**\n\n1. 点击\"开始\"→\"设置\"→\"系统\"→\"存储\"\n2. 在\"存储管理\"下找到\"存储感知\"选项\n3. 将开关切换到\"开启\"状态\n4. 点击\"存储感知\"进入详细配置页面\n5. 可以设置以下选项：\n   * 自动运行存储感知的频率（每天、每周、每月）\n   * 何时删除回收站中的文件\n   * 何时删除下载文件夹中的文件\n   * 是否删除云内容的本地副本\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4bfb701005e243c89569f00c89119141.png)\n\n存储感知是一种便捷的自动清理解决方案，特别适合不想手动清理系统的用户。\n\n#### {#4__109}4. 清理系统还原点和旧的系统备份\n\n系统还原点和备份文件能在系统出现问题时帮助你恢复，但它们也会占用大量存储空间。如果系统稳定运行，可以考虑清理一些旧的还原点。\n\n**清理系统还原点：**\n\n1. 右键点击\"此电脑\"，选择\"属性\"\n2. 点击\"系统保护\"\n3. 在\"系统属性\"窗口中，选择C盘，然后点击\"配置\"\n4. 点击\"删除\"删除所有还原点，或调整\"最大使用空间\"滑块减少分配给还原点的空间\n5. 点击\"应用\"和\"确定\"保存更改\n\n#### {#5__121}5. 移动或删除个人文件\n\n个人文件如视频、音乐、照片和文档可能占用大量C盘空间。找出并移动这些大文件是释放C盘空间的有效方法。\n\n**步骤：**\n\n1. 从任务栏打开\"文件资源管理器\" 也可以使用 `Win + E`快捷键快速打开\n2. 在左侧菜单的\"此电脑\"下选择不同文件夹查看内容\n3. 点击\"查看\"选项卡，选择\"详细信息\"视图\n4. 右键点击空白处，选择\"排序方式\"\\>\"大小\"，将最大文件显示在顶部\n5. 确定不再需要的文件可以删除，或将重要文件移动到外部存储设备\n\n**移动文件到其他驱动器：**\n\n1. 将外部存储设备（如U盘或SD卡）连接到电脑\n2. 打开\"文件资源管理器\"，找到要移动的文件\n3. 选择文件，点击\"剪切\"\n4. 导航到外部存储设备位置，点击\"粘贴\"\n\n#### {#6__141}6. 优化桌面文件存储位置\n\n许多用户习惯将文件保存在桌面上，但可能不知道桌面文件实际上是存储在C盘的。重新定位桌面文件夹可以帮助释放C盘空间。\n\n**移动桌面文件夹位置：**\n\n1. 右键点击桌面上的\"桌面\"文件夹\n2. 选择\"属性\"\n3. 切换到\"位置\"选项卡\n4. 点击\"移动\"，选择一个新位置（如D盘或E盘）\n5. 点击\"应用\"，系统会询问是否将现有文件也迁移，点击\"是\"\n\n同样的方法也适用于\"文档\"、\"下载\"、\"图片\"、\"视频\"和\"音乐\"等用户文件夹。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/433c268e0d64498ba3043157c6dd2cf5.png)\n\n#### {#7__157}7. 调整虚拟内存和休眠文件设置\n\n虚拟内存和休眠文件可能占用大量C盘空间。通过调整这些设置，也可以节省不少空间。\n\n**调整虚拟内存设置：**\n\n1. 右键点击\"此电脑\"，选择\"属性\"\n2. 点击\"高级系统设置\"\n3. 在\"性能\"下，点击\"设置\"\n4. 切换到\"高级\"选项卡，点击\"虚拟内存\"中的\"更改\"\n5. 取消勾选\"自动管理所有驱动器的分页文件大小\"\n6. 选择C盘，点击\"无分页文件\"\n7. 选择其他驱动器（如D盘），点击\"系统管理的大小\"\n8. 点击\"设置\"，然后点击\"确定\"\n\n**关闭休眠功能：**\n\n1. 以管理员身份打开命令提示符（按下`Win + X`，选择\"命令提示符(管理员)\"）\n2. 输入以下命令并按回车：`powercfg -h off`\n3. 关闭窗口\n\n> #### {#_178}休眠功能开启时：\n>\n> 1. **磁盘空间使用**：系统会在C盘创建一个大小约等于物理内存(RAM)的hiberfil.sys文件，用于存储内存内容\n> 2. **完全关机选项**：关机菜单中会有\"休眠\"选项，允许将当前工作状态保存后完全断电\n> 3. **快速启动功能**：启用休眠后，Windows的\"快速启动\"功能也可使用（这是一种混合休眠模式）\n> 4. **电源消耗**：休眠状态下计算机完全断电，不消耗电力（与睡眠模式不同）\n> 5. **恢复速度**：从休眠状态恢复比完全关机后重启要快，但比从睡眠状态恢复要慢\n>\n> #### {#_185}休眠功能关闭时：\n>\n> 1. **节省磁盘空间**：没有hiberfil.sys文件，可释放相当于RAM大小的硬盘空间\n> 2. **没有休眠选项**：关机菜单中不会显示休眠选项\n> 3. **快速启动受限**：无法使用依赖休眠功能的快速启动特性\n> 4. **系统更新**：某些系统更新可能更顺畅，因为没有休眠文件占用空间或可能引起的冲突\n> **对于大多数现代计算机，如果磁盘空间充足且偶尔需要保存工作状态再断电，建议保持休眠功能开启。如果磁盘空间紧张或追求\"纯净\"关机，可以考虑关闭它。**\n\n#### {#8__193}8. 清理浏览器缓存\n\n浏览器保存的缓存文件可能占用大量空间。定期清理这些缓存可以释放C盘空间。\n\n**Google Chrome清理步骤：**\n\n1. 打开Chrome浏览器\n2. 点击右上角的三点菜单，选择\"更多工具\"→\"清除浏览数据\"\n3. 选择\"所有时间\"，并勾选\"缓存的图像和文件\"\n4. 点击\"清除数据\"\n\n**Microsoft Edge清理步骤：**\n\n1. 打开Edge浏览器\n2. 点击右上角的三点菜单，选择\"设置\"\n3. 在\"隐私、搜索和服务\"中，找到\"清除浏览数据\"\n4. 点击\"选择要清除的内容\"\n5. 勾选\"缓存的图像和文件\"，然后点击\"立即清除\"\n\n#### {#9__212}9. 定期清空回收站\n\n回收站中的文件虽然已被\"删除\"，但实际上仍然占用着C盘空间。回收站中的文件越多，占用的空间就越大。\n\n**清空回收站：**\n\n1. 右键点击桌面上的\"回收站\"图标\n2. 选择\"清空回收站\"\n3. 在确认对话框中点击\"是\"\n\n> **提示**：可以设置回收站自动清空，方法是右键点击回收站，选择\"属性\"，然后勾选\"不将文件移动到回收站。删除文件时直接删除\"选项。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/797cc47be3fb43468d3735ac012e1415.png)\n\n#### {#10__226}10. 更改新内容保存位置\n\n将新文件保存到其他驱动器可以预防C盘空间不足问题，避免以后反复移动文件的麻烦。\n\n**更改新内容保存位置：**\n\n1. 点击\"开始\"→\"设置\"→\"系统\"→\"存储\"\n2. 在Windows 11中，点击\"高级存储设置\"→\"保存新建内容位置\"（在Windows 10中，向下滚动找到\"更改新内容保存位置\"）\n3. 为每种内容类型（文档、音乐、图片、视频等）选择一个驱动器\n4. 点击\"应用\"保存更改\n\n### {#_237}三、专业清理工具推荐\n\n除了系统内置工具，还有一些专业的清理工具可以帮助您更全面、深入地清理系统：\n\n1. **CCleaner**\n\n   * **优点**：界面简洁，操作简单，功能全面\n   * **特点**：可清理各种临时文件、浏览器缓存、注册表错误等\n   * **适用人群**：普通用户\n2. **Wise Disk Cleaner**\n\n   * **优点**：深度清理能力强，支持磁盘碎片整理\n   * **特点**：可自定义清理选项，支持定期自动清理\n   * **适用人群**：需要定期清理的用户\n3. **BleachBit**\n\n   * **优点**：开源软件，没有广告和捆绑软件\n   * **特点**：支持深度清理系统和应用程序临时文件\n   * **适用人群**：关注隐私的进阶用户\n4. **Glary Utilities**\n\n   * **优点**：集成多种功能，不仅限于磁盘清理\n   * **特点**：提供一键优化功能，界面友好\n   * **适用人群**：希望全面优化系统的用户\n5. **Windows优化大师/金山毒霸C盘瘦身工具**\n\n   * **优点**：针对中文用户优化，操作简单\n   * **特点**：提供大文件专清、C盘瘦身、微信/QQ专清等功能\n   * **适用人群**：需要针对特定软件清理的中文用户\n6. **Revo Uninstaller(推荐）**\n\n   * **优点**：彻底卸载软件，清理残留文件和注册表项，释放C盘空间\n   * **特点**：提供多种卸载模式，支持批量卸载和强制卸载\n   * **适用人群**：需要彻底清理已安装软件的用户\n   * **版本**：提供免费版和专业版，还有注册表清理专用工具\n\n#### {#Revo_Uninstaller_272}Revo Uninstaller详细介绍\n\nRevo Uninstaller是一款强大的软件卸载和系统清理工具，它不仅能卸载软件，还能扫描并清理卸载后的残留文件、文件夹和注册表项，从而彻底释放C盘空间。\n\n##### {#_276}软件界面\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8a91b765ec8a461888098da59683f4a4.png)\n\n##### {#_279}主要功能\n\n1. **高级卸载功能**\n\n   * **标准卸载**：使用软件自带的卸载程序卸载软件\n   * **高级卸载**：卸载软件后扫描并删除残留的文件和注册表项\n   * **强制卸载**：适用于已损坏或无法正常卸载的软件\n   * **批量卸载**：一次性卸载多个程序，节省时间\n2. **监控系统变更**\n\n   * 实时监控软件安装过程中的系统变更\n   * 记录新建的文件、文件夹和注册表项\n   * 在卸载时可以完全恢复到安装前状态\n3. **日志数据库**\n\n   * 包含常用软件的卸载信息和残留文件位置\n   * 可以更彻底地清理特定软件的残留\n4. **系统工具**\n\n   * 自动启动管理器：管理开机启动项\n   * 垃圾文件清理：清理浏览器缓存、临时文件等\n   * Windows工具管理器：快速访问系统工具\n5. **专业版独有功能**（Pro版本）\n\n   * 实时安装监控\n   * 多级备份系统\n   * 批量卸载工具\n   * 浏览器扩展管理器\n   * 高级扫描算法\n\n##### {#_308}使用方法\n\n**基本卸载流程：**\n\n1. 打开Revo Uninstaller\n2. 在程序列表中找到要卸载的软件\n3. 右键点击或选择左侧的\"卸载\"按钮\n4. 选择卸载模式（适中、高级、安全）  \n   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9b79a44d102a4d6185fecff2a444d0f8.png)\n5. 程序会先运行软件自带的卸载程序\n6. 卸载完成后，Revo会自动扫描残留文件和注册表项\n7. 勾选要删除的残留项，点击\"删除\"\n8. 完成清理\n\n**强制卸载模式：**\n\n1. 在Revo Uninstaller中找不到要卸载的程序时，使用\"强制卸载\"功能\n2. 点击工具栏中的\"强制卸载\"按钮\n3. 通过浏览找到程序的安装文件夹或可执行文件\n4. 选择扫描模式（适中、高级、安全）\n5. 程序会扫描与该软件相关的所有文件和注册表项\n6. 勾选要删除的项目，点击\"删除\"\n\n**批量卸载**（Pro版本）：\n\n1. 点击\"工具\"菜单中的\"批量卸载\"\n2. 勾选要卸载的多个程序\n3. 点击\"卸载选中项\"\n4. 程序会依次卸载所选软件并清理残留\n\n##### {#Revo_Uninstaller_340}Revo Uninstaller与常规卸载的区别\n\n| 功能对比 | Windows控制面板卸载 | Revo Uninstaller |\n|------|---------------|------------------|\n| 卸载方式 | 仅运行软件自带卸载程序   | 软件自带卸载+残留扫描清理    |\n| 残留清理 | 不清理残留         | 全面清理文件和注册表残留     |\n| 强制卸载 | 不支持           | 支持（适用于已损坏的程序）    |\n| 批量卸载 | 不支持           | 支持（Pro版本）        |\n| 安装监控 | 不支持           | 支持（Pro版本）        |\n| 历史备份 | 不支持           | 支持               |\n\n##### {#_351}使用技巧\n\n1. **选择合适的扫描模式**\n\n   * **安全模式**：只删除与软件直接相关的项目，适合初学者\n   * **适中模式**：扫描范围更广，能删除大部分残留，适合普通用户\n   * **高级模式**：最彻底的扫描，需要一定的技术知识，适合高级用户\n2. **使用Hunter模式**\n\n   * 开启Hunter模式（瞄准镜图标）可以直接瞄准桌面或任务栏上的程序图标进行卸载\n   * 特别适合卸载找不到的小程序或工具栏\n3. **利用安装监控**（Pro版本）\n\n   * 安装新软件前开启安装监控\n   * 记录安装过程中的所有系统变更\n   * 卸载时可以完全恢复到安装前状态\n4. **定期清理注册表**\n\n   * 使用Revo Registry Cleaner功能定期清理注册表\n   * 可以修复损坏的注册表项，提高系统性能\n\nRevo Uninstaller是清理C盘空间的有效工具，尤其适合通过彻底卸载不需要的软件来释放空间。与一般的卸载方式相比，它能够更彻底地清理软件残留，防止C盘被无用文件占用。\n\n选择清理工具时，建议考虑以下因素：\n\n* 清理效果和系统兼容性\n* 操作难易程度\n* 安全性和隐私保护\n* 是否带有额外的优化功能\n\n### {#_381}四、注意事项\n\n在清理C盘时，需要注意以下几点：\n\n1. **备份重要数据**：在进行任何清理操作前，备份重要文件和数据，防止误删\n2. **谨慎删除系统文件**：不要删除不了解的系统文件，特别是Windows目录下的文件\n3. **避免使用\"一键清理\"工具**：除非你确切了解其清理内容，否则不要使用第三方的\"一键清理\"功能\n4. **定期清理**：建立定期清理的习惯，避免垃圾文件长期堆积\n5. **选择合适的软件安装位置**：安装新软件时，尽量选择非C盘的位置\n6. **关注大文件**：优先处理那些占用空间大的文件，如视频、游戏、虚拟机文件等\n7. **不要过度清理缓存**：某些缓存文件有助于提高系统和应用的运行速度，不要过度清理\n\n### {#_393}总结\n\nC盘作为系统盘，其空间状态直接影响计算机的整体性能。通过本文介绍的各种清理技巧，您可以有效释放C盘空间，提升系统运行效率。\n\n定期维护C盘不仅能让电脑运行更顺畅，还能延长硬件寿命。建议养成良好的电脑使用习惯：\n\n* 定期清理临时文件和系统缓存\n* 合理规划文件存储位置\n* 谨慎选择软件安装位置\n* 保持桌面整洁\n* 关注大文件的存储位置\n\n最后，记住一个原则：清理是为了让系统运行得更好，而不仅仅是为了释放空间。在清理的同时，也要保留系统和应用正常运行所需的必要文件。希望这篇文章能帮助您更有效地管理C盘空间，让电脑保持最佳状态！\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/O_____V_____O/article/details/147407998?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-05-21 16:47:40', '2025-05-21 18:06:52');
INSERT INTO `sys_article` VALUES (308, 1, 44, '与终端同居日记：Linux指令の进阶撩拨手册', 'img/与终端同居日记：Linux指令の进阶撩拨手册.png', 'Linux', '<h3><a id=\"_content_views_0\"></a>前情提要： {#content_views}</h3>\n<p>当你和终端的关系从「早安打卡」进阶到「深夜代码同居」，那些曾经高冷的指令开始展露<strong>致命の反差萌</strong>------</p>\n<ul>\n<li>\n<p><strong><code>man</code></strong> 是那个永远在线的钢铁直男说明书，只会说：“想懂我？自己看文档！”（但你不得不承认，他的确随叫随到）</p>\n</li>\n<li>\n<p><strong><code>mv</code></strong> 像极了热衷搬家的前任，能把你的青春回忆从 <code>/home/初恋</code> 一键转移到 <code>/tmp/心碎回收站</code></p>\n</li>\n<li>\n<p><strong><code>nano</code></strong> 是初恋记事本，虽然功能朴素，但总在 <code>Ctrl+X</code> 时温柔问你：“要保存这份心动吗？”</p>\n</li>\n</ul>\n<hr />\n<h4><a id=\"_12\"></a><strong>本季同居守则</strong>：</h4>\n<h5><a id=\"1__14\"></a><strong>1. 暧昧期必杀技：指令界的「情感翻译官」</strong></h5>\n<ul>\n<li>\n<p><strong><code>echo &quot;今晚月色真美&quot; &gt; 告白.txt</code></strong></p>\n<ul>\n<li>直男式浪漫：用重定向符 <code>&gt;</code> 把心跳声写入文本（副作用：覆盖式表白可能引发 <code>IOError: 已读不回</code>）</li>\n</ul>\n</li>\n<li>\n<p><strong><code>cat 日记.log | grep &quot;crush&quot;</code></strong></p>\n<ul>\n<li>在百万行的生活日志里，精准捕捞那个TA出现的瞬间（警告：可能挖出黑历史导致 <code>段错误</code>）</li>\n</ul>\n</li>\n</ul>\n<h5><a id=\"2__24\"></a><strong>2. 危险关系の艺术：文件界的「替身文学」</strong></h5>\n<ul>\n<li>\n<p><strong><code>cp -r 前任/ 新欢/ --小心心备份=all</code></strong></p>\n<ul>\n<li>海王の觉悟：用递归复制保留所有纪念品（但 <code>diff</code> 会无情揭穿：“新欢和前任的md5一模一样！”）</li>\n</ul>\n</li>\n<li>\n<p><strong><code>which python</code></strong></p>\n<ul>\n<li>鉴渣神器：查清那个口口声声说只爱你一人的Python，到底在 <code>/usr/bin</code> 藏了多少个版本备胎</li>\n</ul>\n</li>\n</ul>\n<h5><a id=\"3_PUA_34\"></a><strong>3. 终极灵魂拷问：当指令学会PUA</strong></h5>\n<ul>\n<li>\n<p><strong><code>man 爱情</code></strong></p>\n<ul>\n<li>系统冷冰冰地提示：<code>No manual entry for 爱情</code>（但偷偷用 <code>apropos 心动</code> 能搜到隐藏章节）</li>\n</ul>\n</li>\n<li>\n<p><strong><code>sudo rm -rf 犹豫/</code></strong></p>\n<ul>\n<li>用管理员权限删除所有迟疑（副作用：可能误删 <code>/未来/承诺</code> 目录）</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h4><a id=\"_46\"></a><strong>新手指南：同居必备神器</strong></h4>\n<ul>\n<li>\n<p><strong><code>nano 分手信.txt</code></strong></p>\n<ul>\n<li>用最朴素的编辑器写下最痛的句子（若手抖按了 <code>Ctrl+S</code>，请速用 <code>mv 分手信.txt /dev/null</code> 撤回）</li>\n</ul>\n</li>\n<li>\n<p><strong><code>man 7 恋爱哲学</code></strong></p>\n<ul>\n<li>\n<p>隐藏章节揭示真理：</p>\n<pre><code class=\"lang-\">爱情 ≈ 管道符 |   \n你的输出必须是我的输入  \n但永远不要用 &gt; 覆盖对方的灵魂  \n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr />\n<p><strong>现在，深呼吸</strong> <strong>在终端敲下这封加密情书</strong>：</p>\n<pre><code class=\"lang-\">echo &quot;SSBsb3ZlIHlvdSAK&quot; | base64 -d  \n</code></pre>\n<p><strong>让Linux告诉你------</strong> <strong>有些指令不需要手册，因为心跳的源码早已开源</strong> 💻💓</p>\n<h3><a id=\"1man_72\"></a>1.man指令</h3>\n<h4><a id=\"11manLinux_74\"></a>1.1.man指令是什么：Linux的百科知识全书</h4>\n<p>可能当很多小伙伴看到这个指令名字的时候，脑袋里会浮现出那个男人的身影，并且会想起一个当今比较热门的梗：man！当然，这个指令和这些可是没有任何关系，man指令可以说是一个比较热门的指令，因为我们会在学习Linux的时候多次使用到它，它其实就是一个Linux的知识百科全书。</p>\n<h4><a id=\"12man_78\"></a>1.2.man指令的用法：一看就懂</h4>\n<p>man指令的语法很简单，首先我们想要可以用man指令查man指令的用法，它的语法如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">man man  <span class=\"hljs-comment\">#这样就可以知道man的用法</span>\n</code></div></pre>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/93508a1c424d4aa98df6b7f509d63caf.png\" alt=\"\" /></p>\n<p>这里就可以看到上面显示的man函数的功能，其实它的核心主要是在中间的部分，就是数字对应的部分，每一个数字代表着它所含有的工作，这里小编就给大家搜索了相关的资料，告知各位这些数字代表的含义：</p>\n<table>\n<thead>\n<tr>\n<th>章节号</th>\n<th>内容类型</th>\n<th>示例命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>1</strong></td>\n<td>用户命令（普通用户可执行）</td>\n<td><code>man 1 ls</code></td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td>系统调用</td>\n<td><code>man 2 fork</code></td>\n</tr>\n<tr>\n<td><strong>3</strong></td>\n<td>C 库函数</td>\n<td><code>man 3 malloc</code></td>\n</tr>\n<tr>\n<td><strong>4</strong></td>\n<td>设备文件和特殊文件</td>\n<td><code>man 4 null</code>（/dev/null 设备）</td>\n</tr>\n<tr>\n<td><strong>5</strong></td>\n<td>配置文件格式</td>\n<td><code>man 5 fstab</code></td>\n</tr>\n<tr>\n<td><strong>6</strong></td>\n<td>游戏和屏保程序</td>\n<td><code>man 6 tetris</code></td>\n</tr>\n<tr>\n<td><strong>7</strong></td>\n<td>杂项（协议、文件系统等）</td>\n<td><code>man 7 tcp</code></td>\n</tr>\n<tr>\n<td><strong>8</strong></td>\n<td>系统管理命令（需 root 权限）</td>\n<td><code>man 8 iptables</code></td>\n</tr>\n<tr>\n<td><strong>9</strong></td>\n<td>内核相关文档</td>\n<td><code>man 9 syscalls</code></td>\n</tr>\n</tbody>\n</table>\n<p>上面就是对于man函数的使用，各位读者以后遇到函数不会用的问题，完全可以通过man函数来帮助我们相关函数的查找，而不用再去一些平台找相关的解释了。</p>\n<h4><a id=\"13man_104\"></a>1.3.man指令可能出现的错误</h4>\n<p>在我们使用man函数的时候，我们可能想要使用man 3 printf的指令，可能部分读者无法使用这个功能，这是因为部分云服务器删减了不少内容，这个手册相关的内容也进行了删除（因为保证功能太多而浪费掉），所以可以用下面这个指令把这个手册下回来：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">yum install -y man-pages  <span class=\"hljs-comment\">#这样就可以使用3的功能了</span>\n</code></div></pre>\n<h3><a id=\"2echo_112\"></a>2.echo指令</h3>\n<h4><a id=\"1echoLinux__114\"></a>1.echo：Linux 界的「复读机」，但比鹦鹉靠谱！</h4>\n<p>echo指令实际上算是Linux中最没有&quot;存在感&quot;但确实常常被使用的指令了，因为它的功能实际上是很简单的，它的名字听起来像在说：「欸，我在呢！」（Echo：回音），但它的真实身份其实是<strong>命令行界的复读机</strong> 。它的任务很简单：<strong>你喂它什么，它就吐什么</strong>。但别小看它！这货可是隐藏了无数骚操作的宝藏工具（就比如之后让我难受好几天的重定向操作）。</p>\n<h4><a id=\"2echohello_world_118\"></a>2.echo的用法：比&quot;hello world&quot;还简单</h4>\n<p>它的用法很经典，如果你给它说：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;我是以后的技术大佬！&quot;</span> <span class=\"hljs-comment\">#这个引号可以不加，纯纯的写C++习惯了，看到个字符串默认&quot;&quot;</span>\n</code></div></pre>\n<p>它给你回：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/0219ea482ffd42ce9a01d4d8664a8856.png\" alt=\"\" /></p>\n<h4><a id=\"3echo___130\"></a>3.高级玩法：echo の 魔法时刻</h4>\n<p><strong>1. 自带弹幕特效（颜色和格式）</strong></p>\n<p>想让终端输出五彩斑斓的黑？加个「魔法参数」<code>-e</code> 就能解锁转义符！</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">&quot;\\033[31m红色警告：\\033[0m 你的咖啡已空！&quot;</span>\n</code></div></pre>\n<p>效果：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/28c50c31f4bd42a5a4fa8db6f8737595.png\" alt=\"\" /></p>\n<hr />\n<p><strong>2. 制造混乱（生成奇葩文件）</strong></p>\n<p>想快速创建一个文件并写入内容？</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;老板说要写周报，但我觉得他在画饼&quot;</span> &gt; weekly_report.txt\n</code></div></pre>\n<p>（<code>&gt;</code> 表示把输出<strong>重定向</strong>到文件，相当于让 echo 当秘书帮你写文档。关于重定向，我以后会详细说说这玩意，难度还是不小的，在大约我讲到文件的部分时，我会进行一个重定向代码的书写）</p>\n<hr />\n<p><strong>3. 哲学の质问（输出变量）</strong></p>\n<p>Linux 有很多自带「人生哲理」变量，比如 <code>$USER</code>（你是谁）、<code>$HOME</code>（你家在哪）：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;你是 <span class=\"hljs-variable\">$USER</span>，此刻正躲在 <span class=\"hljs-variable\">$HOME</span> 里摸鱼。&quot;</span> <span class=\"hljs-comment\">#这些其实就是后来我会讲的环境变量</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">你是 alice，此刻正躲在 /home/alice 里摸鱼。\n</code></div></pre>\n<p>（扎心了，echo。）</p>\n<hr />\n<p><strong>4. 无声胜有声（不换行输出）</strong></p>\n<p>默认 <code>echo</code> 会在结尾加个换行符，像个礼貌的客服。但如果你想当个「叛逆青年」，用 <code>-n</code> 参数让它闭嘴：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">&quot;正在加载......&quot;</span>\n<span class=\"hljs-built_in\">sleep</span> 2\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;加载了个寂寞！&quot;</span>\n</code></div></pre>\n<p>效果：两句话会连在一起，假装在加载（实则摸鱼）。</p>\n<hr />\n<h5><a id=\"echo__188\"></a><strong>echo 的冷知识</strong></h5>\n<ul>\n<li>\n<p><strong>「我到底说了啥？」</strong> 如果输入 <code>echo *</code>，它会列出当前目录所有文件（因为 <code>*</code> 被 Shell 先解析了）。 如果想原样输出 <code>*</code>，请用单引号：<code>echo \'*\'</code>（单引号是「封印」，防止 Shell 搞事）。</p>\n</li>\n<li>\n<p><strong>「Windows 用户别学我！」</strong> Windows 的 <code>echo</code> 是另一个物种，比如 <code>echo %PATH%</code>，但功能远不如 Linux 的优雅。（手动狗头）</p>\n</li>\n</ul>\n<hr />\n<h5><a id=\"echo__196\"></a><strong>总结：echo 的「人生信条」</strong></h5>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;人生苦短，我用 echo。&quot;</span>\n</code></div></pre>\n<p>简单、直接、不废话------这就是 <code>echo</code> 的极客哲学。下次写脚本时，记得让这个「复读机」帮你喊话、写文件、甚至假装在工作！（老板看不到的，放心。）</p>\n<h3><a id=\"3cat_204\"></a>3.cat指令</h3>\n<h4><a id=\"31catLinux__206\"></a>3.1.cat：Linux 界的「文件魔术师」，但比你家猫还好奇！</h4>\n<p>它的全名是 <code>concatenate</code>（拼接），但别被这名字吓到，它其实是<strong>文件界的瑞士军刀</strong> 。任务就一条：<strong>把文件内容「喵」给你看</strong>！但它不仅能看文件，还能玩拼接、装高冷、甚至倒放人生…（误）</p>\n<h4><a id=\"32_210\"></a>3.2.基础用法：喵星人的偷窥欲</h4>\n<p>如果你对它说：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cat</span> 日记.txt  <span class=\"hljs-comment\">#假设文件里面有内容</span>\n</code></div></pre>\n<p>它会立刻把文件内容摊在屏幕上：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">2023年10月1日：今天学会了用<span class=\"hljs-built_in\">cat</span>，感觉自己像个黑客！\n</code></div></pre>\n<h4><a id=\"33cat___224\"></a>3.3.高级玩法：cat の 九条命</h4>\n<h5><a id=\"1_226\"></a>1.合并文件的魔法（文件拼接）</h5>\n<p>想合并两个文件？<code>cat</code> 表示：「给我两片小鱼干（文件），还你一条大鱼！」</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">2023年10月1日：今天学会了用<span class=\"hljs-built_in\">cat</span>，感觉自己像个黑客！\n</code></div></pre>\n<p>（<code>&gt;</code> 表示把合并结果存到新文件，建议别轻易尝试合并「前半生」和「后半生」，容易引发哲学危机。）</p>\n<h5><a id=\"2_236\"></a>2.高冷模式（显示行号）</h5>\n<p>想让 <code>cat</code> 装高冷学霸？加 <code>-n</code> 参数，连行号都给你标好！</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cat</span> -n 代码.c\n</code></div></pre>\n<p>输出：</p>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;摸鱼.h&gt;</span>  <span class=\"hljs-comment\">//开个玩笑的~头文件要好好的写哦~</span></span>\n<span class=\"hljs-number\">2</span>  <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n<span class=\"hljs-number\">3</span>      <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;世界你好，但我不想动！&quot;</span>);\n<span class=\"hljs-number\">4</span>  }\n</code></div></pre>\n<p>（行号暴露了你代码里的摸鱼痕迹…）</p>\n<h5><a id=\"3_255\"></a>3.倒放人生（反向输出）</h5>\n<p>哦不，是反向输出！用 <code>tac</code>（cat 倒过来）指令：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">tac</span> 日记.txt\n</code></div></pre>\n<p>输出：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">2023年10月1日：今天学会了用<span class=\"hljs-built_in\">cat</span>，感觉自己像个黑客！\n</code></div></pre>\n<p>看起来没变化？因为这日记只有一行…建议写长点再试！）</p>\n<h5><a id=\"4_271\"></a>4.无中生有（快速创建文件）</h5>\n<p>懒人必备！用 <code>cat</code> 直接键盘输入内容：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cat</span> &gt; 紧急备忘录.txt &lt;&lt; <span class=\"hljs-string\">EOF\n1. 买咖啡\n2. 假装在工作\n3. 用cat查看老板的日程（划掉）\nEOF</span>\n</code></div></pre>\n<p>（按 <code>Ctrl+D</code> 保存，深藏功与名。）</p>\n<h5><a id=\"cat__285\"></a><strong>cat 的冷知识</strong></h5>\n<ul>\n<li>\n<p><strong>「别拿我当铲屎官！」</strong> 用 <code>cat</code> 查看超大文件（比如日志）时，它会一口气全吐出来，屏幕直接滚成瀑布！【所以我一般不推荐使用cat指令查看大型的文件，不然有你好果汁吃，嘻嘻~】 此时请用 <code>less</code> 或 <code>more</code> 指令，比如 <code>less 巨型日志.log</code>（猫表示：「我累了，换人！」）。【本来想讲这部分的，但我偷个懒，就不写了】</p>\n</li>\n<li>\n<p><strong>「我和狗（dog）有什么关系？」</strong> 有人觉得 <code>cat</code> 不够酷，于是写了 <code>dog</code> 指令（彩色输出+语法高亮），但记住：<strong>狗是猫的加强版，但猫才是原配！</strong>【原配抵不过天降，总觉着哪里不对】</p>\n</li>\n<li>\n<p><strong>「我是管道工的好朋友！」</strong> <code>cat</code> 常和其他指令「勾搭」干活，比如：</p>\n<pre><code class=\"lang-\">cat 日志.log | grep &quot;error&quot;  # 过滤所有报错（摸鱼时快速甩锅用）\n</code></pre>\n</li>\n</ul>\n<h4><a id=\"cat__297\"></a><strong>总结：cat 的「喵生信条」</strong></h4>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cat</span> &lt;&lt; <span class=\"hljs-string\">EOF\n猫有九条命，\ncat 有九种用法。\n------ 但第九种通常是老板没教你的那个！\nEOF</span>\n</code></div></pre>\n<p>简单、灵活、好奇心爆棚------这就是 <code>cat</code> 的极客精神。下次遇到文件时，记得召唤这只「好奇猫」，但别让它看到你的浏览器历史记录！（手动狗头）</p>\n<h3><a id=\"4cp_309\"></a>4.cp指令</h3>\n<h4><a id=\"41cpLinux__311\"></a>4.1.cp：Linux 界的「文件快递员」，但比搬家小哥更怕丢件！</h4>\n<p><code> cp</code>，全称 <code>copy</code>（复制），它的任务看似简单------<strong>把文件从A地搬到B地</strong>，但这位「文件快递员」的职业生涯充满了血泪史：</p>\n<ul>\n<li>\n<p><strong>搞丢文件？</strong> 当场失业！</p>\n</li>\n<li>\n<p><strong>覆盖文件？</strong> 用户暴走！</p>\n</li>\n<li>\n<p><strong>忘记参数？</strong> 直接emo…</p>\n</li>\n</ul>\n<p>但别慌，学会以下技巧，你就是它的金牌老板！</p>\n<h4><a id=\"42Ctrl_323\"></a>4.2.基础用法：复制粘贴，但不用Ctrl键</h4>\n<p>如果你对 <code>cp</code> 说：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cp</span> 老板的废话.txt 我的脑子/    <span class=\"hljs-comment\">#要复制的文件到指定的目录下，此时就要结合之前学的目录相关的知识(＾Ｕ＾)ノ~ＹＯ</span>\n</code></div></pre>\n<p>它会默默把文件复制到指定目录，深藏功与名：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">我的脑子/  \n  └── 老板的废话.txt  \n</code></div></pre>\n<p>（但请注意：你的脑子可能会选择性拒绝接收该文件！）</p>\n<h4><a id=\"43cp___340\"></a>4.3.<strong>高级玩法：cp の 反卷指南</strong></h4>\n<h5><a id=\"1_342\"></a>1.<strong>暴力搬家（覆盖文件不提醒）</strong></h5>\n<p>默认 <code>cp</code> 会静默覆盖同名文件，像极了半夜偷偷改代码的你：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cp</span> 摸鱼攻略.txt 工作日报.txt  <span class=\"hljs-comment\"># 危险动作，请勿模仿！  这样可能会酿成大错哦~~</span>\n</code></div></pre>\n<p>（第二天：老板：「你的日报为什么写着『如何伪装编译错误』？」）</p>\n<h5><a id=\"2_352\"></a>2.求生欲模式（覆盖前询问）</h5>\n<p>怕手滑？加 <code>-i</code> 参数让 <code>cp</code> 变成「纠结狂魔」：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cp</span> -i 旧简历.txt 新简历.txt  \n</code></div></pre>\n<p>输出：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cp</span>: overwrite <span class=\"hljs-string\">&#x27;新简历.txt&#x27;</span>? （你丫想好了再按！）  \n</code></div></pre>\n<p>（此时建议输入 <code>n</code> 并火速删除旧简历中的「精通一切」字样。）</p>\n<h5><a id=\"3_368\"></a>3.抄家式复制（递归复制文件夹）</h5>\n<p>想复制整个文件夹？加 <code>-r</code> 参数，让 <code>cp</code> 化身「抄家大队长」：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cp</span> -r 我的黑历史/ 备份硬盘/  <span class=\"hljs-comment\"># 建议加密后再操作  ，就比如后面我会讲述的文件以及目录的权限</span>\n</code></div></pre>\n<p>（注：<code>-r</code> 表示递归，适用于文件夹。如果失败，可能是你的黑历史太重了…）</p>\n<h5><a id=\"4or_378\"></a>4.强制式复制（强行复制文件or目录）</h5>\n<p>想要强制复制整个文件夹？加 <code>-f</code> 参数，让 <code>cp</code> 化身「强拆大队长」:</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cp</span> -f 我的白历史/ 公司公共资源/  <span class=\"hljs-comment\">#建议自信后才这么做，不然文件是第一天发的，班是第二天辞的~</span>\n</code></div></pre>\n<h5><a id=\"5_386\"></a>5.戏精附体（显示复制的详情）</h5>\n<p>加 <code>-v</code> 参数，让 <code>cp</code> 实时播报搬家进度：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cp</span> -v 猫片.jpg 狗片.jpg /表情包/  \n</code></div></pre>\n<p>输出：</p>\n<pre><code class=\"lang-\">\'猫片.jpg\' -&gt; \'/表情包/猫片.jpg\'  \n\'狗片.jpg\' -&gt; \'/表情包/狗片.jpg\'  \n</code></pre>\n<p>（仿佛听到 <code>cp</code> 在喊：「搬完啦！求打赏小鱼干！」）</p>\n<h4><a id=\"44cp__403\"></a>4.4.<strong>cp 的冷知识</strong></h4>\n<ul>\n<li>\n<p><strong>「我是时间管理大师！」</strong></p>\n<p>用 <code>-u</code> 参数，只有源文件<strong>比目标新</strong>时才复制：</p>\n<pre><code class=\"lang-\">cp -u 我的努力.txt 老板的眼里/  # 如果老板没发现，就不更新！  \n</code></pre>\n</li>\n<li>\n<p><strong>「我比Ctrl+C更正经！」</strong></p>\n<p><code>cp</code> 会保留文件权限和修改时间（除非用 <code>-p</code> 参数故意不保留）。 而 Windows 的复制？呵，连权限都能搞丢。（再次手动狗头）</p>\n</li>\n<li>\n<p><strong>「毁灭性操作：复制到黑洞」</strong></p>\n<p>永远别尝试 <code>cp * ~/</code>（复制所有文件到家目录），除非你想体验「文件雪崩」的绝望！</p>\n</li>\n</ul>\n<h4><a id=\"cp___420\"></a><strong>总结：cp の 生存法则</strong></h4>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">cp</span> -i 勇气 智商 经验  <span class=\"hljs-comment\"># 覆盖人生前请三思！  </span>\n</code></div></pre>\n<p>快、准、狠------这是 <code>cp</code> 的职业素养，但请记住：<strong>「比猫咪打翻水杯更可怕的，是手滑的 <code>cp</code> 指令！」</strong></p>\n<h3><a id=\"5mv_428\"></a>5.mv指令</h3>\n<h4><a id=\"51mvLinux__430\"></a>5.1.<strong>mv：Linux 界的「文件忍者」，但比魔术师更会玩消失！</strong></h4>\n<p><code> mv</code>，全称 <code>move</code>（移动），它看似是个「搬家工人」，实则是<strong>文件界的变形金刚</strong> ------能移动、能重命名，甚至能「偷天换日」覆盖文件！但小心，它的座右铭是：<strong>「我搬过的文件，连原址都不敢回忆！」</strong></p>\n<h4><a id=\"52_434\"></a>5.2.基础用法：文件瞬移术</h4>\n<h5><a id=\"1_436\"></a>1.普通搬家（移动文件）</h5>\n<p>如果你对 <code>mv</code> 说：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">mv</span> 摸鱼计划.txt 老板看不见的角落/  \n</code></div></pre>\n<p>它会瞬间把文件挪走，仿佛从未存在过：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">老板看不见的角落/  \n  └── 摸鱼计划.txt  \n</code></div></pre>\n<p>（注：老板的视力通常与该文件夹的路径成反比。）</p>\n<h5><a id=\"2_453\"></a>2.原地变身（重命名文件）</h5>\n<p>想让文件「换马甲」？直接给新名字就行！</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">mv</span> 离职申请.txt 年度奋进计划.txt  <span class=\"hljs-comment\"># 职场生存必备技能  </span>\n</code></div></pre>\n<p>（第二天：老板：「这份计划书怎么透着一股悲壮的气息？」）</p>\n<h4><a id=\"53mv___463\"></a>5.3.<strong>高级玩法：mv の 暗黑艺术</strong></h4>\n<h5><a id=\"1_465\"></a>1.静默覆盖（危险の美学）</h5>\n<p>默认 <code>mv</code> 会直接覆盖同名文件，像极了删你代码还没 <code>git commit</code> 的同事：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">mv</span> 新数据.csv 旧数据.csv  <span class=\"hljs-comment\"># 旧数据：我当时害怕极了......  </span>\n</code></div></pre>\n<p>（后果：你可能需要连夜跑路。）</p>\n<h5><a id=\"2_475\"></a>2.求生模式（覆盖前询问）</h5>\n<p>加 <code>-i</code> 参数，让 <code>mv</code> 变成「碎碎念狂魔」：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">mv</span> -i 我的黑历史.zip 云备份/  \n</code></div></pre>\n<p>输出：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">mv</span>: overwrite <span class=\"hljs-string\">&#x27;云备份/我的黑历史.zip&#x27;</span>? （你确定云盘不会泄露吗？）  \n</code></div></pre>\n<p>（建议：输入 <code>n</code>，然后买个硬盘埋后院。）</p>\n<h5><a id=\"3_491\"></a>3.暴力搬家公司（移动整个文件夹）</h5>\n<p>和 <code>cp</code> 不同，<code>mv</code> 搬文件夹<strong>不用加参数</strong>，直接干！（有一次有人问我mv指令需不需要用-rf，我还傻呵呵的给他说必须用，结果他用了半天没用出来，最后还是我复习了之前的知识才想起来这件事）</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">mv</span> 陈年旧代码/ 回收站/  <span class=\"hljs-comment\"># 表面风轻云淡，内心慌得一批  </span>\n</code></div></pre>\n<p>（注：如果 <code>回收站/</code> 不存在，<code>陈年旧代码/</code> 会改名为 <code>回收站</code>…建议提前买保险。）</p>\n<h5><a id=\"4_501\"></a>4.戏精模式（显示搬运动作）</h5>\n<p>加 <code>-v</code> 参数，让 <code>mv</code> 实时播报：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">mv</span> -v 老板的丑照.jpg 加密保险箱/  \n</code></div></pre>\n<p>输出：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-string\">&#x27;老板的丑照.jpg&#x27;</span> -&gt; <span class=\"hljs-string\">&#x27;加密保险箱/老板的丑照.jpg&#x27;</span>  \n</code></div></pre>\n<p>（仿佛听到 <code>mv</code> 说：「已安全转移，人质…啊不，文件平安！」）</p>\n<h4><a id=\"54mv_517\"></a>5.4.mv的冷知识</h4>\n<ul>\n<li>\n<p><strong>「我和 cp 是塑料兄弟！」</strong> <code>mv</code> 的真相：如果目标在<strong>同一磁盘</strong> ，它只是改个路径（瞬间完成）； 如果跨磁盘，它其实是「复制+删除」，慢得像在搬砖！（此时不如直接用 <code>cp</code>）</p>\n</li>\n<li>\n<p><strong>「我比删除键更可怕！」</strong> 用 <code>mv</code> 把文件移到不存在的路径，文件会直接「被改名」：</p>\n<pre><code class=\"lang-\">mv 重要文件.txt /不存在的路径/  # 文件会改名为「不存在的路径」……祝你好运！  \n</code></pre>\n</li>\n<li>\n<p><strong>「我能让文件『社死』！」</strong> 用 <code>mv</code> 隐藏文件（加前缀 <code>.</code>）：</p>\n<pre><code class=\"lang-\">mv 摸鱼笔记.txt .摸鱼笔记.txt  # 现在只有 `ls -a` 能看见它了，或者是\'la\'选项才可以看见哦~  \n</code></pre>\n<p>（适用于「假装在工作」高级玩家。）</p>\n</li>\n</ul>\n<h4><a id=\"55mv_535\"></a>5.5.总结：mvの忍者信条</h4>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">mv</span> 过去 未来  <span class=\"hljs-comment\"># 过去的错误，就扔到未来的回收站吧！  </span>\n</code></div></pre>\n<p>快、准、狠------这是 <code>mv</code> 的职业修养，但请记住：<strong>「比误删文件更惨的，是手滑把文件 mv 进了黑洞！」</strong></p>\n<h3><a id=\"6whichfindwhereis_543\"></a>6.which，find，whereis指令</h3>\n<h4><a id=\"61whichLinux__PATH__545\"></a>6.1.<strong>which：Linux 界的「路痴导航员」，但只会指路 PATH 里的店！</strong></h4>\n<p>which，纯纯的就是一个选择性的路痴：它的任务很简单：<strong>告诉你某个命令到底藏在哪个犄角旮旃</strong> 。但有个毛病：<strong>只认 <code>PATH</code> 环境变量里的路径</strong>（环境变量是我后来会讲述的内容），其他地方的命令？它表示：「看不见，下一个！」</p>\n<h5><a id=\"1_549\"></a>1.基础用法：找命令的「藏身之处」</h5>\n<p>如果你问它：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">which</span> python  \n</code></div></pre>\n<p>它会回答：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">/usr/bin/python  <span class=\"hljs-comment\"># 「在这呢！但你是不是装了 10 个版本？」  </span>\n</code></div></pre>\n<p>（注：如果找不到，它会沉默得像被老板抓包的你。）</p>\n<h5><a id=\"2_565\"></a>2.冷知识：</h5>\n<ul>\n<li>\n<p><strong>「我拒绝搜索你的私人小仓库！」</strong> 如果你自己写了脚本放在 <code>~/bin</code> 但没加到 <code>PATH</code>，<code>which</code> 会直接装瞎：</p>\n<pre><code class=\"lang-\">which 我的摸鱼脚本.sh  # 输出：空气  \n</code></pre>\n</li>\n<li>\n<p><strong>「我和 Windows 的 where 是远房亲戚！」</strong> Windows 的 <code>where</code> 命令类似，但 Linux 的 <code>which</code> 更傲娇。</p>\n</li>\n</ul>\n<h4><a id=\"62whereisLinux__575\"></a>6.2.<strong>whereis：Linux 界的「文件八卦记者」，但只爆料系统知道的事！</strong></h4>\n<p>这位比 <code>which</code> 更八卦------<strong>不仅能找命令，还能挖出它的源码、手册页</strong> ！但缺点是：<strong>只搜系统预设的目录</strong> （比如 <code>/bin</code>, <code>/usr/share/man</code>），其他地方它不关心！</p>\n<h5><a id=\"1__579\"></a>1.基础用法：查命令的「 全家桶」</h5>\n<p>如果你问：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">whereis <span class=\"hljs-built_in\">ls</span>\n</code></div></pre>\n<p>它会甩出一堆信息：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">ls</span>: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz\n</code></div></pre>\n<h5><a id=\"2_593\"></a>2.冷知识：</h5>\n<ul>\n<li>\n<p><strong>「你的自定义命令？我不熟！」</strong> 和 <code>which</code> 一样，非系统目录的命令它直接无视。</p>\n</li>\n<li>\n<p><strong>「源码？可能被我吃掉了！」</strong> 有些命令安装时没带源码，<code>whereis</code> 会假装无事发生。</p>\n</li>\n</ul>\n<h4><a id=\"63findLinux__CPU__599\"></a>6.3.<strong>find：Linux 界的「文件福尔摩斯」，但查案时能把你 CPU 跑炸！</strong></h4>\n<p>真正的搜索大佬！<strong>能按名字、大小、时间、权限…甚至文件内容</strong> 满硬盘搜！但代价是：<strong>语法复杂得像侦探小说</strong>，一不小心就搜出 10 万个临时文件！</p>\n<h5><a id=\"1_603\"></a>1.<strong>基础用法：按名字搜文件</strong></h5>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">find / -name <span class=\"hljs-string\">&quot;摸鱼证据.txt&quot;</span>  <span class=\"hljs-comment\"># 从根目录开始搜，但建议加降压药 ，这里就不出事结果了，因为我目前的CPU正在高速运转~ </span>\n</code></div></pre>\n<p>（后果：硬盘狂转，风扇起飞，CPU 大喊：「我要摸鱼！」）</p>\n<h5><a id=\"2_611\"></a>2.<strong>高级玩法：</strong></h5>\n<ol>\n<li></li>\n</ol>\n<h6><a id=\"_615\"></a><strong>按大小抓「胖子文件」</strong></h6>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">find ~ -size +100M  <span class=\"hljs-comment\"># 找出你硬盘里的「隐藏巨婴」  </span>\n</code></div></pre>\n<p>（输出：<code>~/电影/未看完的1080p学习资料.mp4</code>）<br />\n2.</p>\n<h6><a id=\"_624\"></a><strong>按时间抓「旧爱」</strong></h6>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">find /tmp -mtime +30  <span class=\"hljs-comment\"># 找出 30 天没碰过的临时文件（早该分手了！）  </span>\n</code></div></pre>\n<ol start=\"3\">\n<li>\n<p><strong>「找到后，顺便干点啥」</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">find . -name <span class=\"hljs-string\">&quot;*.log&quot;</span> -<span class=\"hljs-built_in\">exec</span> <span class=\"hljs-built_in\">rm</span> {} \\;  <span class=\"hljs-comment\"># 删除所有日志（谨慎！别删库跑路！）  </span>\n</code></div></pre>\n<p>（<code>-exec</code> 表示让 <code>find</code> 兼职杀手，<code>{}</code> 是文件占位符，<code>\\;</code> 是固定结尾）</p>\n</li>\n</ol>\n<h5><a id=\"3_638\"></a>3.冷知识：</h5>\n<ul>\n<li>\n<p><strong>「我比 Windows 搜索强 100 倍，但用户怕我！」</strong> Windows 用户搜文件靠点击，Linux 用户靠 <code>find</code> 加咖啡因。</p>\n</li>\n<li>\n<p><strong>「别让我搜 /dev，那里全是鬼！」</strong> <code>/dev</code> 是设备文件，用 <code>find</code> 搜它可能触发玄学 Bug。</p>\n</li>\n</ul>\n<h4><a id=\"64_644\"></a>6.4.<strong>总结：三巨头的「职场定位」</strong></h4>\n<ul>\n<li>\n<p><strong><code>which</code></strong>：「我就一路人甲，只认识城里的店！」</p>\n</li>\n<li>\n<p><strong><code>whereis</code></strong>：「我八卦，但只爆系统的料！」</p>\n</li>\n<li>\n<p><strong><code>find</code></strong>：「给我一个硬盘，我能搜到宇宙尽头！」</p>\n</li>\n</ul>\n<h4><a id=\"65_652\"></a>6.5.灵魂拷问</h4>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-built_in\">which</span> whereis  <span class=\"hljs-comment\"># 输出：whereis 在 /usr/bin/whereis  </span>\nwhereis find   <span class=\"hljs-comment\"># 输出：find 在 /usr/bin/find 和它的手册页  </span>\nfind / -name <span class=\"hljs-string\">&quot;人生意义&quot;</span>  <span class=\"hljs-comment\"># 输出：无（建议重启人类试试）  </span>\n</code></div></pre>\n<h3><a id=\"7grep_660\"></a>7.grep指令</h3>\n<h4><a id=\"71grepLinux__662\"></a>7.1.<strong>grep：Linux 界的「文字侦探」，但比柯南更爱找茬！</strong></h4>\n<p><code> grep</code>，全称 <strong>Global Regular Expression Print</strong> （全局正则表达式打印），江湖人称**「键盘界的Ctrl+F」** ，但比浏览器搜索硬核100倍------它能用<strong>正则表达式</strong>在文件大海里精准捞针，甚至能边捞边喊：「真相只有一个！」</p>\n<h4><a id=\"72_666\"></a>7.2.基础用法：字里行间的「捉迷藏」</h4>\n<h5><a id=\"1_668\"></a>1.普通搜索（按关键词抓人）</h5>\n<p>如果你对 <code>grep</code> 说：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">grep <span class=\"hljs-string\">&quot;error&quot;</span> 日志.txt  <span class=\"hljs-comment\"># 在日志里搜所有「error」  </span>\n</code></div></pre>\n<p>它会立刻高亮显示所有匹配行：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">ERROR 2023: 程序员因咖啡不足崩溃。  \nerror 404: 智商未找到。  \n</code></div></pre>\n<p>（注：大小写敏感是它的傲娇设定，<code>Error</code> 和 <code>error</code> 是两码事！）</p>\n<h5><a id=\"2_685\"></a>2.全员逮捕（统计匹配次数）</h5>\n<p>加 <code>-c</code> 参数，直接告诉你抓了多少「嫌疑人」：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">grep -c <span class=\"hljs-string\">&quot;摸鱼&quot;</span> 工作日报.txt  <span class=\"hljs-comment\"># 输出：42  </span>\n</code></div></pre>\n<p>（老板：你一天摸42次鱼？鱼塘都被你摸秃了！）</p>\n<h4><a id=\"73grep___695\"></a>7.3.高级玩法：grep の 刑侦手段</h4>\n<h5><a id=\"1_697\"></a>1.忽略大小写（大小通吃）</h5>\n<p>用 <code>-i</code> 参数，让 <code>grep</code> 变成「脸盲侦探」：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">grep -i <span class=\"hljs-string\">&quot;warning&quot;</span> 系统日志.txt  <span class=\"hljs-comment\"># 连「WaRnInG」都逃不过！  </span>\n</code></div></pre>\n<p>（适合抓那些喜欢伪装成「WARNING」的严重错误。）</p>\n<h5><a id=\"2_707\"></a>2.反向逮捕（排除法）</h5>\n<p>加 <code>-v</code> 参数，专门<strong>排除</strong>符合条件的内容：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">grep -v <span class=\"hljs-string\">&quot;TODO&quot;</span> 代码.py  <span class=\"hljs-comment\"># 只看正经代码，假装TODO不存在  </span>\n</code></div></pre>\n<p>（输出：一片空白------原来你根本没写代码！）</p>\n<h5><a id=\"3_717\"></a>3.地毯式搜索（递归搜索目录）</h5>\n<p>用 <code>-r</code> 参数，让 <code>grep</code> 化身「文件挖掘机」：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">grep -r <span class=\"hljs-string\">&quot;密码&quot;</span> ~/项目  <span class=\"hljs-comment\"># 搜索家目录下所有文件中的「密码」  </span>\n</code></div></pre>\n<p>（后果：可能发现你把数据库密码写在 <code>test.txt</code> 里…）</p>\n<h5><a id=\"4_727\"></a>4.带行号招供（显示行号）</h5>\n<p>加 <code>-n</code> 参数，让匹配行「自曝坐标」：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">grep -n <span class=\"hljs-string\">&quot;BUG&quot;</span> 代码.c  \n</code></div></pre>\n<p>输出：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">42: <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;这里有个BUG，但我不想修！&quot;</span>);  \n</code></div></pre>\n<p>（第42行：程序员の经典摆烂现场。）</p>\n<h5><a id=\"5_743\"></a>5.查案带上下文（显示前后内容）</h5>\n<p>用 <code>-C</code> 参数（比如 <code>-C 2</code>），展示案发现场的前后2行：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">grep -C 2 <span class=\"hljs-string\">&quot;崩溃&quot;</span> 日志.txt  \n</code></div></pre>\n<p>输出：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[时间] 尝试拯救世界...  \n[时间] 系统崩溃！  \n[时间] 程序员开始砸键盘。  \n</code></div></pre>\n<p>（破案了：崩溃原因是键盘质量太差！）</p>\n<h4><a id=\"74grep_761\"></a>7.4.grep的冷知识</h4>\n<ul>\n<li>\n<p><strong>「我和正则表达式是CP！」</strong> <code>grep</code> 的终极技能是<strong>正则表达式</strong>，比如：</p>\n<pre><code class=\"lang-\">grep &quot;^[A-Z]&quot; 文件.txt  # 抓所有以大写字母开头的行（适合找嚣张的错误）  \n</code></pre>\n<p>（注：<code>^</code> 表示行首，<code>[A-Z]</code> 表示大写字母，学废了吗？）</p>\n</li>\n<li>\n<p><strong>「我比猫（cat）更懂文件！」</strong> 常和 <code>cat</code> 勾搭干活，比如：</p>\n<pre><code class=\"lang-\">cat 日志.txt | grep &quot;error&quot;  # 先让猫吐文件，再让grep抓重点  \n</code></pre>\n<p>（但其实可以省掉 <code>cat</code>：<code>grep &quot;error&quot; 日志.txt</code>）</p>\n</li>\n<li>\n<p><strong>「我有个花里胡哨的亲戚------<code>egrep</code> 和 <code>fgrep</code>！」</strong></p>\n<ul>\n<li>\n<p><code>egrep</code>：支持<strong>扩展正则表达式</strong> （比如 <code>+</code>, <code>?</code> 不用转义）。</p>\n</li>\n<li>\n<p><code>fgrep</code>：<strong>固定字符串搜索</strong>（速度更快，适合没正则的情况）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4><a id=\"grep___783\"></a><strong>总结：grep の 侦探守则</strong></h4>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">grep <span class=\"hljs-string\">&quot;智慧&quot;</span> 大脑内存.txt  <span class=\"hljs-comment\"># 输出：查无此词！  </span>\n</code></div></pre>\n<p>快、准、狠------这是 <code>grep</code> 的破案哲学，但请记住：<strong>「比找不到关键词更可怕的，是grep到了老板的敏感词！」</strong></p>\n<h3><a id=\"8_791\"></a>8.总结</h3>\n<p>今天的博客之旅到这里也就结束了，今天讲述了不少的指令，希望各位读者之后会好好的复习这些代码，不然我就会用mv指令快速移动到你身边然后rm你哦~好了，不闹着玩了，指令的记忆不是靠死记硬背，而是靠每天的练习，这样会让自己的记忆变的更加深刻，今天的同居日记已结束，各位朋友们下次见啦！</p>\n<p>是<img src=\"https://i-blog.csdnimg.cn/direct/5fffc8c9f89347c285cc436f23e13ca0.jpeg\" alt=\"\" /></p>\n', '### 前情提要： {#content_views}\n\n当你和终端的关系从「早安打卡」进阶到「深夜代码同居」，那些曾经高冷的指令开始展露**致命の反差萌**------\n\n* **`man`** 是那个永远在线的钢铁直男说明书，只会说：\"想懂我？自己看文档！\"（但你不得不承认，他的确随叫随到）\n\n* **`mv`** 像极了热衷搬家的前任，能把你的青春回忆从 `/home/初恋` 一键转移到 `/tmp/心碎回收站`\n\n* **`nano`** 是初恋记事本，虽然功能朴素，但总在 `Ctrl+X` 时温柔问你：\"要保存这份心动吗？\"\n\n*** ** * ** ***\n\n#### **本季同居守则**：\n\n##### **1. 暧昧期必杀技：指令界的「情感翻译官」**\n\n* **`echo \"今晚月色真美\" > 告白.txt`**\n\n  * 直男式浪漫：用重定向符 `>` 把心跳声写入文本（副作用：覆盖式表白可能引发 `IOError: 已读不回`）\n\n* **`cat 日记.log | grep \"crush\"`**\n\n  * 在百万行的生活日志里，精准捕捞那个TA出现的瞬间（警告：可能挖出黑历史导致 `段错误`）\n\n##### **2. 危险关系の艺术：文件界的「替身文学」**\n\n* **`cp -r 前任/ 新欢/ --小心心备份=all`**\n\n  * 海王の觉悟：用递归复制保留所有纪念品（但 `diff` 会无情揭穿：\"新欢和前任的md5一模一样！\"）\n\n* **`which python`**\n\n  * 鉴渣神器：查清那个口口声声说只爱你一人的Python，到底在 `/usr/bin` 藏了多少个版本备胎\n\n##### **3. 终极灵魂拷问：当指令学会PUA**\n\n* **`man 爱情`**\n\n  * 系统冷冰冰地提示：`No manual entry for 爱情`（但偷偷用 `apropos 心动` 能搜到隐藏章节）\n\n* **`sudo rm -rf 犹豫/`**\n\n  * 用管理员权限删除所有迟疑（副作用：可能误删 `/未来/承诺` 目录）\n\n*** ** * ** ***\n\n#### **新手指南：同居必备神器**\n\n* **`nano 分手信.txt`**\n\n  * 用最朴素的编辑器写下最痛的句子（若手抖按了 `Ctrl+S`，请速用 `mv 分手信.txt /dev/null` 撤回）\n\n* **`man 7 恋爱哲学`**\n\n  * 隐藏章节揭示真理：\n\n    ```\n    爱情 ≈ 管道符 |   \n    你的输出必须是我的输入  \n    但永远不要用 > 覆盖对方的灵魂  \n    ```\n\n*** ** * ** ***\n\n**现在，深呼吸** **在终端敲下这封加密情书**：\n\n```\necho \"SSBsb3ZlIHlvdSAK\" | base64 -d  \n```\n\n**让Linux告诉你------** **有些指令不需要手册，因为心跳的源码早已开源** 💻💓\n\n### 1.man指令\n\n#### 1.1.man指令是什么：Linux的百科知识全书\n\n可能当很多小伙伴看到这个指令名字的时候，脑袋里会浮现出那个男人的身影，并且会想起一个当今比较热门的梗：man！当然，这个指令和这些可是没有任何关系，man指令可以说是一个比较热门的指令，因为我们会在学习Linux的时候多次使用到它，它其实就是一个Linux的知识百科全书。\n\n#### 1.2.man指令的用法：一看就懂\n\nman指令的语法很简单，首先我们想要可以用man指令查man指令的用法，它的语法如下：\n\n```bash\nman man  #这样就可以知道man的用法\n```\n\n![](https://i-blog.csdnimg.cn/direct/93508a1c424d4aa98df6b7f509d63caf.png)\n\n这里就可以看到上面显示的man函数的功能，其实它的核心主要是在中间的部分，就是数字对应的部分，每一个数字代表着它所含有的工作，这里小编就给大家搜索了相关的资料，告知各位这些数字代表的含义：\n\n|  章节号  |       内容类型        |            示例命令            |\n|-------|-------------------|----------------------------|\n| **1** | 用户命令（普通用户可执行）     | `man 1 ls`                 |\n| **2** | 系统调用              | `man 2 fork`               |\n| **3** | C 库函数             | `man 3 malloc`             |\n| **4** | 设备文件和特殊文件         | `man 4 null`（/dev/null 设备） |\n| **5** | 配置文件格式            | `man 5 fstab`              |\n| **6** | 游戏和屏保程序           | `man 6 tetris`             |\n| **7** | 杂项（协议、文件系统等）      | `man 7 tcp`                |\n| **8** | 系统管理命令（需 root 权限） | `man 8 iptables`           |\n| **9** | 内核相关文档            | `man 9 syscalls`           |\n\n上面就是对于man函数的使用，各位读者以后遇到函数不会用的问题，完全可以通过man函数来帮助我们相关函数的查找，而不用再去一些平台找相关的解释了。\n\n#### 1.3.man指令可能出现的错误\n\n在我们使用man函数的时候，我们可能想要使用man 3 printf的指令，可能部分读者无法使用这个功能，这是因为部分云服务器删减了不少内容，这个手册相关的内容也进行了删除（因为保证功能太多而浪费掉），所以可以用下面这个指令把这个手册下回来：\n\n```bash\nyum install -y man-pages  #这样就可以使用3的功能了\n```\n\n### 2.echo指令\n\n#### 1.echo：Linux 界的「复读机」，但比鹦鹉靠谱！\n\necho指令实际上算是Linux中最没有\"存在感\"但确实常常被使用的指令了，因为它的功能实际上是很简单的，它的名字听起来像在说：「欸，我在呢！」（Echo：回音），但它的真实身份其实是**命令行界的复读机** 。它的任务很简单：**你喂它什么，它就吐什么**。但别小看它！这货可是隐藏了无数骚操作的宝藏工具（就比如之后让我难受好几天的重定向操作）。\n\n#### 2.echo的用法：比\"hello world\"还简单\n\n它的用法很经典，如果你给它说：\n\n```bash\necho \"我是以后的技术大佬！\" #这个引号可以不加，纯纯的写C++习惯了，看到个字符串默认\"\"\n```\n\n它给你回：\n\n![](https://i-blog.csdnimg.cn/direct/0219ea482ffd42ce9a01d4d8664a8856.png)\n\n#### 3.高级玩法：echo の 魔法时刻\n\n**1. 自带弹幕特效（颜色和格式）**\n\n想让终端输出五彩斑斓的黑？加个「魔法参数」`-e` 就能解锁转义符！\n\n```bash\necho -e \"\\033[31m红色警告：\\033[0m 你的咖啡已空！\"\n```\n\n效果：\n\n![](https://i-blog.csdnimg.cn/direct/28c50c31f4bd42a5a4fa8db6f8737595.png)\n\n*** ** * ** ***\n\n**2. 制造混乱（生成奇葩文件）**\n\n想快速创建一个文件并写入内容？\n\n```bash\necho \"老板说要写周报，但我觉得他在画饼\" > weekly_report.txt\n```\n\n（`>` 表示把输出**重定向**到文件，相当于让 echo 当秘书帮你写文档。关于重定向，我以后会详细说说这玩意，难度还是不小的，在大约我讲到文件的部分时，我会进行一个重定向代码的书写）\n\n*** ** * ** ***\n\n**3. 哲学の质问（输出变量）**\n\nLinux 有很多自带「人生哲理」变量，比如 `$USER`（你是谁）、`$HOME`（你家在哪）：\n\n```bash\necho \"你是 $USER，此刻正躲在 $HOME 里摸鱼。\" #这些其实就是后来我会讲的环境变量\n```\n\n```bash\n你是 alice，此刻正躲在 /home/alice 里摸鱼。\n```\n\n（扎心了，echo。）\n\n*** ** * ** ***\n\n**4. 无声胜有声（不换行输出）**\n\n默认 `echo` 会在结尾加个换行符，像个礼貌的客服。但如果你想当个「叛逆青年」，用 `-n` 参数让它闭嘴：\n\n```bash\necho -n \"正在加载......\"\nsleep 2\necho \"加载了个寂寞！\"\n```\n\n效果：两句话会连在一起，假装在加载（实则摸鱼）。\n\n*** ** * ** ***\n\n##### **echo 的冷知识**\n\n* **「我到底说了啥？」** 如果输入 `echo *`，它会列出当前目录所有文件（因为 `*` 被 Shell 先解析了）。 如果想原样输出 `*`，请用单引号：`echo \'*\'`（单引号是「封印」，防止 Shell 搞事）。\n\n* **「Windows 用户别学我！」** Windows 的 `echo` 是另一个物种，比如 `echo %PATH%`，但功能远不如 Linux 的优雅。（手动狗头）\n\n*** ** * ** ***\n\n##### **总结：echo 的「人生信条」**\n\n```bash\necho \"人生苦短，我用 echo。\"\n```\n\n简单、直接、不废话------这就是 `echo` 的极客哲学。下次写脚本时，记得让这个「复读机」帮你喊话、写文件、甚至假装在工作！（老板看不到的，放心。）\n\n### 3.cat指令\n\n#### 3.1.cat：Linux 界的「文件魔术师」，但比你家猫还好奇！\n\n它的全名是 `concatenate`（拼接），但别被这名字吓到，它其实是**文件界的瑞士军刀** 。任务就一条：**把文件内容「喵」给你看**！但它不仅能看文件，还能玩拼接、装高冷、甚至倒放人生......（误）\n\n#### 3.2.基础用法：喵星人的偷窥欲\n\n如果你对它说：\n\n```bash\ncat 日记.txt  #假设文件里面有内容\n```\n\n它会立刻把文件内容摊在屏幕上：\n\n```bash\n2023年10月1日：今天学会了用cat，感觉自己像个黑客！\n```\n\n#### 3.3.高级玩法：cat の 九条命\n\n##### 1.合并文件的魔法（文件拼接）\n\n想合并两个文件？`cat` 表示：「给我两片小鱼干（文件），还你一条大鱼！」\n\n```bash\n2023年10月1日：今天学会了用cat，感觉自己像个黑客！\n```\n\n（`>` 表示把合并结果存到新文件，建议别轻易尝试合并「前半生」和「后半生」，容易引发哲学危机。）\n\n##### 2.高冷模式（显示行号）\n\n想让 `cat` 装高冷学霸？加 `-n` 参数，连行号都给你标好！\n\n```bash\ncat -n 代码.c\n```\n\n输出：\n\n```cpp\n1  #include <摸鱼.h>  //开个玩笑的~头文件要好好的写哦~\n2  int main() {\n3      printf(\"世界你好，但我不想动！\");\n4  }\n```\n\n（行号暴露了你代码里的摸鱼痕迹......）\n\n##### 3.倒放人生（反向输出）\n\n哦不，是反向输出！用 `tac`（cat 倒过来）指令：\n\n```bash\ntac 日记.txt\n```\n\n输出：\n\n```bash\n2023年10月1日：今天学会了用cat，感觉自己像个黑客！\n```\n\n看起来没变化？因为这日记只有一行......建议写长点再试！）\n\n##### 4.无中生有（快速创建文件）\n\n懒人必备！用 `cat` 直接键盘输入内容：\n\n```bash\ncat > 紧急备忘录.txt << EOF\n1. 买咖啡\n2. 假装在工作\n3. 用cat查看老板的日程（划掉）\nEOF\n```\n\n（按 `Ctrl+D` 保存，深藏功与名。）\n\n##### **cat 的冷知识**\n\n* **「别拿我当铲屎官！」** 用 `cat` 查看超大文件（比如日志）时，它会一口气全吐出来，屏幕直接滚成瀑布！【所以我一般不推荐使用cat指令查看大型的文件，不然有你好果汁吃，嘻嘻\\~】 此时请用 `less` 或 `more` 指令，比如 `less 巨型日志.log`（猫表示：「我累了，换人！」）。【本来想讲这部分的，但我偷个懒，就不写了】\n\n* **「我和狗（dog）有什么关系？」** 有人觉得 `cat` 不够酷，于是写了 `dog` 指令（彩色输出+语法高亮），但记住：**狗是猫的加强版，但猫才是原配！**【原配抵不过天降，总觉着哪里不对】\n\n* **「我是管道工的好朋友！」** `cat` 常和其他指令「勾搭」干活，比如：\n\n  ```\n  cat 日志.log | grep \"error\"  # 过滤所有报错（摸鱼时快速甩锅用）\n  ```\n\n#### **总结：cat 的「喵生信条」**\n\n```bash\ncat << EOF\n猫有九条命，\ncat 有九种用法。\n------ 但第九种通常是老板没教你的那个！\nEOF\n```\n\n简单、灵活、好奇心爆棚------这就是 `cat` 的极客精神。下次遇到文件时，记得召唤这只「好奇猫」，但别让它看到你的浏览器历史记录！（手动狗头）\n\n### 4.cp指令\n\n#### 4.1.cp：Linux 界的「文件快递员」，但比搬家小哥更怕丢件！\n\n` cp`，全称 `copy`（复制），它的任务看似简单------**把文件从A地搬到B地**，但这位「文件快递员」的职业生涯充满了血泪史：\n\n* **搞丢文件？** 当场失业！\n\n* **覆盖文件？** 用户暴走！\n\n* **忘记参数？** 直接emo......\n\n但别慌，学会以下技巧，你就是它的金牌老板！\n\n#### 4.2.基础用法：复制粘贴，但不用Ctrl键\n\n如果你对 `cp` 说：\n\n```bash\ncp 老板的废话.txt 我的脑子/    #要复制的文件到指定的目录下，此时就要结合之前学的目录相关的知识(＾Ｕ＾)ノ~ＹＯ\n```\n\n它会默默把文件复制到指定目录，深藏功与名：\n\n```bash\n我的脑子/  \n  └── 老板的废话.txt  \n```\n\n（但请注意：你的脑子可能会选择性拒绝接收该文件！）\n\n#### 4.3.**高级玩法：cp の 反卷指南**\n\n##### 1.**暴力搬家（覆盖文件不提醒）**\n\n默认 `cp` 会静默覆盖同名文件，像极了半夜偷偷改代码的你：\n\n```bash\ncp 摸鱼攻略.txt 工作日报.txt  # 危险动作，请勿模仿！  这样可能会酿成大错哦~~\n```\n\n（第二天：老板：「你的日报为什么写着『如何伪装编译错误』？」）\n\n##### 2.求生欲模式（覆盖前询问）\n\n怕手滑？加 `-i` 参数让 `cp` 变成「纠结狂魔」：\n\n```bash\ncp -i 旧简历.txt 新简历.txt  \n```\n\n输出：\n\n```bash\ncp: overwrite \'新简历.txt\'? （你丫想好了再按！）  \n```\n\n（此时建议输入 `n` 并火速删除旧简历中的「精通一切」字样。）\n\n##### 3.抄家式复制（递归复制文件夹）\n\n想复制整个文件夹？加 `-r` 参数，让 `cp` 化身「抄家大队长」：\n\n```bash\ncp -r 我的黑历史/ 备份硬盘/  # 建议加密后再操作  ，就比如后面我会讲述的文件以及目录的权限\n```\n\n（注：`-r` 表示递归，适用于文件夹。如果失败，可能是你的黑历史太重了......）\n\n##### 4.强制式复制（强行复制文件or目录）\n\n想要强制复制整个文件夹？加 `-f` 参数，让 `cp` 化身「强拆大队长」:\n\n```bash\ncp -f 我的白历史/ 公司公共资源/  #建议自信后才这么做，不然文件是第一天发的，班是第二天辞的~\n```\n\n##### 5.戏精附体（显示复制的详情）\n\n加 `-v` 参数，让 `cp` 实时播报搬家进度：\n\n```bash\ncp -v 猫片.jpg 狗片.jpg /表情包/  \n```\n\n输出：\n\n```\n\'猫片.jpg\' -> \'/表情包/猫片.jpg\'  \n\'狗片.jpg\' -> \'/表情包/狗片.jpg\'  \n```\n\n（仿佛听到 `cp` 在喊：「搬完啦！求打赏小鱼干！」）\n\n#### 4.4.**cp 的冷知识**\n\n* **「我是时间管理大师！」**\n\n  用 `-u` 参数，只有源文件**比目标新**时才复制：\n\n  ```\n  cp -u 我的努力.txt 老板的眼里/  # 如果老板没发现，就不更新！  \n  ```\n\n* **「我比Ctrl+C更正经！」**\n\n  `cp` 会保留文件权限和修改时间（除非用 `-p` 参数故意不保留）。 而 Windows 的复制？呵，连权限都能搞丢。（再次手动狗头）\n* **「毁灭性操作：复制到黑洞」**\n\n  永远别尝试 `cp * ~/`（复制所有文件到家目录），除非你想体验「文件雪崩」的绝望！\n\n#### **总结：cp の 生存法则**\n\n```bash\ncp -i 勇气 智商 经验  # 覆盖人生前请三思！  \n```\n\n快、准、狠------这是 `cp` 的职业素养，但请记住：**「比猫咪打翻水杯更可怕的，是手滑的 `cp` 指令！」**\n\n### 5.mv指令\n\n#### 5.1.**mv：Linux 界的「文件忍者」，但比魔术师更会玩消失！**\n\n` mv`，全称 `move`（移动），它看似是个「搬家工人」，实则是**文件界的变形金刚** ------能移动、能重命名，甚至能「偷天换日」覆盖文件！但小心，它的座右铭是：**「我搬过的文件，连原址都不敢回忆！」**\n\n#### 5.2.基础用法：文件瞬移术\n\n##### 1.普通搬家（移动文件）\n\n如果你对 `mv` 说：\n\n```bash\nmv 摸鱼计划.txt 老板看不见的角落/  \n```\n\n它会瞬间把文件挪走，仿佛从未存在过：\n\n```bash\n老板看不见的角落/  \n  └── 摸鱼计划.txt  \n```\n\n（注：老板的视力通常与该文件夹的路径成反比。）\n\n##### 2.原地变身（重命名文件）\n\n想让文件「换马甲」？直接给新名字就行！\n\n```bash\nmv 离职申请.txt 年度奋进计划.txt  # 职场生存必备技能  \n```\n\n（第二天：老板：「这份计划书怎么透着一股悲壮的气息？」）\n\n#### 5.3.**高级玩法：mv の 暗黑艺术**\n\n##### 1.静默覆盖（危险の美学）\n\n默认 `mv` 会直接覆盖同名文件，像极了删你代码还没 `git commit` 的同事：\n\n```bash\nmv 新数据.csv 旧数据.csv  # 旧数据：我当时害怕极了......  \n```\n\n（后果：你可能需要连夜跑路。）\n\n##### 2.求生模式（覆盖前询问）\n\n加 `-i` 参数，让 `mv` 变成「碎碎念狂魔」：\n\n```bash\nmv -i 我的黑历史.zip 云备份/  \n```\n\n输出：\n\n```bash\nmv: overwrite \'云备份/我的黑历史.zip\'? （你确定云盘不会泄露吗？）  \n```\n\n（建议：输入 `n`，然后买个硬盘埋后院。）\n\n##### 3.暴力搬家公司（移动整个文件夹）\n\n和 `cp` 不同，`mv` 搬文件夹**不用加参数**，直接干！（有一次有人问我mv指令需不需要用-rf，我还傻呵呵的给他说必须用，结果他用了半天没用出来，最后还是我复习了之前的知识才想起来这件事）\n\n```bash\nmv 陈年旧代码/ 回收站/  # 表面风轻云淡，内心慌得一批  \n```\n\n（注：如果 `回收站/` 不存在，`陈年旧代码/` 会改名为 `回收站`......建议提前买保险。）\n\n##### 4.戏精模式（显示搬运动作）\n\n加 `-v` 参数，让 `mv` 实时播报：\n\n```bash\nmv -v 老板的丑照.jpg 加密保险箱/  \n```\n\n输出：\n\n```bash\n\'老板的丑照.jpg\' -> \'加密保险箱/老板的丑照.jpg\'  \n```\n\n（仿佛听到 `mv` 说：「已安全转移，人质......啊不，文件平安！」）\n\n#### 5.4.mv的冷知识\n\n* **「我和 cp 是塑料兄弟！」** `mv` 的真相：如果目标在**同一磁盘** ，它只是改个路径（瞬间完成）； 如果跨磁盘，它其实是「复制+删除」，慢得像在搬砖！（此时不如直接用 `cp`）\n\n* **「我比删除键更可怕！」** 用 `mv` 把文件移到不存在的路径，文件会直接「被改名」：\n\n  ```\n  mv 重要文件.txt /不存在的路径/  # 文件会改名为「不存在的路径」……祝你好运！  \n  ```\n\n* **「我能让文件『社死』！」** 用 `mv` 隐藏文件（加前缀 `.`）：\n\n  ```\n  mv 摸鱼笔记.txt .摸鱼笔记.txt  # 现在只有 `ls -a` 能看见它了，或者是\'la\'选项才可以看见哦~  \n  ```\n\n  （适用于「假装在工作」高级玩家。）\n\n#### 5.5.总结：mvの忍者信条\n\n```bash\nmv 过去 未来  # 过去的错误，就扔到未来的回收站吧！  \n```\n\n快、准、狠------这是 `mv` 的职业修养，但请记住：**「比误删文件更惨的，是手滑把文件 mv 进了黑洞！」**\n\n### 6.which，find，whereis指令\n\n#### 6.1.**which：Linux 界的「路痴导航员」，但只会指路 PATH 里的店！**\n\nwhich，纯纯的就是一个选择性的路痴：它的任务很简单：**告诉你某个命令到底藏在哪个犄角旮旃** 。但有个毛病：**只认 `PATH` 环境变量里的路径**（环境变量是我后来会讲述的内容），其他地方的命令？它表示：「看不见，下一个！」\n\n##### 1.基础用法：找命令的「藏身之处」\n\n如果你问它：\n\n```bash\nwhich python  \n```\n\n它会回答：\n\n```bash\n/usr/bin/python  # 「在这呢！但你是不是装了 10 个版本？」  \n```\n\n（注：如果找不到，它会沉默得像被老板抓包的你。）\n\n##### 2.冷知识：\n\n* **「我拒绝搜索你的私人小仓库！」** 如果你自己写了脚本放在 `~/bin` 但没加到 `PATH`，`which` 会直接装瞎：\n\n  ```\n  which 我的摸鱼脚本.sh  # 输出：空气  \n  ```\n\n* **「我和 Windows 的 where 是远房亲戚！」** Windows 的 `where` 命令类似，但 Linux 的 `which` 更傲娇。\n\n#### 6.2.**whereis：Linux 界的「文件八卦记者」，但只爆料系统知道的事！**\n\n这位比 `which` 更八卦------**不仅能找命令，还能挖出它的源码、手册页** ！但缺点是：**只搜系统预设的目录** （比如 `/bin`, `/usr/share/man`），其他地方它不关心！\n\n##### 1.基础用法：查命令的「 全家桶」\n\n如果你问：\n\n```bash\nwhereis ls\n```\n\n它会甩出一堆信息：\n\n```bash\nls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz\n```\n\n##### 2.冷知识：\n\n* **「你的自定义命令？我不熟！」** 和 `which` 一样，非系统目录的命令它直接无视。\n\n* **「源码？可能被我吃掉了！」** 有些命令安装时没带源码，`whereis` 会假装无事发生。\n\n#### 6.3.**find：Linux 界的「文件福尔摩斯」，但查案时能把你 CPU 跑炸！**\n\n真正的搜索大佬！**能按名字、大小、时间、权限......甚至文件内容** 满硬盘搜！但代价是：**语法复杂得像侦探小说**，一不小心就搜出 10 万个临时文件！\n\n##### 1.**基础用法：按名字搜文件**\n\n```bash\nfind / -name \"摸鱼证据.txt\"  # 从根目录开始搜，但建议加降压药 ，这里就不出事结果了，因为我目前的CPU正在高速运转~ \n```\n\n（后果：硬盘狂转，风扇起飞，CPU 大喊：「我要摸鱼！」）\n\n##### 2.**高级玩法：**\n\n1.\n\n   ###### **按大小抓「胖子文件」**\n\n   ```bash\n   find ~ -size +100M  # 找出你硬盘里的「隐藏巨婴」  \n   ```\n\n   （输出：`~/电影/未看完的1080p学习资料.mp4`）\n2.\n\n   ###### **按时间抓「旧爱」**\n\n   ```bash\n   find /tmp -mtime +30  # 找出 30 天没碰过的临时文件（早该分手了！）  \n   ```\n\n3. **「找到后，顺便干点啥」**\n\n   ```bash\n   find . -name \"*.log\" -exec rm {} \\;  # 删除所有日志（谨慎！别删库跑路！）  \n   ```\n\n   （`-exec` 表示让 `find` 兼职杀手，`{}` 是文件占位符，`\\;` 是固定结尾）\n\n##### 3.冷知识：\n\n* **「我比 Windows 搜索强 100 倍，但用户怕我！」** Windows 用户搜文件靠点击，Linux 用户靠 `find` 加咖啡因。\n\n* **「别让我搜 /dev，那里全是鬼！」** `/dev` 是设备文件，用 `find` 搜它可能触发玄学 Bug。\n\n#### 6.4.**总结：三巨头的「职场定位」**\n\n* **`which`**：「我就一路人甲，只认识城里的店！」\n\n* **`whereis`**：「我八卦，但只爆系统的料！」\n\n* **`find`**：「给我一个硬盘，我能搜到宇宙尽头！」\n\n#### 6.5.灵魂拷问\n\n```bash\nwhich whereis  # 输出：whereis 在 /usr/bin/whereis  \nwhereis find   # 输出：find 在 /usr/bin/find 和它的手册页  \nfind / -name \"人生意义\"  # 输出：无（建议重启人类试试）  \n```\n\n### 7.grep指令\n\n#### 7.1.**grep：Linux 界的「文字侦探」，但比柯南更爱找茬！**\n\n` grep`，全称 **Global Regular Expression Print** （全局正则表达式打印），江湖人称**「键盘界的Ctrl+F」** ，但比浏览器搜索硬核100倍------它能用**正则表达式**在文件大海里精准捞针，甚至能边捞边喊：「真相只有一个！」\n\n#### 7.2.基础用法：字里行间的「捉迷藏」\n\n##### 1.普通搜索（按关键词抓人）\n\n如果你对 `grep` 说：\n\n```bash\ngrep \"error\" 日志.txt  # 在日志里搜所有「error」  \n```\n\n它会立刻高亮显示所有匹配行：\n\n```bash\nERROR 2023: 程序员因咖啡不足崩溃。  \nerror 404: 智商未找到。  \n```\n\n（注：大小写敏感是它的傲娇设定，`Error` 和 `error` 是两码事！）\n\n##### 2.全员逮捕（统计匹配次数）\n\n加 `-c` 参数，直接告诉你抓了多少「嫌疑人」：\n\n```bash\ngrep -c \"摸鱼\" 工作日报.txt  # 输出：42  \n```\n\n（老板：你一天摸42次鱼？鱼塘都被你摸秃了！）\n\n#### 7.3.高级玩法：grep の 刑侦手段\n\n##### 1.忽略大小写（大小通吃）\n\n用 `-i` 参数，让 `grep` 变成「脸盲侦探」：\n\n```bash\ngrep -i \"warning\" 系统日志.txt  # 连「WaRnInG」都逃不过！  \n```\n\n（适合抓那些喜欢伪装成「WARNING」的严重错误。）\n\n##### 2.反向逮捕（排除法）\n\n加 `-v` 参数，专门**排除**符合条件的内容：\n\n```bash\ngrep -v \"TODO\" 代码.py  # 只看正经代码，假装TODO不存在  \n```\n\n（输出：一片空白------原来你根本没写代码！）\n\n##### 3.地毯式搜索（递归搜索目录）\n\n用 `-r` 参数，让 `grep` 化身「文件挖掘机」：\n\n```bash\ngrep -r \"密码\" ~/项目  # 搜索家目录下所有文件中的「密码」  \n```\n\n（后果：可能发现你把数据库密码写在 `test.txt` 里......）\n\n##### 4.带行号招供（显示行号）\n\n加 `-n` 参数，让匹配行「自曝坐标」：\n\n```bash\ngrep -n \"BUG\" 代码.c  \n```\n\n输出：\n\n```bash\n42: printf(\"这里有个BUG，但我不想修！\");  \n```\n\n（第42行：程序员の经典摆烂现场。）\n\n##### 5.查案带上下文（显示前后内容）\n\n用 `-C` 参数（比如 `-C 2`），展示案发现场的前后2行：\n\n```bash\ngrep -C 2 \"崩溃\" 日志.txt  \n```\n\n输出：\n\n```bash\n[时间] 尝试拯救世界...  \n[时间] 系统崩溃！  \n[时间] 程序员开始砸键盘。  \n```\n\n（破案了：崩溃原因是键盘质量太差！）\n\n#### 7.4.grep的冷知识\n\n* **「我和正则表达式是CP！」** `grep` 的终极技能是**正则表达式**，比如：\n\n  ```\n  grep \"^[A-Z]\" 文件.txt  # 抓所有以大写字母开头的行（适合找嚣张的错误）  \n  ```\n\n  （注：`^` 表示行首，`[A-Z]` 表示大写字母，学废了吗？）\n* **「我比猫（cat）更懂文件！」** 常和 `cat` 勾搭干活，比如：\n\n  ```\n  cat 日志.txt | grep \"error\"  # 先让猫吐文件，再让grep抓重点  \n  ```\n\n  （但其实可以省掉 `cat`：`grep \"error\" 日志.txt`）\n* **「我有个花里胡哨的亲戚------`egrep` 和 `fgrep`！」**\n\n  * `egrep`：支持**扩展正则表达式** （比如 `+`, `?` 不用转义）。\n\n  * `fgrep`：**固定字符串搜索**（速度更快，适合没正则的情况）。\n\n#### **总结：grep の 侦探守则**\n\n```bash\ngrep \"智慧\" 大脑内存.txt  # 输出：查无此词！  \n```\n\n快、准、狠------这是 `grep` 的破案哲学，但请记住：**「比找不到关键词更可怕的，是grep到了老板的敏感词！」**\n\n### 8.总结\n\n今天的博客之旅到这里也就结束了，今天讲述了不少的指令，希望各位读者之后会好好的复习这些代码，不然我就会用mv指令快速移动到你身边然后rm你哦\\~好了，不闹着玩了，指令的记忆不是靠死记硬背，而是靠每天的练习，这样会让自己的记忆变的更加深刻，今天的同居日记已结束，各位朋友们下次见啦！\n\n是![](https://i-blog.csdnimg.cn/direct/5fffc8c9f89347c285cc436f23e13ca0.jpeg)\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/effort123_/article/details/147338970?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-05-23 16:50:28', '2025-05-23 17:32:16');
INSERT INTO `sys_article` VALUES (309, 1, 40, '常用控件 【多元素类 | 容器类 | 布局类】', 'img/常用控件 【多元素类  容器类  布局类】.png', '常用控件 【多元素类 | 容器类 | 布局类】', '<p>🌈 <strong>个人主页：<a href=\"https://blog.csdn.net/weixin_50776420?type=blog\" target=\"_blank\">Zfox_</a></strong><br />\n🔥 <strong>系列专栏：<a href=\"https://blog.csdn.net/weixin_50776420/category_12894253.html?spm=1001.2014.3001.5482\" target=\"_blank\">Qt</a></strong></p>\n<br />\n<h4><a id=\"_8\"></a>目录</h4>\n<ul>\n<li><a href=\"#font_colorDarkOrchid__QT__font_8\">一：🔥 QT 常用控件【多元素类】</a></li>\n<li>\n<ul>\n<li><a href=\"#_List_Widget___32\">🦋 List Widget – 列表</a></li>\n<li><a href=\"#_Table_Widget___110\">🦋 Table Widget – 表格</a></li>\n<li><a href=\"#_Tree_Widget___191\">🦋 Tree Widget – 树形</a></li>\n</ul>\n</li>\n<li><a href=\"#font_colorDarkOrchid_QT__font_273\">二：🔥 QT 常用控件【容器类】</a></li>\n<li>\n<ul>\n<li><a href=\"#_Group_Box___275\">🦋 Group Box – 分组框</a></li>\n<li><a href=\"#_Tab_Widget___301\">🦋 Tab Widget – 标签页</a></li>\n</ul>\n</li>\n<li><a href=\"#font_colorDarkOrchid_QT__font_364\">三：🔥 QT 常用控件【布局类】</a></li>\n<li>\n<ul>\n<li><a href=\"#__376\">🦋 垂直布局</a></li>\n<li>\n<ul>\n<li><a href=\"#__QVBoxLayout__390\">🎀 【使用 QVBoxLayout 管理多个控件】</a></li>\n<li><a href=\"#__QVBoxLayout_404\">🎀 【创建两个 QVBoxLayout】</a></li>\n</ul>\n</li>\n<li><a href=\"#__429\">🦋 水平布局</a></li>\n<li>\n<ul>\n<li><a href=\"#_QHBoxLayout__443\">🎀【使用 QHBoxLayout 管理控件】</a></li>\n<li><a href=\"#_layout_456\">🎀【嵌套的 layout】</a></li>\n</ul>\n</li>\n<li><a href=\"#__466\">🦋 网格布局</a></li>\n<li>\n<ul>\n<li><a href=\"#__QGridLayout__487\">🎀 【使用 QGridLayout 管理元素】</a></li>\n<li><a href=\"#__QGridLayout__504\">🎀 【设置 QGridLayout 中元素的大小比例】</a></li>\n<li><a href=\"#__519\">🎀 【设置垂直方向的拉伸系数】</a></li>\n</ul>\n</li>\n<li><a href=\"#__547\">🦋 表单布局</a></li>\n<li><a href=\"#_Space_565\">🦋 Space</a></li>\n</ul>\n</li>\n<li><a href=\"#font_colorDarkOrchid__font_592\">四：🔥 共勉</a></li>\n</ul>\n<br />\n<h2><a id=\"_QT__40\"></a>一：🔥 QT 常用控件【多元素类】</h2>\n<p>🚇 Qt 中提供的<strong>多元素控件</strong>有：</p>\n<ul>\n<li>QListWidget</li>\n<li>QListView</li>\n<li>QTableWidget</li>\n<li>QTableView</li>\n<li>QTreeWidget</li>\n<li>QTreeView</li>\n</ul>\n<p><strong>xxWidget 和 xxView 之间的区别</strong></p>\n<p>以 QTableWidget 和 QTableView 为例</p>\n<p>QTableView 是基于 MVC 设计的控件</p>\n<ul>\n<li>\n<p>MVC：M(model) 数据，V(view) 界面，C(controller)控制器 数据和视图之间的业务流程</p>\n</li>\n<li>\n<p>QTableView 自身不持有数据，使用 QTableView 的时候需要用户创建一个 Model 对象（比如 QStandardModel），并且把 Model 和 QTableView 关联起来。</p>\n</li>\n<li>\n<p>后续修改 Model 中的数据就会影响 QTableView 的显示，修改 QTableView 的显示也会影响到 Model 中的数据（双向绑定）。</p>\n</li>\n</ul>\n<p><code>QTableWidget</code> 是 <code>QTableView</code> 的子类，对 <code>QTableView</code> 进行了扩展，将 Model 进行了封装，不需要用户手动创建 Model 对象，直接就可以往 <code>QTableWidget</code> 中添加数据了。</p>\n<h3><a id=\"_List_Widget___32_List_Widget___66\"></a>{#_List_Widget___32}🦋 List Widget – 列表</h3>\n<p>使用 QListWidget 能够显示一个纵向的列表组件。形如：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/f58876ab6bf6d22fd3452ef02e344132.png\" alt=\"image-20250120154630270\" /></p>\n<table>\n<thead>\n<tr>\n<th>核心属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>currentRow</td>\n<td>当前被选中的是第几行</td>\n</tr>\n<tr>\n<td>count</td>\n<td>一共有多少行</td>\n</tr>\n<tr>\n<td>sortingEnabled</td>\n<td>是否允许排序</td>\n</tr>\n<tr>\n<td>isWrapping</td>\n<td>是否允许换行</td>\n</tr>\n<tr>\n<td>itemAlignment</td>\n<td>元素的对齐方式</td>\n</tr>\n<tr>\n<td>selectRectVisible</td>\n<td>被选中的元素矩形是否可见</td>\n</tr>\n<tr>\n<td>spacing</td>\n<td>元素之间的间隔</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>核心方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>addItem(const QString&amp; label) addItem(QListWidgetItem *item)</td>\n<td>列表中添加元素</td>\n</tr>\n<tr>\n<td>currentItem()</td>\n<td>返回 <code>QListWidgetItem*</code> 表示当前选中的元素</td>\n</tr>\n<tr>\n<td>setCurrentItem(QListWidgetItem* item)</td>\n<td>设置选中哪个元素</td>\n</tr>\n<tr>\n<td>setCurrentRow(int row)</td>\n<td>设置选中第几行的元素</td>\n</tr>\n<tr>\n<td>insertItem(const QString&amp; label, int row) insertItem(QListWidgetItem *item, int row)</td>\n<td>在指定的位置插入元素</td>\n</tr>\n<tr>\n<td>item(int row)</td>\n<td>返回 <code>QListWidgetItem*</code> 表示第 <code>row</code> 行的元素</td>\n</tr>\n<tr>\n<td>takeItem(int row)</td>\n<td><strong>删除</strong> 指定行的元素, 返回 <code>QListWidgetItem*</code> 表示是哪个元素被删除了</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>核心信号</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>currentItemChanged(QListWidgetItem* current, QListWidgetItem* old)</td>\n<td>选中不同元素时会触发. 参数是当前选中的元素和之前选中的元素</td>\n</tr>\n<tr>\n<td>currentRowChanged(int)</td>\n<td>选中不同元素时会触发. 参数是当前选中元素的行数</td>\n</tr>\n<tr>\n<td>itemClicked(QListWidgetItem* item)</td>\n<td>点击某个元素时触发</td>\n</tr>\n<tr>\n<td>itemDoubleClicked(QListWidgetItem* item)</td>\n<td>双击某个元素时触发</td>\n</tr>\n<tr>\n<td>itemEntered(QListWidgetItem* item)</td>\n<td>鼠标进入元素时触发</td>\n</tr>\n</tbody>\n</table>\n<p>在上述介绍中涉及到⼀个关键的类：<strong>QListWidgetItem</strong> ，这个类表示 <code>QListWidget</code> 中的一个元素。核心方法如下，本质上就是⼀个 “文本+图标” 构成的</p>\n<ul>\n<li>setFont: 设置字体</li>\n<li>setIcon: 设置图标</li>\n<li>setHidden: 设置隐藏</li>\n<li>setSizeHint: 设置尺寸</li>\n<li>setSelected: 设置是否选中</li>\n<li>setText: 设置文本</li>\n<li>setTextAlignment: 设置文本对齐方式</li>\n</ul>\n<p>这些方法允许我们自定义 Q List Widget Item 的外观和行为。</p>\n<p>通过结合使用 QListWidget 的属性、方法和信号，以及 <code>QListWidgetItem</code> 的方法，可以创建高度定制化的列表控件。</p>\n<p>使用 ListWidget</p>\n<p>（1）在界面上创建一个 ListView，右键 =&gt; 变形为 =&gt; ListWidget，再创建一个 lineEdit 和两个按钮</p>\n<p>注意：</p>\n<ul>\n<li>ListWidget 是 ListView 的子类，功能比 ListView 更丰富。</li>\n<li>我们使用 ListWidget 即可。</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/8e51a24ecf705e8e06d27af930066196.png\" alt=\"image-20250120162804519\" /></p>\n<p>（2）编写 widget.cpp，在构造函数中添加初始元素 或者 直接在图形化界面选择 “编辑项目”，编写 listWidget 的 slot 函数，然后编写按钮的 slot 函数</p>\n<ul>\n<li>此处编写 listWidget 的 slot 函数：需要判定 current 和 previous 非空，初始情况下是没有元素选中的，就导致这两个指针可能是 NULL。</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/0485f980e2f132b8b6df5e05a0d2a67f.png\" alt=\"image-20250120162753899\" /></p>\n<ul>\n<li>注意：这里需要给 widget.h 前⾯加上 #include ，不然会出现报错</li>\n</ul>\n<p>结果如下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/06bd3afcbf70911a5f0e6b3df72f2ea3.gif\" alt=\"\" /></p>\n<h3><a id=\"_Table_Widget___110_Table_Widget___137\"></a>{#_Table_Widget___110}🦋 Table Widget – 表格</h3>\n<p>使用 QTableWidget 表示一个表格控件。一个表格中包含若干行，每一行又包含若干列。</p>\n<p>表格中的每个单元格，是一个 <code>QTableWidge tItem</code> 对象。</p>\n<p><strong>QTableWidget 核心方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>item(int row, int column)</td>\n<td>根据行数列数获取指定的 <code>QTableWidgetItem*</code></td>\n</tr>\n<tr>\n<td>setItem(int row, int column, QTableWidgetItem*)</td>\n<td>根据行数列数设置表格中的元素</td>\n</tr>\n<tr>\n<td>currentItem()</td>\n<td>返回被选中的元素 <code>QTableWidgetItem*</code></td>\n</tr>\n<tr>\n<td>currentRow()</td>\n<td>返回被选中元素是第几行</td>\n</tr>\n<tr>\n<td>currentColumn()</td>\n<td>返回被选中元素是第几列</td>\n</tr>\n<tr>\n<td>row(QTableWidgetItem*)</td>\n<td>获取指定 <code>item</code> 是第几行</td>\n</tr>\n<tr>\n<td>column(QTableWidgetItem*)</td>\n<td>获取指定 <code>item</code> 是第几列</td>\n</tr>\n<tr>\n<td>rowCount()</td>\n<td>获取行数</td>\n</tr>\n<tr>\n<td>columnCount()</td>\n<td>获取列数</td>\n</tr>\n<tr>\n<td>insertRow(int row)</td>\n<td>在第 <code>row</code> 行处插入新行</td>\n</tr>\n<tr>\n<td>insertColumn(int column)</td>\n<td>在第 <code>column</code> 列插入新列</td>\n</tr>\n<tr>\n<td>removeRow(int row)</td>\n<td>删除第 <code>row</code> 行</td>\n</tr>\n<tr>\n<td>removeColumn(int column)</td>\n<td>删除第 <code>column</code> 列</td>\n</tr>\n<tr>\n<td>setHorizontalHeaderItem(int column, QTableWidgetItem*)</td>\n<td>设置指定列的表头</td>\n</tr>\n<tr>\n<td>setVerticalHeaderItem(int row, QTableWidgetItem*)</td>\n<td>设置指定行的表头</td>\n</tr>\n</tbody>\n</table>\n<p><strong>QTableWidget tltem 核心信号</strong></p>\n<table>\n<thead>\n<tr>\n<th>核心信号</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cellClicked(int row, int column)</td>\n<td>点击单元格时触发</td>\n</tr>\n<tr>\n<td>cellDoubleClicked(int row, int column)</td>\n<td>双击单元格时触发</td>\n</tr>\n<tr>\n<td>cellEntered(int row, int column)</td>\n<td>鼠标进入单元格时触发</td>\n</tr>\n<tr>\n<td>currentCellChanged(int row, int column, int previousRow, int previousColumn)</td>\n<td>选中不同单元格时触发</td>\n</tr>\n</tbody>\n</table>\n<p><strong>QTableWidget tltem 核心方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>核心方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>row()</td>\n<td>获取当前是第几行</td>\n</tr>\n<tr>\n<td>column()</td>\n<td>获取当前是第几列</td>\n</tr>\n<tr>\n<td>setText(const QString&amp;)</td>\n<td>设置文本</td>\n</tr>\n<tr>\n<td>setTextAlignment(int)</td>\n<td>设置文本对齐</td>\n</tr>\n<tr>\n<td>setIcon(const QIcon&amp;)</td>\n<td>设置图标</td>\n</tr>\n<tr>\n<td>setSelected(bool)</td>\n<td>设置被选中</td>\n</tr>\n<tr>\n<td>setSizeHint(const QSize&amp;)</td>\n<td>设置尺寸</td>\n</tr>\n<tr>\n<td>setFont(const QFont&amp;)</td>\n<td>设置字体</td>\n</tr>\n</tbody>\n</table>\n<p>可以通过这些 属性和方法来动态地添加、移除或修改表格内容，以及定制单元格的表现形式，包括文本、对齐方式、图标等。</p>\n<p>同时，利用信号可以<strong>实现用户交互逻辑</strong>，如当用户点击或双击单元格时执行特定的操作。</p>\n<p>使用 TableWidget</p>\n<p>（1）在界面上创建 QTableWidget 和 四个按钮，一个输入框</p>\n<ul>\n<li>注意：<code>QTableWidget</code> 是 <code>QTableView</code> 的子类，功能比 <code>QTableView</code> 更丰富。我们使用 <code>QTableWidget</code> 即可。</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/63b3d198fe3ea08bc99317921187e9e5.png\" alt=\"image-20250120164846592\" /></p>\n<ul>\n<li>lineEdit 的文本是 右下角的 PlaceholderText 里设置的</li>\n</ul>\n<p>（2）编写 widget.cpp 构造函数，构造表格中的初始数据</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/68174f5dbf9d0587568a05d29c5672df.png\" alt=\"image-20250120165853238\" /></p>\n<p>（3）编写对应按钮的槽函数</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/517c61bc0d068f311c2ec563a9e094f7.png\" alt=\"image-20250120170407765\" /></p>\n<p>（4）执行程序，即可完成表格的基本操作</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/c045a6077863ddcb0a957cb420531ef7.gif\" alt=\"\" /></p>\n<ul>\n<li>默认情况下，单元格中的内容直接就是可编辑的。</li>\n<li>如果不想让用户编辑，可以设置 <code>ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);</code></li>\n</ul>\n<h3><a id=\"_Tree_Widget___191_Tree_Widget___214\"></a>{#_Tree_Widget___191}🦋 Tree Widget – 树形</h3>\n<p>使用 <code>QTreeWidget</code> (树整体 的管理） 表示一个树形控件，里面的每个元素都是一个 QTreeWidge tItem（选中的 某个节点 管理），每个 QTreeWidgetItem 可以包含多个文本和图标，每个文本 / 图标为一个列</p>\n<ul>\n<li>虽然 <code>QTreeWidget</code> 是树形结构，但是这个树形结构没有体验出根节点的，是从根节点的下一次子节点开始</li>\n<li>可以给 <code>QTreeWidget</code> 设置顶层节点（顶层节点可以有多个），然后再给顶层节点添加子节点，从而构成树形结构。</li>\n</ul>\n<p><strong>QTreeWidget 核心方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>核心方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>clear()</td>\n<td>清空所有子节点</td>\n</tr>\n<tr>\n<td>addTopLevelItem(QTreeWidgetItem* item)</td>\n<td>新增顶层节点</td>\n</tr>\n<tr>\n<td>topLevelItem(int index)</td>\n<td>获取指定下标的顶层节点</td>\n</tr>\n<tr>\n<td>topLevelItemCount()</td>\n<td>获取顶层节点个数</td>\n</tr>\n<tr>\n<td>indexOfTopLevelItem(QTreeWidgetItem* item)</td>\n<td>查询指定节点是顶层节点中的下标</td>\n</tr>\n<tr>\n<td>takeTopLevelItem(int index)</td>\n<td>删除指定的顶层节点，返回 <code>QTreeWidgetItem*</code> 表示被删除的元素</td>\n</tr>\n<tr>\n<td>currentItem()</td>\n<td>获取当前选中的节点，返回 <code>QTreeWidgetItem*</code></td>\n</tr>\n<tr>\n<td>setCurrentItem(QTreeWidgetItem* item)</td>\n<td>选中指定节点</td>\n</tr>\n<tr>\n<td>setExpanded(bool)</td>\n<td>展开/关闭节点</td>\n</tr>\n<tr>\n<td>setHeaderLabel(const QString&amp; text)</td>\n<td>设置 <code>TreeWidget</code> 的 header 名称</td>\n</tr>\n</tbody>\n</table>\n<p><strong>QTreeWidget 核心信号</strong></p>\n<table>\n<thead>\n<tr>\n<th>核心信号</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>currentItemChanged(QTreeWidgetItem* current, QTreeWidgetItem* old)</td>\n<td>切换选中元素时触发</td>\n</tr>\n<tr>\n<td>itemClicked(QTreeWidgetItem* item, int col)</td>\n<td>点击元素时触发</td>\n</tr>\n<tr>\n<td>itemDoubleClicked(QTreeWidgetItem* item, int col)</td>\n<td>双击元素时触发</td>\n</tr>\n<tr>\n<td>itemEntered(QTreeWidgetItem* item, int col)</td>\n<td>鼠标进入时触发</td>\n</tr>\n<tr>\n<td>itemExpanded(QTreeWidgetItem* item)</td>\n<td>元素被展开时触发</td>\n</tr>\n<tr>\n<td>itemCollapsed(QTreeWidgetItem* item)</td>\n<td>元素被折叠时触发</td>\n</tr>\n</tbody>\n</table>\n<p><strong>QTreeWidget tltem 核心属性</strong></p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text</td>\n<td>持有的文本</td>\n</tr>\n<tr>\n<td>textAlignment</td>\n<td>文本对齐方式</td>\n</tr>\n<tr>\n<td>icon</td>\n<td>持有的图标</td>\n</tr>\n<tr>\n<td>font</td>\n<td>文本字体</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td>是否隐藏</td>\n</tr>\n<tr>\n<td>disabled</td>\n<td>是否禁用</td>\n</tr>\n<tr>\n<td>expanded</td>\n<td>是否展开</td>\n</tr>\n<tr>\n<td>sizeHint</td>\n<td>尺寸大小</td>\n</tr>\n<tr>\n<td>selected</td>\n<td>是否选中</td>\n</tr>\n</tbody>\n</table>\n<p><strong>QTreeWidget tltem 核心信号</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>addChild(QTreeWidgetItem* child)</td>\n<td>新增子节点</td>\n</tr>\n<tr>\n<td>childCount()</td>\n<td>子节点的个数</td>\n</tr>\n<tr>\n<td>child(int index)</td>\n<td>获取指定下标的子节点，返回 <code>QTreeWidgetItem*</code></td>\n</tr>\n<tr>\n<td>takeChild(int index)</td>\n<td>删除对应下标的子节点</td>\n</tr>\n<tr>\n<td>removeChild(QTreeWidgetItem* child)</td>\n<td>删除对应的子节点</td>\n</tr>\n<tr>\n<td>parent()</td>\n<td>获取该元素的父节点</td>\n</tr>\n</tbody>\n</table>\n<p>通过上述提供的方法和信号，可以创建、管理和操作树形结构的数据，并响应用户的交互。<code>QTreeWidgetItem</code> 提供了更多的<strong>细粒度控制，允许 定制每个项的表现形式和行为</strong>。</p>\n<p>使用 TreeWidget</p>\n<p>（1）在界面上创建一个 TreeView，右键 =&gt; 变形为 =&gt; TreeWidget，再创建一个 lineEdit 和两个按钮</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/dfac40cce0570373f2cf807c9405ffd6.png\" alt=\"image-20250120174231180\" /></p>\n<ul>\n<li>注意：TreeWidget 是 TreeView 的子类，功能比 TreeView 更丰富。我们使用 TreeWidget 即可。</li>\n</ul>\n<p>（2）编写代码，构造初始数据</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/53f531a4d7be14bfbb6096e5d1226e98.png\" alt=\"image-20250120175108799\" /></p>\n<p>（3）编写代码，实现按钮的 slot 函数</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/d353d6f253c35ca8d6f5530f3b3bce3d.png\" alt=\"image-20250120181057527\" /></p>\n<p>（4）执行程序，可以针对树形框进行编辑，如下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/f9a8fffed205892422e544af43c55996.gif\" alt=\"\" /></p>\n<h2><a id=\"font_colorDarkOrchid_QT__font_273_QT__294\"></a>{#font_colorDarkOrchid_QT__font_273}二：🔥 QT 常用控件【容器类】</h2>\n<h3><a id=\"_Group_Box___275_Group_Box___297\"></a>{#_Group_Box___275}🦋 Group Box – 分组框</h3>\n<p>使用 <code>QGroupBox</code> 实现一个带有标题的分组框，可以把其他的控件放到里面作为一组，这样看起来能更好看一点。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/ffea36bcdd0783acc5f6394b2b6f0188.png\" alt=\"image-20250120181448805\" /></p>\n<p>注意：不要把 QGroupBox 和 QButtonGroup 混淆（之前在介绍 QRadionButton 的时候提到了 QButtonGroup）。</p>\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>title</td>\n<td>分组框的标题</td>\n</tr>\n<tr>\n<td>alignment</td>\n<td>分组框内部内容的对齐方式</td>\n</tr>\n<tr>\n<td>flat</td>\n<td>是否是 “扁平” 模式；设置为 <code>true</code>时，分组框将不显示边框，呈现扁平化外观</td>\n</tr>\n<tr>\n<td>checkable</td>\n<td>是否可选择；设为 <code>true</code>，则在 <code>title</code>前方会多出一个可勾选的部分</td>\n</tr>\n<tr>\n<td>checked</td>\n<td>描述分组框的选择状态（前提是 <code>checkable</code>为 <code>true</code>）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>分组框 只是一个用来 “美化界面” 这样的组件，并不涉及到用户交互和业务逻辑，属于 “锦上添花”。</li>\n</ul>\n<p>使用 Group Box</p>\n<p>在界面上创建两个分组框，并且在分组框内部创建下拉框和微调框</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/9ac9b8606fdfaf7ddab0bed4d5fae76f.png\" alt=\"image-20250120210555821\" /></p>\n<ul>\n<li>注意：在复制粘贴控件的时候，一定要先选中对应的父控件，再粘贴</li>\n</ul>\n<h3><a id=\"_Tab_Widget___301_Tab_Widget___323\"></a>{#_Tab_Widget___301}🦋 Tab Widget – 标签页</h3>\n<p>使用 <code>QTabWidget</code> 实现一个带有标签页的控件，可以往里面添加一些 widget，进一步的就可以通过标签页切换。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/9d91bebd492e17e7fb40c0af25d63991.png\" alt=\"image-20250120181921636\" /></p>\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>tabPosition</td>\n<td>标签页所在的位置： - North 上方 - South 下方 - West 左侧 - East 右侧</td>\n</tr>\n<tr>\n<td>currentIndex</td>\n<td>当前选中了第几个标签页（从0开始计算）</td>\n</tr>\n<tr>\n<td>currentTabText</td>\n<td>当前选中的标签页的文本</td>\n</tr>\n<tr>\n<td>currentTabName</td>\n<td>当前选中的标签页的名字</td>\n</tr>\n<tr>\n<td>currentTabIcon</td>\n<td>当前选中的标签页的图标</td>\n</tr>\n<tr>\n<td>currentTabToolTip</td>\n<td>当前选中的标签页的提示信息</td>\n</tr>\n<tr>\n<td>tabsClosable</td>\n<td>标签页是否可以关闭</td>\n</tr>\n<tr>\n<td>movable</td>\n<td>标签页是否可以移动</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th><strong>信号</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>currentChanged(int)</td>\n<td>在标签页发生切换时触发，参数为被点击的选项卡编号。</td>\n</tr>\n<tr>\n<td>tabBarClicked(int)</td>\n<td>在点击选项卡的标签条的时候触发，参数为被点击的选项卡编号。</td>\n</tr>\n<tr>\n<td>tabBarDoubleClicked(int)</td>\n<td>在双击选项卡的标签条的时候触发，参数为被点击的选项卡编号。</td>\n</tr>\n<tr>\n<td>tabCloseRequested(int)</td>\n<td>在标签页关闭请求时触发，参数为被请求关闭的选项卡编号。</td>\n</tr>\n</tbody>\n</table>\n<p>使用标签页管理多组控件</p>\n<p>（1）在界面上创建一个 QTabWidget 和两个按钮</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/2b723a78ac5cb68b07f2f1639b86d354.png\" alt=\"image-20250120182514456\" /></p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/a972037347bccacab4812bd94967ec4a.png\" alt=\"image-20250120212338110\" /></p>\n<p><strong>注意 ：</strong></p>\n<ul>\n<li>QTabWidget 中的每个标签页都是⼀个 QWidget</li>\n<li>点击标签页就可以直接切换</li>\n<li>右键 QTabWidget，可以添加标签页或者删除标签页</li>\n</ul>\n<p>（2）编写 widget.cpp，进行初始化，给标签页中放个简单的 label</p>\n<ul>\n<li>注意新创建的 label 的父元素，是 ui-&gt;tab 和 ui-&gt;tab_2</li>\n<li>Qt 中使用父子关系决定该控件 “在哪里”</li>\n</ul>\n<p>然后再编写按钮的 slot 函数 和 QTabWidget 的 <code>currentChanged</code> 函数</p>\n<ul>\n<li>使用 count() 获取到标签页的个数</li>\n<li>使用 addTab 新增标签页</li>\n<li>使用 removeTab 删除标签页</li>\n<li>使用 currentIndex 获取到当前标签页的下标</li>\n<li>使用 setCurrentIndex 切换当前标签页</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/b3fd3c2fb413c559758e8d43107d59eb.png\" alt=\"image-20250120213417906\" /></p>\n<p>（3）运行程序</p>\n<ul>\n<li>点击新建标签页，可以创建出新的标签</li>\n<li>点击删除当前标签页，可以删除标签</li>\n<li>切换标签页时，可以看到 qDebug 打印出的标签页编号</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/cd43000e65eab433a23a1a62196f0810.gif\" alt=\"\" /></p>\n<h2><a id=\"font_colorDarkOrchid_QT__font_364_QT__384\"></a>{#font_colorDarkOrchid_QT__font_364}三：🔥 QT 常用控件【布局类】</h2>\n<ul>\n<li>\n<p>之前使用 Qt 在界面上创建的控件都是通过 “绝对定位” 的方式来设定的，也就是每个控件所在的位置都需要计算坐标，最终通过 setGeometry 或者 move 方式摆放过去</p>\n</li>\n<li>\n<p>这种设定方式其实并不方便，尤其是界面如果 内容比较多，不好计算，而且一个窗口大小往往是可以调整的，按照绝对定位的方式，也无法自适应窗口大小。</p>\n</li>\n<li>\n<p>因此 Qt 引入 “布局管理器”（Layout）机制 来解决上述问题。</p>\n</li>\n</ul>\n<blockquote>\n<p>当然，布局管理器并非 Qt 独有。其他的 GUI 开发框架，像 Android、前端等也有类似的机制。</p>\n</blockquote>\n<h3><a id=\"__376__395\"></a>{#__376}🦋 垂直布局</h3>\n<p>🎢 使用 QVBoxLayout 表示垂直的布局管理器，V 是 vertical 的缩写。</p>\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layoutLeftMargin</td>\n<td>左侧边距，设置或获取布局内容与容器左边界的距离</td>\n</tr>\n<tr>\n<td>layoutRightMargin</td>\n<td>右侧边距，设置或获取布局内容与容器右边界的距离</td>\n</tr>\n<tr>\n<td>layoutTopMargin</td>\n<td>上方边距，设置或获取布局内容与容器上边界的距离</td>\n</tr>\n<tr>\n<td>layoutBottomMargin</td>\n<td>下方边距，设置或获取布局内容与容器下边界的距离</td>\n</tr>\n<tr>\n<td>layoutSpacing</td>\n<td>相邻元素之间的间距，设置或获取布局中各元素之间的默认间隔</td>\n</tr>\n</tbody>\n</table>\n<p>Layout 只是用于界面布局，并没有提供信号</p>\n<h4><a id=\"__QVBoxLayout__390__QVBoxLayout__409\"></a>{#__QVBoxLayout__390}🎀 【使用 QVBoxLayout 管理多个控件】</h4>\n<p>编写代码，创建布局管理器和三个按钮，并且把按钮添加到布局管理器中</p>\n<ul>\n<li>使用 addWidget 把控件添加到布局管理器中</li>\n<li>使用 setLayout 设置该布局管理器到 widget 中</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/34c1156fbca76b0e9b025af5b3f896b7.png\" alt=\"image-20250120214432395\" /></p>\n<ul>\n<li>可以看到此时界面上的按钮就存在于布局管理器中，随着窗口尺存变化而发生改变。</li>\n<li>此时的三个按钮的尺存和位置都是自动计算出来的。</li>\n</ul>\n<h4><a id=\"__QVBoxLayout_404__QVBoxLayout_421\"></a>{#__QVBoxLayout_404}🎀 【创建两个 QVBoxLayout】</h4>\n<p>🔥 在上面通过上述代码的方式，只能给这个 widget <strong>设定一个布局管理器</strong> 。实际上也可以通过 Qt Design 在一个窗口中创建多个布局管理器，如下操作：</p>\n<p>（1）在界面上创建两个 <code>QVBoxLayout</code>，每个 <code>QVBoxLayout</code> 各放三个按钮</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/daf20867fa263135d745d5d8e210d31a.png\" alt=\"image-20250120214545989\" /></p>\n<p>（2）运行程序</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/beb73aaad8ae64dbf469896920009d51.png\" alt=\"image-20250120214658126\" /></p>\n<ul>\n<li>可以看到这些按钮已经自动排列好，只不过<strong>当前这些按钮的位置不能随着窗口大小自动变化</strong>。</li>\n</ul>\n<p>通过 <code>Qt Designer</code> 创建的布局管理，其实是先创建了一个 widget，设置过 geometry 属性的，再把这个 layout 设置到这个 widget 中</p>\n<blockquote>\n<ul>\n<li>实际上，一个 widget 只能包含一个 layout。</li>\n<li>打开 ui 文件的原始 xml，可以看到其中的端倪。这种情况下 layout 并非是窗口 widget 的布局管理器，因此不会随着窗口大小改变。</li>\n</ul>\n</blockquote>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/fbd2152d308de947f0f46a0e6aa0bd01.png\" alt=\"image-20250120215246071\" /></p>\n<h3><a id=\"__429__441\"></a>{#__429}🦋 水平布局</h3>\n<p>使用 QHBoxLayout 表示垂直的布局管理器，H 是 horizontal 的缩写。</p>\n<ul>\n<li>核心属性（和 QVBoxLayout 属性是一致的）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layoutLeftMargin</td>\n<td>左侧边距</td>\n</tr>\n<tr>\n<td>layoutRightMargin</td>\n<td>右侧边距</td>\n</tr>\n<tr>\n<td>layoutTopMargin</td>\n<td>上方边距</td>\n</tr>\n<tr>\n<td>layoutBottomMargin</td>\n<td>下方边距</td>\n</tr>\n<tr>\n<td>layoutSpacing</td>\n<td>相邻元素之间的间距</td>\n</tr>\n</tbody>\n</table>\n<h4><a id=\"_QHBoxLayout__443_QHBoxLayout__455\"></a>{#_QHBoxLayout__443}🎀【使用 QHBoxLayout 管理控件】</h4>\n<p>编写代码，创建布局管理器和三个按钮，并且把按钮添加到布局管理器中，并且运行</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/a7217858fb6aa5dd3f69b14841d0c697.png\" alt=\"image-20250120215629736\" /></p>\n<ul>\n<li>可以看到此时界面上的按钮就存在于布局管理器中，随着窗口尺寸变化而发生改变。</li>\n<li>此时的三个按钮的尺存和位置都是自动计算出来的</li>\n</ul>\n<p>Layout 里面可以再嵌套上其他的 layout，从而达到更复杂的布局效果</p>\n<h4><a id=\"_layout_456_layout_466\"></a>{#_layout_456}🎀【嵌套的 layout】</h4>\n<p>在代码中创建以下内容，使用 <code>addLayout</code> 给 layout 中添加子 layout，并且运行程序</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/9e634c4f5f4ae26a821391fc4ad962e5.png\" alt=\"image-20250120220349671\" /></p>\n<p>结论：结合 QHBoxLayout 和 QVBoxLayout， 就可以做出各种复杂的界面了</p>\n<h3><a id=\"__466__474\"></a>{#__466}🦋 网格布局</h3>\n<p>Qt 中还提供了 QGridLayout 用来实现网格布局的效果，可以达到 <em><strong>*M * N*</strong></em> 的这种网格的效果。</p>\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layoutLeftMargin</td>\n<td>左侧边距</td>\n</tr>\n<tr>\n<td>layoutRightMargin</td>\n<td>右侧边距</td>\n</tr>\n<tr>\n<td>layoutTopMargin</td>\n<td>上方边距</td>\n</tr>\n<tr>\n<td>layoutBottomMargin</td>\n<td>下方边距</td>\n</tr>\n<tr>\n<td>layoutHorizontalSpacing</td>\n<td>相邻元素之间水平方向的间距</td>\n</tr>\n<tr>\n<td>layoutVerticalSpacing</td>\n<td>相邻元素之间垂直方向的间距</td>\n</tr>\n<tr>\n<td>layoutRowStretch</td>\n<td>行方向的拉伸系数</td>\n</tr>\n<tr>\n<td>layoutColumnStretch</td>\n<td>列方向的拉伸系数</td>\n</tr>\n</tbody>\n</table>\n<p>整体和 <code>QVBoxLayout</code> 以及<code>QHBoxLayout</code> 相似</p>\n<p>但是设置 spacing 的时候是按照垂直水平两个方向来设置的。</p>\n<h4><a id=\"__QGridLayout__487__QGridLayout__493\"></a>{#__QGridLayout__487}🎀 【使用 QGridLayout 管理元素】</h4>\n<p>代码中创建 QGridLayout 和 4 个按钮</p>\n<ul>\n<li>使用 addWidget 添加控件到布局管理器中，但是添加的同时会指定两个<strong>坐标</strong>，表示放在第几行，第几列。</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/7e74e2953913b297da05439cf7c29987.png\" alt=\"image-20250120220829889\" /></p>\n<ul>\n<li>当然如果调整行列坐标全部为0的话，那么这四个按钮都在一行，就相当于 <strong>QHBoxLayout</strong></li>\n</ul>\n<blockquote>\n<p>注意 ：</p>\n<ul>\n<li>设置行和列的时候，如果设置的是一个很大的值，但是这个值和上一个值之间并没有其他的元素，那么并不会在中间腾出额外的空间</li>\n<li>比如：把 button4 设置在第 100 行，但是由于 3-99 行没有元素，因此 button4 仍然会紧挨在 button3 下方看起来和上面的 0 1 2 3 的情况是相同的。</li>\n</ul>\n</blockquote>\n<h4><a id=\"__QGridLayout__504__QGridLayout__507\"></a>{#__QGridLayout__504}🎀 【设置 QGridLayout 中元素的大小比例】</h4>\n<p>创建 6 个按钮，按照 2 行 3 列的方式排列，使用 <code>setColumnStretch</code> 设置每一列的拉伸系数：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/3d4dcb7d2c9ec7849f39d113ab6247b4.png\" alt=\"image-20250120221625371\" /></p>\n<ul>\n<li>另外，QGridLayout 也提供了 <code>setRowStretch</code> 设置行之间的拉伸系数</li>\n<li>上述案例中，直接设置 <code>setRowStretch</code> 效果不明显，因为<strong>每个按钮的高度是固定的</strong>。</li>\n<li>需要把按钮的垂直方向的 sizePolicy 属性设置为 <code>QSizePolicy::Expanding</code> 尽可能填充满布局管理器，才能看到效果。</li>\n</ul>\n<p>如果<strong>拉伸系数设为 0，意思是不参与拉伸，此时按钮的宽度是固定值</strong>。</p>\n<h4><a id=\"__519__519\"></a>{#__519}🎀 【设置垂直方向的拉伸系数】</h4>\n<p>编写代码, 创建 6 个按钮, 按照 3 行 2 列方式排列，使用 setSizePolicy 设置按钮的尺寸策略，可选的值如下：</p>\n<ul>\n<li>QSizePolicy::Ignored：忽略控件的尺寸，不对布局产生影响。</li>\n<li>QSizePolicy::Minimum：控件的最小尺寸为固定值，布局时不会超过该值。</li>\n<li>QSizePolicy::Maximum：控件的最大尺寸为固定值，布局时不会小于该值。</li>\n<li>QSizePolicy::Preferred：控件的理想尺寸为固定值，布局时会尽量接近该值。</li>\n<li>QSizePolicy::Expanding：控件的尺寸可以根据空间调整，尽可能占据更多空间。</li>\n<li>QSizePolicy::Shrinking：控件的尺寸可以根据空间调整，尽可能缩小以适应空间。</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/a1efd9f51729c8681bcd091d06c027f1.png\" alt=\"image-20250120221941956\" /></p>\n<blockquote>\n<p>此时的按钮垂直方向都舒展开了，并且调整窗口尺寸，也会按照设定的比例同步变化。</p>\n</blockquote>\n<p>💡 结论：</p>\n<ul>\n<li>\n<p>总的来说，使用 <code>QGridLayout</code> 能够代替很多 <code>QHBoxLayout</code> 和 <code>QVBoxLayout</code> 嵌套的场景。毕竟嵌套的代码写起来是比较麻烦的。</p>\n</li>\n<li>\n<p>另外不要忘了，<code>QGridLayout</code> 里面也能嵌套 <code>QHBoxLayout</code> 和 <code>QVBoxLayout</code>，<code>QHBoxLayout</code> 和 <code>QVBoxLayout </code>里面也能嵌套 <code>QGridLayout</code></p>\n</li>\n<li>\n<p>灵活使用上述布局管理器就可以实现出任意的复杂界面。</p>\n</li>\n</ul>\n<h3><a id=\"__547__541\"></a>{#__547}🦋 表单布局</h3>\n<p>除了上述的布局管理器之外，Qt 还提供了 QFormLayout，属于是 QGridLayout 的特殊情况，专门用于实现两列表单的布局。</p>\n<p>这种表单布局多用于让用户 填写信息的场景，左侧列为提示，右侧列为输入框</p>\n<p>【使用 QFormLayout 创建表单】</p>\n<p>编写代码，创建 <code>QFormLayout</code>，以及两个 label 和两个 lineEdit</p>\n<ul>\n<li>使用 addRow 方法来添加一行，每行包含两个控件。</li>\n<li>第一个控件固定是 QLabel / 文本，第二个控件则可以是任意控件。</li>\n<li>如果把第⼀个参数填写为 <code>NULL</code>，则什么都不显示。</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/b8d51ad8e2a4c2dc2600002bca661b1d.png\" alt=\"image-20250120222721244\" /></p>\n<h3><a id=\"_Space_565_Space_557\"></a>{#_Space_565}🦋 Space</h3>\n<p>使用布局管理器的时候，可能需要在控件之间添加一段空白，就可以使用 <code>QSpacerItem</code> 来表示。</p>\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>width</td>\n<td>宽度</td>\n</tr>\n<tr>\n<td>height</td>\n<td>高度</td>\n</tr>\n<tr>\n<td>hData</td>\n<td>水平方向的 sizePolicy - QSizePolicy::Ignored: 忽略控件的尺寸，不对布局产生影响。 - QSizePolicy::Minimum: 控件的最小尺寸为固定值，布局时不会超过该值。 QSizePolicy::Maximum: 控件的最大尺寸为固定值，布局时不会小于该值。 QSizePolicy::Preferred: 控件的理想尺寸为固定值，布局时会尽量接近该值。 QSizePolicy::Expanding: 控件的尺寸可以根据空间调整，尽可能占据更多空间。 QSizePolicy::Shrinking: 控件的尺寸可以根据空间调整，尽可能缩小以适应空间。</td>\n</tr>\n<tr>\n<td>vData</td>\n<td>垂直方向的 <code>sizePolicy</code> 选项同上。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>注意：上述属性在构造函数设置即可</li>\n</ul>\n<p>【创建一组左右排列的按钮】</p>\n<p>在界面上创建一个 <code>QVBoxLayout</code> ，并添加两个按钮，在上面运行结果中我们可以知道这个肯定是紧挨的，但是如果在两个按钮中间添加一个 spacer，会咋样呢，如下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/94b6966ec49d2cd40042bf66bccb8c53.png\" alt=\"image-20250120223109755\" /></p>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/068ef0116140b189a860dcdfef5d6375.png\" alt=\"image-20250120223109755\" /></p>\n<ul>\n<li>在 Qt Designer 中，也可以直接给界面上添加 spacer：</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/img_convert/1381299fac0b11ae9a5f5338e5847ae7.png\" alt=\"image-20250120223133183\" /></p>\n<h2><a id=\"font_colorDarkOrchid__font_592__582\"></a>{#font_colorDarkOrchid__font_592}四：🔥 共勉</h2>\n<p>😋 以上就是我对 <strong><code>【QT】常用控件 【多元素类 | 容器类 | 布局类】</code></strong> 的理解, 觉得这篇博客对你有帮助的，可以点赞收藏关注支持一波~ 😉<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/1c9d1ff0140a4e5685ff162c69851475.gif\" alt=\"在这里插入图片描述\" /></p>\n', '\n\n🌈 **个人主页：[Zfox_](https://blog.csdn.net/weixin_50776420?type=blog)**   \n🔥 **系列专栏：[Qt](https://blog.csdn.net/weixin_50776420/category_12894253.html?spm=1001.2014.3001.5482)**\n\n\n<br />\n\n#### 目录\n\n* [一：🔥 QT 常用控件【多元素类】](#font_colorDarkOrchid__QT__font_8)\n*\n  * [🦋 List Widget -- 列表](#_List_Widget___32)\n  * [🦋 Table Widget -- 表格](#_Table_Widget___110)\n  * [🦋 Tree Widget -- 树形](#_Tree_Widget___191)\n* [二：🔥 QT 常用控件【容器类】](#font_colorDarkOrchid_QT__font_273)\n*\n  * [🦋 Group Box -- 分组框](#_Group_Box___275)\n  * [🦋 Tab Widget -- 标签页](#_Tab_Widget___301)\n* [三：🔥 QT 常用控件【布局类】](#font_colorDarkOrchid_QT__font_364)\n*\n  * [🦋 垂直布局](#__376)\n  *\n    * [🎀 【使用 QVBoxLayout 管理多个控件】](#__QVBoxLayout__390)\n    * [🎀 【创建两个 QVBoxLayout】](#__QVBoxLayout_404)\n  * [🦋 水平布局](#__429)\n  *\n    * [🎀【使用 QHBoxLayout 管理控件】](#_QHBoxLayout__443)\n    * [🎀【嵌套的 layout】](#_layout_456)\n  * [🦋 网格布局](#__466)\n  *\n    * [🎀 【使用 QGridLayout 管理元素】](#__QGridLayout__487)\n    * [🎀 【设置 QGridLayout 中元素的大小比例】](#__QGridLayout__504)\n    * [🎀 【设置垂直方向的拉伸系数】](#__519)\n  * [🦋 表单布局](#__547)\n  * [🦋 Space](#_Space_565)\n* [四：🔥 共勉](#font_colorDarkOrchid__font_592)\n\n<br />\n\n一：🔥 QT 常用控件【多元素类】 \n----------------------------------------------------------------------\n\n🚇 Qt 中提供的**多元素控件**有：\n\n* QListWidget\n* QListView\n* QTableWidget\n* QTableView\n* QTreeWidget\n* QTreeView\n\n**xxWidget 和 xxView 之间的区别**\n\n以 QTableWidget 和 QTableView 为例\n\nQTableView 是基于 MVC 设计的控件\n\n* MVC：M(model) 数据，V(view) 界面，C(controller)控制器 数据和视图之间的业务流程\n\n* QTableView 自身不持有数据，使用 QTableView 的时候需要用户创建一个 Model 对象（比如 QStandardModel），并且把 Model 和 QTableView 关联起来。\n\n* 后续修改 Model 中的数据就会影响 QTableView 的显示，修改 QTableView 的显示也会影响到 Model 中的数据（双向绑定）。\n\n`QTableWidget` 是 `QTableView` 的子类，对 `QTableView` 进行了扩展，将 Model 进行了封装，不需要用户手动创建 Model 对象，直接就可以往 `QTableWidget` 中添加数据了。\n\n### {#_List_Widget___32}🦋 List Widget -- 列表\n\n使用 QListWidget 能够显示一个纵向的列表组件。形如：\n\n![image-20250120154630270](https://i-blog.csdnimg.cn/img_convert/f58876ab6bf6d22fd3452ef02e344132.png)\n\n|       核心属性        |      说明      |\n|-------------------|--------------|\n| currentRow        | 当前被选中的是第几行   |\n| count             | 一共有多少行       |\n| sortingEnabled    | 是否允许排序       |\n| isWrapping        | 是否允许换行       |\n| itemAlignment     | 元素的对齐方式      |\n| selectRectVisible | 被选中的元素矩形是否可见 |\n| spacing           | 元素之间的间隔      |\n\n|                                          核心方法                                          |                        说明                        |\n|----------------------------------------------------------------------------------------|--------------------------------------------------|\n| addItem(const QString\\& label) addItem(QListWidgetItem \\*item)                         | 列表中添加元素                                          |\n| currentItem()                                                                          | 返回 `QListWidgetItem*` 表示当前选中的元素                  |\n| setCurrentItem(QListWidgetItem\\* item)                                                 | 设置选中哪个元素                                         |\n| setCurrentRow(int row)                                                                 | 设置选中第几行的元素                                       |\n| insertItem(const QString\\& label, int row) insertItem(QListWidgetItem \\*item, int row) | 在指定的位置插入元素                                       |\n| item(int row)                                                                          | 返回 `QListWidgetItem*` 表示第 `row` 行的元素             |\n| takeItem(int row)                                                                      | **删除** 指定行的元素, 返回 `QListWidgetItem*` 表示是哪个元素被删除了 |\n\n|                                 核心信号                                 |               说明               |\n|----------------------------------------------------------------------|--------------------------------|\n| currentItemChanged(QListWidgetItem\\* current, QListWidgetItem\\* old) | 选中不同元素时会触发. 参数是当前选中的元素和之前选中的元素 |\n| currentRowChanged(int)                                               | 选中不同元素时会触发. 参数是当前选中元素的行数       |\n| itemClicked(QListWidgetItem\\* item)                                  | 点击某个元素时触发                      |\n| itemDoubleClicked(QListWidgetItem\\* item)                            | 双击某个元素时触发                      |\n| itemEntered(QListWidgetItem\\* item)                                  | 鼠标进入元素时触发                      |\n\n在上述介绍中涉及到⼀个关键的类：**QListWidgetItem** ，这个类表示 `QListWidget` 中的一个元素。核心方法如下，本质上就是⼀个 \"文本+图标\" 构成的\n\n* setFont: 设置字体\n* setIcon: 设置图标\n* setHidden: 设置隐藏\n* setSizeHint: 设置尺寸\n* setSelected: 设置是否选中\n* setText: 设置文本\n* setTextAlignment: 设置文本对齐方式\n\n这些方法允许我们自定义 Q List Widget Item 的外观和行为。\n\n通过结合使用 QListWidget 的属性、方法和信号，以及 `QListWidgetItem` 的方法，可以创建高度定制化的列表控件。\n\n使用 ListWidget\n\n（1）在界面上创建一个 ListView，右键 =\\> 变形为 =\\> ListWidget，再创建一个 lineEdit 和两个按钮\n\n注意：\n\n* ListWidget 是 ListView 的子类，功能比 ListView 更丰富。\n* 我们使用 ListWidget 即可。\n\n![image-20250120162804519](https://i-blog.csdnimg.cn/img_convert/8e51a24ecf705e8e06d27af930066196.png)\n\n（2）编写 widget.cpp，在构造函数中添加初始元素 或者 直接在图形化界面选择 \"编辑项目\"，编写 listWidget 的 slot 函数，然后编写按钮的 slot 函数\n\n* 此处编写 listWidget 的 slot 函数：需要判定 current 和 previous 非空，初始情况下是没有元素选中的，就导致这两个指针可能是 NULL。\n\n![image-20250120162753899](https://i-blog.csdnimg.cn/img_convert/0485f980e2f132b8b6df5e05a0d2a67f.png)\n\n* 注意：这里需要给 widget.h 前⾯加上 #include ，不然会出现报错\n\n结果如下：\n\n![](https://i-blog.csdnimg.cn/img_convert/06bd3afcbf70911a5f0e6b3df72f2ea3.gif)\n\n### {#_Table_Widget___110}🦋 Table Widget -- 表格\n\n使用 QTableWidget 表示一个表格控件。一个表格中包含若干行，每一行又包含若干列。\n\n表格中的每个单元格，是一个 `QTableWidge tItem` 对象。\n\n**QTableWidget 核心方法**\n\n|                           方法                            |               说明                |\n|---------------------------------------------------------|---------------------------------|\n| item(int row, int column)                               | 根据行数列数获取指定的 `QTableWidgetItem*` |\n| setItem(int row, int column, QTableWidgetItem\\*)        | 根据行数列数设置表格中的元素                  |\n| currentItem()                                           | 返回被选中的元素 `QTableWidgetItem*`    |\n| currentRow()                                            | 返回被选中元素是第几行                     |\n| currentColumn()                                         | 返回被选中元素是第几列                     |\n| row(QTableWidgetItem\\*)                                 | 获取指定 `item` 是第几行                |\n| column(QTableWidgetItem\\*)                              | 获取指定 `item` 是第几列                |\n| rowCount()                                              | 获取行数                            |\n| columnCount()                                           | 获取列数                            |\n| insertRow(int row)                                      | 在第 `row` 行处插入新行                 |\n| insertColumn(int column)                                | 在第 `column` 列插入新列               |\n| removeRow(int row)                                      | 删除第 `row` 行                     |\n| removeColumn(int column)                                | 删除第 `column` 列                  |\n| setHorizontalHeaderItem(int column, QTableWidgetItem\\*) | 设置指定列的表头                        |\n| setVerticalHeaderItem(int row, QTableWidgetItem\\*)      | 设置指定行的表头                        |\n\n**QTableWidget tltem 核心信号**\n\n|                                     核心信号                                     |     说明     |\n|------------------------------------------------------------------------------|------------|\n| cellClicked(int row, int column)                                             | 点击单元格时触发   |\n| cellDoubleClicked(int row, int column)                                       | 双击单元格时触发   |\n| cellEntered(int row, int column)                                             | 鼠标进入单元格时触发 |\n| currentCellChanged(int row, int column, int previousRow, int previousColumn) | 选中不同单元格时触发 |\n\n**QTableWidget tltem 核心方法**\n\n|            核心方法            |    说明    |\n|----------------------------|----------|\n| row()                      | 获取当前是第几行 |\n| column()                   | 获取当前是第几列 |\n| setText(const QString\\&)   | 设置文本     |\n| setTextAlignment(int)      | 设置文本对齐   |\n| setIcon(const QIcon\\&)     | 设置图标     |\n| setSelected(bool)          | 设置被选中    |\n| setSizeHint(const QSize\\&) | 设置尺寸     |\n| setFont(const QFont\\&)     | 设置字体     |\n\n可以通过这些 属性和方法来动态地添加、移除或修改表格内容，以及定制单元格的表现形式，包括文本、对齐方式、图标等。\n\n同时，利用信号可以**实现用户交互逻辑**，如当用户点击或双击单元格时执行特定的操作。\n\n使用 TableWidget\n\n（1）在界面上创建 QTableWidget 和 四个按钮，一个输入框\n\n* 注意：`QTableWidget` 是 `QTableView` 的子类，功能比 `QTableView` 更丰富。我们使用 `QTableWidget` 即可。\n\n![image-20250120164846592](https://i-blog.csdnimg.cn/img_convert/63b3d198fe3ea08bc99317921187e9e5.png)\n\n* lineEdit 的文本是 右下角的 PlaceholderText 里设置的\n\n（2）编写 widget.cpp 构造函数，构造表格中的初始数据\n\n![image-20250120165853238](https://i-blog.csdnimg.cn/img_convert/68174f5dbf9d0587568a05d29c5672df.png)\n\n（3）编写对应按钮的槽函数\n\n![image-20250120170407765](https://i-blog.csdnimg.cn/img_convert/517c61bc0d068f311c2ec563a9e094f7.png)\n\n（4）执行程序，即可完成表格的基本操作\n\n![](https://i-blog.csdnimg.cn/img_convert/c045a6077863ddcb0a957cb420531ef7.gif)\n\n* 默认情况下，单元格中的内容直接就是可编辑的。\n* 如果不想让用户编辑，可以设置 `ui->tableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);`\n\n### {#_Tree_Widget___191}🦋 Tree Widget -- 树形\n\n使用 `QTreeWidget` (树整体 的管理） 表示一个树形控件，里面的每个元素都是一个 QTreeWidge tItem（选中的 某个节点 管理），每个 QTreeWidgetItem 可以包含多个文本和图标，每个文本 / 图标为一个列\n\n* 虽然 `QTreeWidget` 是树形结构，但是这个树形结构没有体验出根节点的，是从根节点的下一次子节点开始\n* 可以给 `QTreeWidget` 设置顶层节点（顶层节点可以有多个），然后再给顶层节点添加子节点，从而构成树形结构。\n\n**QTreeWidget 核心方法**\n\n|                    核心方法                     |                    说明                    |\n|---------------------------------------------|------------------------------------------|\n| clear()                                     | 清空所有子节点                                  |\n| addTopLevelItem(QTreeWidgetItem\\* item)     | 新增顶层节点                                   |\n| topLevelItem(int index)                     | 获取指定下标的顶层节点                              |\n| topLevelItemCount()                         | 获取顶层节点个数                                 |\n| indexOfTopLevelItem(QTreeWidgetItem\\* item) | 查询指定节点是顶层节点中的下标                          |\n| takeTopLevelItem(int index)                 | 删除指定的顶层节点，返回 `QTreeWidgetItem*` 表示被删除的元素 |\n| currentItem()                               | 获取当前选中的节点，返回 `QTreeWidgetItem*`          |\n| setCurrentItem(QTreeWidgetItem\\* item)      | 选中指定节点                                   |\n| setExpanded(bool)                           | 展开/关闭节点                                  |\n| setHeaderLabel(const QString\\& text)        | 设置 `TreeWidget` 的 header 名称              |\n\n**QTreeWidget 核心信号**\n\n|                                 核心信号                                 |    说明     |\n|----------------------------------------------------------------------|-----------|\n| currentItemChanged(QTreeWidgetItem\\* current, QTreeWidgetItem\\* old) | 切换选中元素时触发 |\n| itemClicked(QTreeWidgetItem\\* item, int col)                         | 点击元素时触发   |\n| itemDoubleClicked(QTreeWidgetItem\\* item, int col)                   | 双击元素时触发   |\n| itemEntered(QTreeWidgetItem\\* item, int col)                         | 鼠标进入时触发   |\n| itemExpanded(QTreeWidgetItem\\* item)                                 | 元素被展开时触发  |\n| itemCollapsed(QTreeWidgetItem\\* item)                                | 元素被折叠时触发  |\n\n**QTreeWidget tltem 核心属性**\n\n|      属性       |   说明   |\n|---------------|--------|\n| text          | 持有的文本  |\n| textAlignment | 文本对齐方式 |\n| icon          | 持有的图标  |\n| font          | 文本字体   |\n| hidden        | 是否隐藏   |\n| disabled      | 是否禁用   |\n| expanded      | 是否展开   |\n| sizeHint      | 尺寸大小   |\n| selected      | 是否选中   |\n\n**QTreeWidget tltem 核心信号**\n\n|                  方法                  |                说明                |\n|--------------------------------------|----------------------------------|\n| addChild(QTreeWidgetItem\\* child)    | 新增子节点                            |\n| childCount()                         | 子节点的个数                           |\n| child(int index)                     | 获取指定下标的子节点，返回 `QTreeWidgetItem*` |\n| takeChild(int index)                 | 删除对应下标的子节点                       |\n| removeChild(QTreeWidgetItem\\* child) | 删除对应的子节点                         |\n| parent()                             | 获取该元素的父节点                        |\n\n通过上述提供的方法和信号，可以创建、管理和操作树形结构的数据，并响应用户的交互。`QTreeWidgetItem` 提供了更多的**细粒度控制，允许 定制每个项的表现形式和行为**。\n\n使用 TreeWidget\n\n（1）在界面上创建一个 TreeView，右键 =\\> 变形为 =\\> TreeWidget，再创建一个 lineEdit 和两个按钮\n\n![image-20250120174231180](https://i-blog.csdnimg.cn/img_convert/dfac40cce0570373f2cf807c9405ffd6.png)\n\n* 注意：TreeWidget 是 TreeView 的子类，功能比 TreeView 更丰富。我们使用 TreeWidget 即可。\n\n（2）编写代码，构造初始数据\n\n![image-20250120175108799](https://i-blog.csdnimg.cn/img_convert/53f531a4d7be14bfbb6096e5d1226e98.png)\n\n（3）编写代码，实现按钮的 slot 函数\n\n![image-20250120181057527](https://i-blog.csdnimg.cn/img_convert/d353d6f253c35ca8d6f5530f3b3bce3d.png)\n\n（4）执行程序，可以针对树形框进行编辑，如下：\n\n![](https://i-blog.csdnimg.cn/img_convert/f9a8fffed205892422e544af43c55996.gif)\n\n{#font_colorDarkOrchid_QT__font_273}二：🔥 QT 常用控件【容器类】\n-----------------------------------------------------\n\n### {#_Group_Box___275}🦋 Group Box -- 分组框\n\n使用 `QGroupBox` 实现一个带有标题的分组框，可以把其他的控件放到里面作为一组，这样看起来能更好看一点。\n\n![image-20250120181448805](https://i-blog.csdnimg.cn/img_convert/ffea36bcdd0783acc5f6394b2b6f0188.png)\n\n注意：不要把 QGroupBox 和 QButtonGroup 混淆（之前在介绍 QRadionButton 的时候提到了 QButtonGroup）。\n\n|  **属性**   |                  **说明**                   |\n|-----------|-------------------------------------------|\n| title     | 分组框的标题                                    |\n| alignment | 分组框内部内容的对齐方式                              |\n| flat      | 是否是 \"扁平\" 模式；设置为 `true`时，分组框将不显示边框，呈现扁平化外观 |\n| checkable | 是否可选择；设为 `true`，则在 `title`前方会多出一个可勾选的部分   |\n| checked   | 描述分组框的选择状态（前提是 `checkable`为 `true`）       |\n\n* 分组框 只是一个用来 \"美化界面\" 这样的组件，并不涉及到用户交互和业务逻辑，属于 \"锦上添花\"。\n\n使用 Group Box\n\n在界面上创建两个分组框，并且在分组框内部创建下拉框和微调框\n\n![image-20250120210555821](https://i-blog.csdnimg.cn/img_convert/9ac9b8606fdfaf7ddab0bed4d5fae76f.png)\n\n* 注意：在复制粘贴控件的时候，一定要先选中对应的父控件，再粘贴\n\n### {#_Tab_Widget___301}🦋 Tab Widget -- 标签页\n\n使用 `QTabWidget` 实现一个带有标签页的控件，可以往里面添加一些 widget，进一步的就可以通过标签页切换。\n\n![image-20250120181921636](https://i-blog.csdnimg.cn/img_convert/9d91bebd492e17e7fb40c0af25d63991.png)\n\n|      **属性**       |                       **说明**                        |\n|-------------------|-----------------------------------------------------|\n| tabPosition       | 标签页所在的位置： - North 上方 - South 下方 - West 左侧 - East 右侧 |\n| currentIndex      | 当前选中了第几个标签页（从0开始计算）                                 |\n| currentTabText    | 当前选中的标签页的文本                                         |\n| currentTabName    | 当前选中的标签页的名字                                         |\n| currentTabIcon    | 当前选中的标签页的图标                                         |\n| currentTabToolTip | 当前选中的标签页的提示信息                                       |\n| tabsClosable      | 标签页是否可以关闭                                           |\n| movable           | 标签页是否可以移动                                           |\n\n|          **信号**          |            **说明**             |\n|--------------------------|-------------------------------|\n| currentChanged(int)      | 在标签页发生切换时触发，参数为被点击的选项卡编号。     |\n| tabBarClicked(int)       | 在点击选项卡的标签条的时候触发，参数为被点击的选项卡编号。 |\n| tabBarDoubleClicked(int) | 在双击选项卡的标签条的时候触发，参数为被点击的选项卡编号。 |\n| tabCloseRequested(int)   | 在标签页关闭请求时触发，参数为被请求关闭的选项卡编号。   |\n\n使用标签页管理多组控件\n\n（1）在界面上创建一个 QTabWidget 和两个按钮\n\n![image-20250120182514456](https://i-blog.csdnimg.cn/img_convert/2b723a78ac5cb68b07f2f1639b86d354.png)\n\n![image-20250120212338110](https://i-blog.csdnimg.cn/img_convert/a972037347bccacab4812bd94967ec4a.png)\n\n**注意 ：**\n\n* QTabWidget 中的每个标签页都是⼀个 QWidget\n* 点击标签页就可以直接切换\n* 右键 QTabWidget，可以添加标签页或者删除标签页\n\n（2）编写 widget.cpp，进行初始化，给标签页中放个简单的 label\n\n* 注意新创建的 label 的父元素，是 ui-\\>tab 和 ui-\\>tab_2\n* Qt 中使用父子关系决定该控件 \"在哪里\"\n\n然后再编写按钮的 slot 函数 和 QTabWidget 的 `currentChanged` 函数\n\n* 使用 count() 获取到标签页的个数\n* 使用 addTab 新增标签页\n* 使用 removeTab 删除标签页\n* 使用 currentIndex 获取到当前标签页的下标\n* 使用 setCurrentIndex 切换当前标签页\n\n![image-20250120213417906](https://i-blog.csdnimg.cn/img_convert/b3fd3c2fb413c559758e8d43107d59eb.png)\n\n（3）运行程序\n\n* 点击新建标签页，可以创建出新的标签\n* 点击删除当前标签页，可以删除标签\n* 切换标签页时，可以看到 qDebug 打印出的标签页编号\n\n![](https://i-blog.csdnimg.cn/img_convert/cd43000e65eab433a23a1a62196f0810.gif)\n\n{#font_colorDarkOrchid_QT__font_364}三：🔥 QT 常用控件【布局类】\n-----------------------------------------------------\n\n* 之前使用 Qt 在界面上创建的控件都是通过 \"绝对定位\" 的方式来设定的，也就是每个控件所在的位置都需要计算坐标，最终通过 setGeometry 或者 move 方式摆放过去\n\n* 这种设定方式其实并不方便，尤其是界面如果 内容比较多，不好计算，而且一个窗口大小往往是可以调整的，按照绝对定位的方式，也无法自适应窗口大小。\n\n* 因此 Qt 引入 \"布局管理器\"（Layout）机制 来解决上述问题。\n\n> 当然，布局管理器并非 Qt 独有。其他的 GUI 开发框架，像 Android、前端等也有类似的机制。\n\n### {#__376}🦋 垂直布局\n\n🎢 使用 QVBoxLayout 表示垂直的布局管理器，V 是 vertical 的缩写。\n\n|       **属性**       |            **说明**            |\n|--------------------|------------------------------|\n| layoutLeftMargin   | 左侧边距，设置或获取布局内容与容器左边界的距离      |\n| layoutRightMargin  | 右侧边距，设置或获取布局内容与容器右边界的距离      |\n| layoutTopMargin    | 上方边距，设置或获取布局内容与容器上边界的距离      |\n| layoutBottomMargin | 下方边距，设置或获取布局内容与容器下边界的距离      |\n| layoutSpacing      | 相邻元素之间的间距，设置或获取布局中各元素之间的默认间隔 |\n\nLayout 只是用于界面布局，并没有提供信号\n\n#### {#__QVBoxLayout__390}🎀 【使用 QVBoxLayout 管理多个控件】\n\n编写代码，创建布局管理器和三个按钮，并且把按钮添加到布局管理器中\n\n* 使用 addWidget 把控件添加到布局管理器中\n* 使用 setLayout 设置该布局管理器到 widget 中\n\n![image-20250120214432395](https://i-blog.csdnimg.cn/img_convert/34c1156fbca76b0e9b025af5b3f896b7.png)\n\n* 可以看到此时界面上的按钮就存在于布局管理器中，随着窗口尺存变化而发生改变。\n* 此时的三个按钮的尺存和位置都是自动计算出来的。\n\n#### {#__QVBoxLayout_404}🎀 【创建两个 QVBoxLayout】\n\n🔥 在上面通过上述代码的方式，只能给这个 widget **设定一个布局管理器** 。实际上也可以通过 Qt Design 在一个窗口中创建多个布局管理器，如下操作：\n\n（1）在界面上创建两个 `QVBoxLayout`，每个 `QVBoxLayout` 各放三个按钮\n\n![image-20250120214545989](https://i-blog.csdnimg.cn/img_convert/daf20867fa263135d745d5d8e210d31a.png)\n\n（2）运行程序\n\n![image-20250120214658126](https://i-blog.csdnimg.cn/img_convert/beb73aaad8ae64dbf469896920009d51.png)\n\n* 可以看到这些按钮已经自动排列好，只不过**当前这些按钮的位置不能随着窗口大小自动变化**。\n\n通过 `Qt Designer` 创建的布局管理，其实是先创建了一个 widget，设置过 geometry 属性的，再把这个 layout 设置到这个 widget 中\n> * 实际上，一个 widget 只能包含一个 layout。\n> * 打开 ui 文件的原始 xml，可以看到其中的端倪。这种情况下 layout 并非是窗口 widget 的布局管理器，因此不会随着窗口大小改变。\n\n![image-20250120215246071](https://i-blog.csdnimg.cn/img_convert/fbd2152d308de947f0f46a0e6aa0bd01.png)\n\n### {#__429}🦋 水平布局\n\n使用 QHBoxLayout 表示垂直的布局管理器，H 是 horizontal 的缩写。\n\n* 核心属性（和 QVBoxLayout 属性是一致的）\n\n|       **属性**       |  **说明**   |\n|--------------------|-----------|\n| layoutLeftMargin   | 左侧边距      |\n| layoutRightMargin  | 右侧边距      |\n| layoutTopMargin    | 上方边距      |\n| layoutBottomMargin | 下方边距      |\n| layoutSpacing      | 相邻元素之间的间距 |\n\n#### {#_QHBoxLayout__443}🎀【使用 QHBoxLayout 管理控件】\n\n编写代码，创建布局管理器和三个按钮，并且把按钮添加到布局管理器中，并且运行\n\n![image-20250120215629736](https://i-blog.csdnimg.cn/img_convert/a7217858fb6aa5dd3f69b14841d0c697.png)\n\n* 可以看到此时界面上的按钮就存在于布局管理器中，随着窗口尺寸变化而发生改变。\n* 此时的三个按钮的尺存和位置都是自动计算出来的\n\nLayout 里面可以再嵌套上其他的 layout，从而达到更复杂的布局效果\n\n#### {#_layout_456}🎀【嵌套的 layout】\n\n在代码中创建以下内容，使用 `addLayout` 给 layout 中添加子 layout，并且运行程序\n\n![image-20250120220349671](https://i-blog.csdnimg.cn/img_convert/9e634c4f5f4ae26a821391fc4ad962e5.png)\n\n结论：结合 QHBoxLayout 和 QVBoxLayout， 就可以做出各种复杂的界面了\n\n### {#__466}🦋 网格布局\n\nQt 中还提供了 QGridLayout 用来实现网格布局的效果，可以达到 ***\\*M \\* N\\**** 的这种网格的效果。\n\n|         **属性**          |    **说明**     |\n|-------------------------|---------------|\n| layoutLeftMargin        | 左侧边距          |\n| layoutRightMargin       | 右侧边距          |\n| layoutTopMargin         | 上方边距          |\n| layoutBottomMargin      | 下方边距          |\n| layoutHorizontalSpacing | 相邻元素之间水平方向的间距 |\n| layoutVerticalSpacing   | 相邻元素之间垂直方向的间距 |\n| layoutRowStretch        | 行方向的拉伸系数      |\n| layoutColumnStretch     | 列方向的拉伸系数      |\n\n整体和 `QVBoxLayout` 以及`QHBoxLayout` 相似\n\n但是设置 spacing 的时候是按照垂直水平两个方向来设置的。\n\n#### {#__QGridLayout__487}🎀 【使用 QGridLayout 管理元素】\n\n代码中创建 QGridLayout 和 4 个按钮\n\n* 使用 addWidget 添加控件到布局管理器中，但是添加的同时会指定两个**坐标**，表示放在第几行，第几列。\n\n![image-20250120220829889](https://i-blog.csdnimg.cn/img_convert/7e74e2953913b297da05439cf7c29987.png)\n\n* 当然如果调整行列坐标全部为0的话，那么这四个按钮都在一行，就相当于 **QHBoxLayout**\n\n> 注意 ：\n> * 设置行和列的时候，如果设置的是一个很大的值，但是这个值和上一个值之间并没有其他的元素，那么并不会在中间腾出额外的空间\n> * 比如：把 button4 设置在第 100 行，但是由于 3-99 行没有元素，因此 button4 仍然会紧挨在 button3 下方看起来和上面的 0 1 2 3 的情况是相同的。\n\n#### {#__QGridLayout__504}🎀 【设置 QGridLayout 中元素的大小比例】\n\n创建 6 个按钮，按照 2 行 3 列的方式排列，使用 `setColumnStretch` 设置每一列的拉伸系数：\n\n![image-20250120221625371](https://i-blog.csdnimg.cn/img_convert/3d4dcb7d2c9ec7849f39d113ab6247b4.png)\n\n* 另外，QGridLayout 也提供了 `setRowStretch` 设置行之间的拉伸系数\n* 上述案例中，直接设置 `setRowStretch` 效果不明显，因为**每个按钮的高度是固定的**。\n* 需要把按钮的垂直方向的 sizePolicy 属性设置为 `QSizePolicy::Expanding` 尽可能填充满布局管理器，才能看到效果。\n\n如果**拉伸系数设为 0，意思是不参与拉伸，此时按钮的宽度是固定值**。\n\n#### {#__519}🎀 【设置垂直方向的拉伸系数】\n\n编写代码, 创建 6 个按钮, 按照 3 行 2 列方式排列，使用 setSizePolicy 设置按钮的尺寸策略，可选的值如下：\n\n* QSizePolicy::Ignored：忽略控件的尺寸，不对布局产生影响。\n* QSizePolicy::Minimum：控件的最小尺寸为固定值，布局时不会超过该值。\n* QSizePolicy::Maximum：控件的最大尺寸为固定值，布局时不会小于该值。\n* QSizePolicy::Preferred：控件的理想尺寸为固定值，布局时会尽量接近该值。\n* QSizePolicy::Expanding：控件的尺寸可以根据空间调整，尽可能占据更多空间。\n* QSizePolicy::Shrinking：控件的尺寸可以根据空间调整，尽可能缩小以适应空间。\n\n![image-20250120221941956](https://i-blog.csdnimg.cn/img_convert/a1efd9f51729c8681bcd091d06c027f1.png)\n> 此时的按钮垂直方向都舒展开了，并且调整窗口尺寸，也会按照设定的比例同步变化。\n\n💡 结论：\n\n* 总的来说，使用 `QGridLayout` 能够代替很多 `QHBoxLayout` 和 `QVBoxLayout` 嵌套的场景。毕竟嵌套的代码写起来是比较麻烦的。\n\n* 另外不要忘了，`QGridLayout` 里面也能嵌套 `QHBoxLayout` 和 `QVBoxLayout`，`QHBoxLayout` 和 `QVBoxLayout `里面也能嵌套 `QGridLayout`\n\n* 灵活使用上述布局管理器就可以实现出任意的复杂界面。\n\n### {#__547}🦋 表单布局\n\n除了上述的布局管理器之外，Qt 还提供了 QFormLayout，属于是 QGridLayout 的特殊情况，专门用于实现两列表单的布局。\n\n这种表单布局多用于让用户 填写信息的场景，左侧列为提示，右侧列为输入框\n\n【使用 QFormLayout 创建表单】\n\n编写代码，创建 `QFormLayout`，以及两个 label 和两个 lineEdit\n\n* 使用 addRow 方法来添加一行，每行包含两个控件。\n* 第一个控件固定是 QLabel / 文本，第二个控件则可以是任意控件。\n* 如果把第⼀个参数填写为 `NULL`，则什么都不显示。\n\n![image-20250120222721244](https://i-blog.csdnimg.cn/img_convert/b8d51ad8e2a4c2dc2600002bca661b1d.png)\n\n### {#_Space_565}🦋 Space\n\n使用布局管理器的时候，可能需要在控件之间添加一段空白，就可以使用 `QSpacerItem` 来表示。\n\n| **属性** |                                                                                                                                                  **说明**                                                                                                                                                   |\n|--------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| width  | 宽度                                                                                                                                                                                                                                                                                                        |\n| height | 高度                                                                                                                                                                                                                                                                                                        |\n| hData  | 水平方向的 sizePolicy - QSizePolicy::Ignored: 忽略控件的尺寸，不对布局产生影响。 - QSizePolicy::Minimum: 控件的最小尺寸为固定值，布局时不会超过该值。 QSizePolicy::Maximum: 控件的最大尺寸为固定值，布局时不会小于该值。 QSizePolicy::Preferred: 控件的理想尺寸为固定值，布局时会尽量接近该值。 QSizePolicy::Expanding: 控件的尺寸可以根据空间调整，尽可能占据更多空间。 QSizePolicy::Shrinking: 控件的尺寸可以根据空间调整，尽可能缩小以适应空间。 |\n| vData  | 垂直方向的 `sizePolicy` 选项同上。                                                                                                                                                                                                                                                                                  |\n\n* 注意：上述属性在构造函数设置即可\n\n【创建一组左右排列的按钮】\n\n在界面上创建一个 `QVBoxLayout` ，并添加两个按钮，在上面运行结果中我们可以知道这个肯定是紧挨的，但是如果在两个按钮中间添加一个 spacer，会咋样呢，如下：\n\n![image-20250120223109755](https://i-blog.csdnimg.cn/img_convert/94b6966ec49d2cd40042bf66bccb8c53.png)\n\n![image-20250120223109755](https://i-blog.csdnimg.cn/img_convert/068ef0116140b189a860dcdfef5d6375.png)\n\n* 在 Qt Designer 中，也可以直接给界面上添加 spacer：\n\n![image-20250120223133183](https://i-blog.csdnimg.cn/img_convert/1381299fac0b11ae9a5f5338e5847ae7.png)\n\n{#font_colorDarkOrchid__font_592}四：🔥 共勉\n----------------------------------------\n\n😋 以上就是我对 **`【QT】常用控件 【多元素类 | 容器类 | 布局类】`** 的理解, 觉得这篇博客对你有帮助的，可以点赞收藏关注支持一波\\~ 😉  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1c9d1ff0140a4e5685ff162c69851475.gif)\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/weixin_50776420/article/details/147226912?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-05-23 16:50:51', '2025-05-23 17:13:20');
INSERT INTO `sys_article` VALUES (312, 1, 17, '【Linux 进程控制】—— 进程亦生生不息：起于鸿蒙，守若空谷，归于太虚', 'img/【Linux 进程控制】—— 进程亦生生不息：起于鸿蒙，守若空谷，归于太虚.png', '【Linux 进程控制】—— 进程亦生生不息：起于鸿蒙，守若空谷，归于太虚', '<blockquote>\n<p>欢迎来到一整颗红豆的博客✨，一个关于探索技术的角落，记录学习的点滴📖，分享实用的技巧🛠️，偶尔还有一些奇思妙想💡<br />\n本文由一整颗红豆原创✍️，感谢支持❤️！请尊重原创📩！欢迎评论区留言交流🌟<br />\n个人主页 👉 <a href=\"https://blog.csdn.net/bite_zwy?spm=1000.2115.3001.5343\" target=\"_blank\">一整颗红豆</a><br />\n本文专栏➡️<a href=\"https://blog.csdn.net/bite_zwy/category_12860166.html\" target=\"_blank\">Linux驾驭之道 掌控操作系统的艺术与哲学</a></p>\n</blockquote>\n<br />\n<h4><a id=\"_8\"></a>生生不息：起于鸿蒙，守若空谷，归于太虚</h4>\n<ul>\n<li><a href=\"#_11\">进程创建</a></li>\n<li>\n<ul>\n<li><a href=\"#fork_12\">再识fork函数</a></li>\n<li><a href=\"#fork_81\">fork函数返回值</a></li>\n<li><a href=\"#_CopyOnWrite_123\">写时拷贝 `Copy-On-Write`</a></li>\n</ul>\n</li>\n<li><a href=\"#_168\">进程等待</a></li>\n<li>\n<ul>\n<li><a href=\"#_183\">进程等待的方法</a></li>\n<li>\n<ul>\n<li><a href=\"#wait_185\">`wait`</a></li>\n<li><a href=\"#waitpid_205\">`waitpid`</a></li>\n</ul>\n</li>\n<li><a href=\"#_status_247\">获取子进程 status</a></li>\n<li><a href=\"#_389\">阻塞等待与非阻塞等待</a></li>\n<li>\n<ul>\n<li><a href=\"#Blocking_Wait_393\">阻塞等待（`Blocking Wait`）</a></li>\n<li><a href=\"#Nonblocking_Wait_424\">非阻塞等待（`Non-blocking Wait`）</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#_484\">进程终止</a></li>\n<li>\n<ul>\n<li><a href=\"#_491\">进程退出场景</a></li>\n<li><a href=\"#_604\">进程退出码</a></li>\n<li><a href=\"#_624\">错误码</a></li>\n<li><a href=\"#_exitexit_832\">_exit函数和exit函数</a></li>\n<li><a href=\"#return__944\">return 退出</a></li>\n<li><a href=\"#_exitexit__return__989\">`_exit`、`exit` 和 `return` 对比</a></li>\n</ul>\n</li>\n<li><a href=\"#_1019\">写在最后</a></li>\n</ul>\n<br />\n<h2><a id=\"_11_content_views_38\"></a>{#_11}进程创建 {#content_views}</h2>\n<h3><a id=\"fork_12fork_41\"></a>{#fork_12}再识fork函数</h3>\n<blockquote>\n<p>之前在 <a href=\"https://blog.csdn.net/bite_zwy/article/details/145863781?spm=1001.2014.3001.5501\" target=\"_blank\">Linux进程状态</a> 这篇文章中，我们已经为大家介绍过Linux系统中一个非常重要的系统调用 — <strong><code>fork</code></strong> ，今天我们在来重谈 <strong><code>fork</code></strong> 函数，让大家对这个系统调用有更深刻的理解。</p>\n</blockquote>\n<p>在 Linux中 <strong><code>fork</code></strong> 函数是非常重要的函数，它从已存在进程中创建⼀个新进程。创建出来的新进程叫做子进程，而原进程则称为父进程。</p>\n<p>在Linux参考手册中，fork函数的原型如下：（<code>man 2 fork</code> 指令查看）</p>\n<pre><code class=\"lang-prism\">NAME\n       fork - create a child process\n\nSYNOPSIS\n       #include &lt;sys/types.h&gt;\n       #include &lt;unistd.h&gt;\n\n       pid_t fork(void);\n</code></pre>\n<p>如上不难看出：</p>\n<ul>\n<li><strong><code>fork</code></strong> 函数的功能是创建一个子进程</li>\n<li>头文件有 <strong><code>&lt;sys/types.h&gt;</code></strong> 和 <strong><code>&lt;unistd.h&gt;</code></strong></li>\n<li>参数为 <strong><code>void</code></strong> ，返回值为 <strong><code>pid_t</code></strong> (实际上是Linux内核中typedef出来的一个类型)</li>\n</ul>\n<hr />\n<p>进程调用 fork，当控制转移到内核中的 fork 代码后，内核做如下几件事：</p>\n<ul>\n<li>分配新的内存块和内核数据结构给子进程</li>\n<li>将父进程部分数据结构内容拷贝至子进程</li>\n<li>添加子进程到系统进程列表当中</li>\n<li>fork返回，开始调度器调度</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/b0da0e26c11b454b934fbdf009216003.png\" alt=\"在这里插入图片描述\" /></p>\n<p>当⼀个进程调用fork之后，就有两个⼆进制代码相同的进程。并且它们都运行到相同的地方。但每个进程都将可以开始属于它们自己的旅程，看如下程序：</p>\n<pre><code class=\"lang-prism\">int main(void)\n{\n    pid_t pid;\n    printf(&quot;Before: pid is %d\\n&quot;, getpid());\n    if ((pid = fork()) == -1)\n        perror(&quot;fork()&quot;), exit(1);\n    printf(&quot;After:pid is %d, fork return %d\\n&quot;, getpid(), pid);\n    sleep(1);\n    return 0;\n}\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"lang-prism\">Before: pid is 40176\nAfter:pid is 40176, fork return 40177\nAfter:pid is 40177, fork return 0\n</code></pre>\n<hr />\n<blockquote>\n<p>这里看到了三行输出，⼀行before，两行after。其中 40176就是父进程啦，40177就是子进程。进程40176先打印before消息，然后它有打印after。另⼀个after消息是进程40177打印的。注意到进程40177没有打印before，为什么呢？</p>\n</blockquote>\n<p>如下图所示：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/8ebde01960aa4fb98e450fe488d4f5b0.png\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>当父进程执行到fork创建出子进程时，已经执行了上面的before代码，而创建出子进程后，子进程不会去执行父进程已经执行过的代码，而是和父进程一同执行fork之后的代码。这就是为什么子进程没有打印before的原因</p>\n</blockquote>\n<p><strong>所以，fork之前父进程独立执行，fork之后，父子进程两个执行流分别执行之后的代码。<code>值得注意的是，fork之后，谁先执行完全由调度器决定，并没有明确的先后关系！</code></strong></p>\n<hr />\n<h3><a id=\"fork_81fork_113\"></a>{#fork_81}fork函数返回值</h3>\n<blockquote>\n<p>类型定义：fork() 返回 <strong><code>pid_t</code></strong> 类型（通常为 int 通过 typedef 定义），用于表示进程ID（PID）。</p>\n</blockquote>\n<p><strong><code>fork</code>创建成功：</strong></p>\n<ul>\n<li>子进程返回0</li>\n<li>父进程返回的是子进程的 pid</li>\n</ul>\n<p><strong>为什么给父进程返回子进程的pid，这个问题我们之前已经讨论过：</strong></p>\n<blockquote>\n<p>一个父进程可以创建一个或者多个子进程，父进程需要通过返回值获得新创建的子进程的唯一标识符（正整数），从而可以管理创建的多个子进程（如发送信号、等待终止等）</p>\n</blockquote>\n<p><strong>为什么子进程返回0</strong></p>\n<blockquote>\n<p>子进程返回0，标识自己为子进程，子进程通过返回值 0 确认自己的身份。子进程无需知晓父进程的PID（实际上可以通过 <strong><code>getppid()</code></strong> 获取）</p>\n</blockquote>\n<hr />\n<p><strong><code>fork</code>创建失败：</strong></p>\n<p>返回 -1并设置错误码：</p>\n<ul>\n<li>当系统资源不足（如进程数超限、内存耗尽）时，fork() 失败。</li>\n</ul>\n<p>错误码：</p>\n<ul>\n<li>需检查 errno 确定具体原因</li>\n</ul>\n<pre><code class=\"lang-prism\">if (pid == -1) {\n    perror(&quot;fork failed&quot;); // 输出类似 &quot;fork failed: Resource temporarily unavailable&quot;\n}\n</code></pre>\n<p>常见错误码：</p>\n<ul>\n<li><strong><code>EAGAIN</code></strong>：进程数超过限制（RLIMIT_NPROC）或内存不足。</li>\n<li><strong><code>ENOMEM</code></strong>：内核无法分配必要数据结构所需内存。</li>\n</ul>\n<hr />\n<h3><a id=\"_CopyOnWrite_123_CopyOnWrite_153\"></a>{#_CopyOnWrite_123}写时拷贝 <code>Copy-On-Write</code></h3>\n<blockquote>\n<p>写时拷贝（COW）是 Linux 中 fork() 系统调用的核心优化机制，它使得进程创建变得高效且资源友好，通常，父子代码共享，父子再不写入时，数据也是共享的，当任意一方试图写入，便以写时拷贝的方式各自⼀份副本。</p>\n</blockquote>\n<p><strong>为什么需要写时拷贝？</strong></p>\n<p>在传统的进程创建方式中，fork() 会直接复制父进程的所有内存空间给子进程。这种方式存在明显问题：</p>\n<ul>\n<li>内存浪费：如果父进程占用 1GB 内存，子进程即使不修改任何数据，也会立即消耗额外 1GB 内存。</li>\n<li>性能低下：复制大量内存需要时间，尤其是对大型进程而言，fork() 会显著延迟程序运行。</li>\n</ul>\n<p>COW 的解决思路：</p>\n<ul>\n<li>推迟实际的内存复制，直到父子进程中某一方尝试修改内存页时，才进行真正的拷贝。在此之前，父子进程共享同一份物理内存。</li>\n</ul>\n<p>具体见下图:</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/8833d10b92034fe8bc0b2d3232ea0329.png\" alt=\"在这里插入图片描述\" /></p>\n<p>因为有写时拷贝技术的存在,所以父子进程得以彻底分离！完成了进程独立性的技术保证! 写时拷贝,是⼀种延时申请技术,可以提高整机内存的使用率。</p>\n<p><strong>写时拷贝的工作流程</strong></p>\n<p>1、 fork() 调用时</p>\n<ul>\n<li>共享内存页：内核仅为子进程创建虚拟内存结构（页表），但物理内存页仍与父进程共享。</li>\n<li>标记为只读：内核将共享的物理内存页标记为只读（即使父进程原本可写）。</li>\n</ul>\n<p>2、进程尝试写入内存</p>\n<ul>\n<li>触发页错误：当父进程或子进程尝试修改某个共享内存页时，由于页被标记为只读，CPU 会触发页错误（<strong><code>Page Fault</code></strong>）。</li>\n</ul>\n<p>内核介入处理：操作系统会由用户态陷入内核态处理异常</p>\n<ul>\n<li>分配新的物理内存页，复制原页内容到新页。</li>\n<li>修改触发写入的进程的页表，使其指向新页。</li>\n<li>将新页标记为可写，恢复进程执行。</li>\n</ul>\n<p>3、后续操作</p>\n<ul>\n<li>修改后的进程独享新内存页，另一进程仍使用原页。</li>\n<li>未修改的内存页继续共享，不做复制，操作系统不做任何无意义的事情。</li>\n</ul>\n<hr />\n<h2><a id=\"_168_198\"></a>{#_168}进程等待</h2>\n<p>之前我们在讲进程概念的时候讲过，如果父进程创建出子进程后，如果子进程已经退出，父进程却没有对子进程回收，那么就子进程就会变成 <strong>“僵尸进程”</strong> ，造成内存泄露等问题。</p>\n<blockquote>\n<p>在Linux系统中，进程等待是父进程通过系统调用等待子进程终止并获取其退出状态的过程，主要目的是避免僵尸进程并回收子进程资源。</p>\n</blockquote>\n<p><strong>进程等待的必要性</strong></p>\n<p><strong>僵尸进程问题：</strong></p>\n<ul>\n<li>子进程终止后，其退出状态会保留在进程表中，直到父进程读取。若父进程未处理，子进程将保持僵尸状态（<strong><code>Zombie</code></strong>），占用系统资源。</li>\n<li>状态收集：父进程需知晓子进程的执行结果（成功、错误代码、信号终止等）。</li>\n<li>资源回收：内核释放子进程占用的内存、文件描述符等资源。</li>\n</ul>\n<h3><a id=\"_183_212\"></a>{#_183}进程等待的方法</h3>\n<h4><a id=\"wait_185wait_214\"></a>{#wait_185}<code>wait</code></h4>\n<pre><code class=\"lang-prism\">#include&lt;sys/types.h&gt;\n#include&lt;sys/wait.h&gt;\npid_t wait(int* status);\n</code></pre>\n<p>具体功能：</p>\n<ul>\n<li>阻塞父进程，直到等待到任意一个子进程终止。</li>\n</ul>\n<p>参数：</p>\n<ul>\n<li><strong><code>status</code></strong> ：输出型参数，用来存储子进程退出状态的指针（可为 <strong><code>NULL</code></strong>，表示不关心状态）。</li>\n</ul>\n<p>返回值：</p>\n<ul>\n<li>成功：返回终止的子进程PID。失败：返回-1（如无子进程）。</li>\n</ul>\n<hr />\n<h4><a id=\"waitpid_205waitpid_236\"></a>{#waitpid_205}<code>waitpid</code></h4>\n<pre><code class=\"lang-prism\">#include &lt;sys/wait.h&gt;\npid_t waitpid(pid_t pid, int *status, int options);\n</code></pre>\n<ul>\n<li>功能：更灵活的等待方式，可指定子进程或非阻塞等待模式。</li>\n</ul>\n<p>参数：</p>\n<p><strong><code>pid：</code></strong></p>\n<ul>\n<li><strong><code>&gt;0</code></strong>：等待指定 PID 的子进程。</li>\n<li><strong><code>-1</code></strong>：等待任意子进程（等效于 wait）。</li>\n<li><strong><code>0</code></strong>：等待同一进程组的子进程。</li>\n</ul>\n<p><strong><code>status</code></strong> ：同 <strong>wait</strong>，输出型参数，表明子进程的退出状态。</p>\n<p><strong><code>options</code>：</strong> 默认为0，表示阻塞等待</p>\n<ul>\n<li><strong><code>WNOHANG</code></strong>：非阻塞模式，无子进程终止时立即返回 0。</li>\n<li><strong><code>WUNTRACED</code></strong>：报告已停止的子进程（如被信号暂停）。</li>\n</ul>\n<p>返回值：</p>\n<ul>\n<li>成功：返回子进程PID。</li>\n<li><strong><code>WNOHANG</code></strong> 且无子进程终止：返回0。</li>\n<li>失败：返回-1。</li>\n</ul>\n<p><strong>做个总结：</strong></p>\n<ul>\n<li>如果子进程已经退出，调用 <strong>wait / waitpid</strong> 时，<strong>wait / waitpid</strong> 会立即返回，并且释放资源，获得子进程退出信息。</li>\n<li>如果在任意时刻调用 <strong>wait / waitpid</strong>，子进程存在且正常运行，则进程可能阻塞。 如果不存在该子进程，则立即出错返回。</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/a0412fcc88f24cfc9f5e9a38f4278147.png\" alt=\"在这里插入图片描述\" /></p>\n<hr />\n<h3><a id=\"_status_247_status_275\"></a>{#_status_247}获取子进程 status</h3>\n<p><strong><code>wait</code></strong> 和 <strong><code>waitpid</code></strong> ，都有⼀个 <strong><code>status</code></strong> 参数，该参数是⼀个输出型参数，由操作系统填充。</p>\n<ul>\n<li>如果传递 <strong><code>NULL</code></strong>，表示不关心子进程的退出状态信息。</li>\n<li>否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程。</li>\n</ul>\n<p><strong><code>status</code></strong> 不能简单的当作整形来看待，可以当作位图来看待，具体细节如下图<br />\n（只研究 status 低16比特位）：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/f8291ebf08c043cc8e5c7fe6a840148b.png\" alt=\"在这里插入图片描述\" /></p>\n<hr />\n<p>如何理解呢？<br />\n子进程的退出分为两种情况：</p>\n<ol>\n<li>正常终止</li>\n</ol>\n<p>高 8 位（第 8 ~ 15 位）：保存子进程的退出状态（退出码）（即 <strong><code>exit(code)</code></strong> 或 <strong><code>return code</code></strong> 中的 <strong><code>code</code></strong> 值）。</p>\n<p>第 7 位：通常为 0，表示正常终止。</p>\n<p>示例：</p>\n<p>若子进程调用 exit(5)，表明子进程是正常退出，则 status 的高 8 位为 00000101（即十进制 5）。</p>\n<ol start=\"2\">\n<li>被信号所杀导致终止</li>\n</ol>\n<p>低 7 位（第 0 ~ 6 位）：保存导致子进程终止的信号编号。</p>\n<p>第 7 位：若为 1，表示子进程在终止时生成了 <strong><code>core dump</code></strong> 文件（用于调试）。有关 <strong><code>core dump</code></strong> 文件，后面会讲，大家这里先了解一下即可。</p>\n<p>第 8 ~ 15 位：未使用（通常为 0）。</p>\n<p>示例：</p>\n<p>若子进程因 <strong><code>SIGKILL</code></strong>（信号编号 9）终止，则 status 的低 7 位为 0001001（即十进制 9）。</p>\n<ul>\n<li><strong>做个小总结：</strong></li>\n</ul>\n<pre><code class=\"lang-prism\">低 16 位结构：\n| 15 14 13 12 11 10 9 8 | 7 | 6 5 4 3 2 1 0 |\n---------------------------------------------\n正常终止 → [ 退出状态（高8位） ]  0  [ 未使用 ]\n被信号终止 → [   未使用（全0）   ] c  [ 信号编号 ]\n</code></pre>\n<hr />\n<p><strong>如何解析 status？</strong></p>\n<blockquote>\n<p>难道真的需要我们将 status 当作位图，使用位操作来提取子进程的退出信息吗？<br />\n这么做对我们程序员来说当然小菜一碟，不过有点多余了，没必要。Linux系统为我们定义了多种宏用来提取 status，方便且专业。</p>\n</blockquote>\n<p><strong>使用宏定义检查 status 的值：</strong></p>\n<table>\n<thead>\n<tr>\n<th>宏</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WIFEXITED(status)</td>\n<td>若子进程正常终止（exit 或 return）返回真。</td>\n</tr>\n<tr>\n<td>WEXITSTATUS(status)</td>\n<td>若 WIFEXITED 为真，返回子进程的退出码（exit 的参数或 return 的值）。</td>\n</tr>\n<tr>\n<td>WIFSIGNALED(status)</td>\n<td>若子进程因信号终止返回真。</td>\n</tr>\n<tr>\n<td>WTERMSIG(status)</td>\n<td>若 WIFSIGNALED 为真，返回导致终止的信号编号。</td>\n</tr>\n<tr>\n<td>WCOREDUMP(status)</td>\n<td>若子进程生成了核心转储文件返回真。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>常用的两个宏：</strong></p>\n<ul>\n<li><strong><code>WIFEXITED</code></strong>(status): 若为正常终止子进程返回的状态，则为真。（查看进程是 否是正常退出）</li>\n<li><strong><code>WEXITSTATUS</code></strong>(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的 退出码）</li>\n</ul>\n<p>示例一：子进程正常退出</p>\n<pre><code class=\"lang-prism\">int main()\n{\n    pid_t pid = fork();\n    if (pid == 0)\n    { // 子进程\n        printf(&quot;子进程运行中... PID=%d\\n&quot;, getpid());\n        // 1. 正常退出：调用 exit(42)\n        exit(42);\n    }\n    else\n    { // 父进程\n        int status;\n        waitpid(pid, &amp;status, 0); // 等待子进程结束\n        if (WIFEXITED(status))\n        { // 正常退出\n            printf(&quot;子进程正常退出，退出码: %d\\n&quot;, WEXITSTATUS(status));\n        }\n        else if (WIFSIGNALED(status))\n        { // 被信号终止\n            printf(&quot;子进程被信号终止，信号编号: %d\\n&quot;, WTERMSIG(status));\n        }\n    }\n    return 0;\n}\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"lang-prism\">子进程运行中... PID=56153\n子进程正常退出，退出码: 42\n</code></pre>\n<p>示例二：子进程被信号终止</p>\n<pre><code class=\"lang-prism\">int main()\n{\n    pid_t pid = fork();\n    if (pid == 0)\n    { // 子进程\n        printf(&quot;子进程运行中... PID=%d\\n&quot;, getpid());\n        int *p = NULL;\n        *p = 100;  // 对空指针解引用，触发 SIGSEGV 被信号终止\n    }\n    else\n    { // 父进程\n        int status;\n        waitpid(pid, &amp;status, 0); // 等待子进程结束\n        if (WIFEXITED(status))\n        { // 正常退出\n            printf(&quot;子进程正常退出，退出码: %d\\n&quot;, WEXITSTATUS(status));\n        }\n        else if (WIFSIGNALED(status))\n        { // 被信号终止\n            printf(&quot;子进程被信号终止，信号编号: %d\\n&quot;, WTERMSIG(status));\n        }\n    }\n    return 0;\n}\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"lang-prism\">子进程运行中... PID=56203\n子进程被信号终止，信号编号: 11\n</code></pre>\n<h3><a id=\"_389_417\"></a>{#_389}阻塞等待与非阻塞等待</h3>\n<blockquote>\n<p>在 Unix/Linux 中，父进程通过 wait 或 waitpid 函数等待子进程结束。它们的核心区别在于是否允许父进程在等待子进程时继续执行其他任务。</p>\n</blockquote>\n<h4><a id=\"Blocking_Wait_393Blocking_Wait_421\"></a>{#Blocking_Wait_393}阻塞等待（<code>Blocking Wait</code>）</h4>\n<blockquote>\n<p>父进程调用 waitpid 后，会一直挂起（阻塞），直到目标子进程终止。在阻塞期间，父进程无法执行其他操作，直到子进程退出。</p>\n</blockquote>\n<pre><code class=\"lang-prism\">pid_t waitpid(pid_t pid, int *status, 0);  // options 参数为 0\n</code></pre>\n<p>示例：</p>\n<pre><code class=\"lang-prism\">int main()\n{\n    int status;\n    pid_t child_pid = fork();\n    if (child_pid == 0)\n    {\n        // 子进程执行任务\n        exit(10);\n    }\n    else\n    {\n        // 父进程阻塞等待子进程结束\n        waitpid(child_pid, &amp;status, 0);\n        if (WIFEXITED(status))\n        {\n            printf(&quot;子进程退出码: %d\\n&quot;, WEXITSTATUS(status));\n        }\n    }\n}\n</code></pre>\n<h4><a id=\"Nonblocking_Wait_424Nonblocking_Wait_453\"></a>{#Nonblocking_Wait_424}非阻塞等待（<code>Non-blocking Wait</code>）</h4>\n<blockquote>\n<p>父进程调用 waitpid 时，若子进程未结束，则父进程立即返回，而不是挂起。父进程可以继续执行其他任务，同时定期检查子进程状态。需结合循环实现非阻塞式轮询（<code>polling</code>）。</p>\n</blockquote>\n<p>关键选项：宏 <strong><code>WNOHANG</code></strong> （定义在 <strong><code>&lt;sys/wait.h&gt;</code></strong> 中）。</p>\n<pre><code class=\"lang-prism\">pid_t waitpid(pid_t pid, int *status, WNOHANG);\n</code></pre>\n<p>示例：非阻塞轮询方式</p>\n<pre><code class=\"lang-prism\">int main()\n{\n    int status;\n    pid_t child_pid = fork();\n    if (child_pid == 0)\n    {\n        sleep(3); // 子进程休眠 3 秒后退出\n        exit(10);\n    }\n    else\n    {\n        while (1)\n        {\n            pid_t ret = waitpid(child_pid, &amp;status, WNOHANG);\n            if (ret == -1)\n            {\n                perror(&quot;waitpid&quot;);\n                break;\n            }\n            else if (ret == 0)\n            {\n                printf(&quot;子进程未结束，父进程继续工作...\\n&quot;);\n                sleep(1); // 避免频繁轮询消耗 CPU\n            }\n            else\n            {\n                if (WIFEXITED(status))\n                {\n                    printf(&quot;子进程退出码: %d\\n&quot;, WEXITSTATUS(status));\n                }\n                break;\n            }\n        }\n    }\n}\n</code></pre>\n<p><strong>阻塞等待和非阻塞等待的对比：</strong></p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>阻塞等待</th>\n<th>非阻塞等待</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>父进程任务优先级</td>\n<td>必须立即处理子进程结果</td>\n<td>需同时处理其他任务</td>\n</tr>\n<tr>\n<td>子进程执行时间</td>\n<td>较短或确定</td>\n<td>较长或不确定</td>\n</tr>\n<tr>\n<td>资源消耗</td>\n<td>CPU 空闲，无额外开销</td>\n<td>需轮询，可能占用更多 CPU</td>\n</tr>\n<tr>\n<td>典型应用</td>\n<td>简单脚本、单任务场景</td>\n<td>多进程管理、事件驱动程序</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2><a id=\"_484_514\"></a>{#_484}进程终止</h2>\n<p><strong><code>进程= 内核数据结构 + 进程自己的代码和数据</code></strong></p>\n<blockquote>\n<p>进程终止是进程生命周期的最后一个阶段，涉及资源释放、状态通知及父进程回收等关键步骤。进程终止的本质是释放系统资源，就是释放进程申请的相关内核数据结构和对应的代码和数据。</p>\n</blockquote>\n<h3><a id=\"_491_520\"></a>{#_491}进程退出场景</h3>\n<ul>\n<li><strong>代码运行完毕，结果正确</strong></li>\n<li><strong>代码运行完毕，结果不正确</strong></li>\n<li><strong>代码异常终止</strong></li>\n</ul>\n<p>如何理解这三种进程退出的场景呢？举个例子</p>\n<p><strong>代码运行完毕，结果正确</strong></p>\n<ul>\n<li>程序完整执行了所有逻辑，未触发任何错误或异常。</li>\n<li>输出结果与预期完全一致，符合功能需求或算法目标。</li>\n</ul>\n<pre><code class=\"lang-prism\">int sum(int a, int b)\n{\n    return a + b;\n}\n\nint main()\n{\n    int result = sum(3, 5);\n    printf(&quot;Result: %d\\n&quot;, result); // 输出 8，结果正确\n    return 0;\n}\n</code></pre>\n<p><strong>输出：</strong></p>\n<pre><code class=\"lang-prism\">Result: 8\n</code></pre>\n<hr />\n<p><strong>代码运行完毕，结果不正确</strong></p>\n<ul>\n<li>程序正常结束（无崩溃或异常），但输出结果与预期不符。</li>\n<li>通常由逻辑错误、算法错误或数据处理错误导致。</li>\n</ul>\n<p>例如：</p>\n<pre><code class=\"lang-prism\">// 错误实现：本应计算阶乘，但初始值错误\nint factorial(int n)\n{\n    int result = 0; // 错误！应为 result = 1\n    for (int i = 1; i &lt;= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\n\nint main()\n{\n    printf(&quot;5! = %d\\n&quot;, factorial(5)); // 输出 0，结果错误\n    return 0;\n}\n</code></pre>\n<hr />\n<p><strong>代码未执行完毕，异常终止</strong></p>\n<ul>\n<li>程序未执行完毕就中途崩溃或被强制终止。</li>\n<li>通常由运行时错误、资源限制或外部信号触发。</li>\n<li>比如除零错误，对空指针解引用等异常</li>\n</ul>\n<p><strong>例如</strong>：</p>\n<pre><code class=\"lang-prism\">int main()\n{\n    int *ptr = NULL;\n    *ptr = 42;  // 对空指针解引用，触发段错误\n    printf(&quot;Value: %d\\n&quot;, *ptr);\n    return 0;\n}\n</code></pre>\n<p><strong>段错误：</strong></p>\n<pre><code class=\"lang-prism\">Segmentation fault\n</code></pre>\n<p><strong>再比如：</strong></p>\n<pre><code class=\"lang-prism\">int main()\n{\n    int a = 10;\n    int b = a / 0; // 程序除零异常\n    printf(&quot;Value: %d\\n&quot;, b);\n    return 0;\n}\n</code></pre>\n<p><strong>浮点数异常：</strong></p>\n<pre><code class=\"lang-prism\">Floating point exception\n</code></pre>\n<p><strong>进程常见退出方法</strong></p>\n<p>正常终止（可以通过 <strong><code>echo $?</code></strong> 查看进程退出码）</p>\n<ol>\n<li>从main返回</li>\n<li>调用exit</li>\n<li>_exit</li>\n</ol>\n<p>异常退出：</p>\n<ol>\n<li><strong><code>ctrl + c</code></strong>，信号终止</li>\n</ol>\n<hr />\n<h3><a id=\"_604_639\"></a>{#_604}进程退出码</h3>\n<blockquote>\n<p>进程退出码（退出状态）可以告诉我们最后⼀次执行的命令的状态。在命令结束以后，我们可以知道命令是成功完成的还是以错误结束的。通常是你程序中mian函数的返回值，其基本思想是，程序返回退出代码 0 时表示执行成功，没有问题。 0 以外的任何代码都被视为不成功。</p>\n</blockquote>\n<p>退出码是一个 8 位无符号整数（8-bit unsigned integer），因此取值范围为 2^8=256 个值。</p>\n<p><strong><code>Linux Shell</code></strong> 中的常见退出码：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/21cab7befcc3476a84fb8c918829a806.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>退出码 0 表示命令执行有误，这是完成命令的理想状态。</li>\n<li>退出码 1 我们也可以将其解释为 “不被允许的操作”。例如在没有 <strong><code>sudo</code></strong> 权限的情况下使用 <strong><code>yum</code></strong>；</li>\n<li>130 （ <strong><code>SIGINT 或 ^C</code></strong> ）和 143 （ <strong><code>SIGTERM</code></strong> ）等终止信号是非常典型的，它们属于 <strong><code>128+n</code></strong> 信号，其中 n 代表信号编号。</li>\n</ul>\n<hr />\n<p><strong>这里需要补充一点：</strong></p>\n<p>进程退出码和错误码是两个完全不同的概念，不要混为一谈！</p>\n<h3><a id=\"_624_659\"></a>{#_624}错误码</h3>\n<blockquote>\n<p>在 Linux 系统中，错误码（<strong><code>Error Codes</code></strong> ）是操作系统用于标识程序运行中遇到的各类问题的核心机制。这些错误码通过全局变量 <strong><code>errno</code></strong> （定义在 <strong><code>&lt;errno.h&gt;</code></strong> 头文件中）传递，帮助开发者快速定位和调试问题。</p>\n</blockquote>\n<p>要理解错误码，首先要认识全局变量 <strong><code>error</code></strong></p>\n<p>例如：fork函数调用失败后，会立刻返回-1，并设置全局变量 <strong><code>error</code></strong></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/08b99043e9ca463d9d0b960ccada77e0.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>定义：<strong><code>errno</code></strong> 是一个线程安全的整型变量，用于存储最近一次系统调用或库函数调用失败的错误码。</li>\n</ul>\n<p>特性：</p>\n<ul>\n<li>成功调用不会重置 errno，因此必须在调用后立即检查其值。</li>\n<li>每个线程有独立的 errno 副本（多线程安全）。</li>\n</ul>\n<p>头文件：</p>\n<pre><code class=\"lang-prism\">#include &lt;errno.h&gt;\n</code></pre>\n<p>与之对应的是 <strong><code>strerror</code></strong> 函数，该函数可以将对应的错误码转化成字符串描述的错误信息打印出来，方便程序员调试代码。</p>\n<p>实际上，我们可以通过 <strong><code>for</code></strong> 循环来打印查看Linux系统下所有的错误码以及其错误信息：</p>\n<pre><code class=\"lang-prism\">int main()\n{\n    for (int i = 0; i &lt; 135; ++i)\n    {\n        printf(&quot;%d-&gt; %s\\n&quot;, i, strerror(i));\n    }\n    return 0;\n}\n</code></pre>\n<p><strong>不难看出，在Linux系统下，一共有 <code>0 ~ 133</code> 总共<code>134</code>个错误码，其中 <code>0</code> 表示 <code>success</code> ，即程序运行成功， <code>1 ~ 133</code> 则分别对应一个错误信息。</strong></p>\n<pre><code class=\"lang-prism\">0-&gt; Success\n1-&gt; Operation not permitted\n2-&gt; No such file or directory\n3-&gt; No such process\n4-&gt; Interrupted system call\n5-&gt; Input/output error\n6-&gt; No such device or address\n7-&gt; Argument list too long\n8-&gt; Exec format error\n9-&gt; Bad file descriptor\n10-&gt; No child processes\n11-&gt; Resource temporarily unavailable\n12-&gt; Cannot allocate memory\n13-&gt; Permission denied\n14-&gt; Bad address\n15-&gt; Block device required\n16-&gt; Device or resource busy\n17-&gt; File exists\n18-&gt; Invalid cross-device link\n19-&gt; No such device\n20-&gt; Not a directory\n21-&gt; Is a directory\n22-&gt; Invalid argument\n23-&gt; Too many open files in system\n24-&gt; Too many open files\n25-&gt; Inappropriate ioctl for device\n26-&gt; Text file busy\n27-&gt; File too large\n28-&gt; No space left on device\n29-&gt; Illegal seek\n30-&gt; Read-only file system\n31-&gt; Too many links\n32-&gt; Broken pipe\n33-&gt; Numerical argument out of domain\n34-&gt; Numerical result out of range\n35-&gt; Resource deadlock avoided\n36-&gt; File name too long\n37-&gt; No locks available\n38-&gt; Function not implemented\n39-&gt; Directory not empty\n40-&gt; Too many levels of symbolic links\n41-&gt; Unknown error 41\n42-&gt; No message of desired type\n43-&gt; Identifier removed\n44-&gt; Channel number out of range\n45-&gt; Level 2 not synchronized\n46-&gt; Level 3 halted\n47-&gt; Level 3 reset\n48-&gt; Link number out of range\n49-&gt; Protocol driver not attached\n50-&gt; No CSI structure available\n51-&gt; Level 2 halted\n52-&gt; Invalid exchange\n53-&gt; Invalid request descriptor\n54-&gt; Exchange full\n55-&gt; No anode\n56-&gt; Invalid request code\n57-&gt; Invalid slot\n58-&gt; Unknown error 58\n59-&gt; Bad font file format\n60-&gt; Device not a stream\n61-&gt; No data available\n62-&gt; Timer expired\n63-&gt; Out of streams resources\n64-&gt; Machine is not on the network\n65-&gt; Package not installed\n66-&gt; Object is remote\n67-&gt; Link has been severed\n68-&gt; Advertise error\n69-&gt; Srmount error\n70-&gt; Communication error on send\n71-&gt; Protocol error\n72-&gt; Multihop attempted\n73-&gt; RFS specific error\n74-&gt; Bad message\n75-&gt; Value too large for defined data type\n76-&gt; Name not unique on network\n77-&gt; File descriptor in bad state\n78-&gt; Remote address changed\n79-&gt; Can not access a needed shared library\n80-&gt; Accessing a corrupted shared library\n81-&gt; .lib section in a.out corrupted\n82-&gt; Attempting to link in too many shared libraries\n83-&gt; Cannot exec a shared library directly\n84-&gt; Invalid or incomplete multibyte or wide character\n85-&gt; Interrupted system call should be restarted\n86-&gt; Streams pipe error\n87-&gt; Too many users\n88-&gt; Socket operation on non-socket\n89-&gt; Destination address required\n90-&gt; Message too long\n91-&gt; Protocol wrong type for socket\n92-&gt; Protocol not available\n93-&gt; Protocol not supported\n94-&gt; Socket type not supported\n95-&gt; Operation not supported\n96-&gt; Protocol family not supported\n97-&gt; Address family not supported by protocol\n98-&gt; Address already in use\n99-&gt; Cannot assign requested address\n100-&gt; Network is down\n101-&gt; Network is unreachable\n102-&gt; Network dropped connection on reset\n103-&gt; Software caused connection abort\n104-&gt; Connection reset by peer\n105-&gt; No buffer space available\n106-&gt; Transport endpoint is already connected\n107-&gt; Transport endpoint is not connected\n108-&gt; Cannot send after transport endpoint shutdown\n109-&gt; Too many references: cannot splice\n110-&gt; Connection timed out\n111-&gt; Connection refused\n112-&gt; Host is down\n113-&gt; No route to host\n114-&gt; Operation already in progress\n115-&gt; Operation now in progress\n116-&gt; Stale file handle\n117-&gt; Structure needs cleaning\n118-&gt; Not a XENIX named type file\n119-&gt; No XENIX semaphores available\n120-&gt; Is a named type file\n121-&gt; Remote I/O error\n122-&gt; Disk quota exceeded\n123-&gt; No medium found\n124-&gt; Wrong medium type\n125-&gt; Operation canceled\n126-&gt; Required key not available\n127-&gt; Key has expired\n128-&gt; Key has been revoked\n129-&gt; Key was rejected by service\n130-&gt; Owner died\n131-&gt; State not recoverable\n132-&gt; Operation not possible due to RF-kill\n133-&gt; Memory page has hardware error\n134-&gt; Unknown error 134\n</code></pre>\n<p><strong>错误码的应用：</strong></p>\n<pre><code class=\"lang-prism\">int main()\n{\n    FILE *fp = fopen(&quot;invalid.txt&quot;, &quot;r&quot;);//以只读方式打开不存在的文件会出错\n    if (fp == NULL)\n    {\n        // 使用 strerror 获取错误描述\n        printf(&quot;%d-&gt;%s\\n&quot;, errno,strerror(errno));            \n        return 1; //退出码设为1\n    }\n    return 0;\n}\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"lang-prism\">2-&gt;No such file or directory\n</code></pre>\n<p><strong>使用错误码和对应的错误信息可以帮助程序员快速定位错误模块，调试程序，掌握错误码的使用与调试技巧，是提升 Linux 编程效率和系统可靠性的关键。</strong></p>\n<hr />\n<h3><a id=\"_exitexit_832_exitexit_863\"></a>{#_exitexit_832}_exit函数和exit函数</h3>\n<p><strong><code>_exit函数</code></strong></p>\n<blockquote>\n<p>在 Linux 系统中，<strong><code>_exit()</code></strong> 是一个直接终止进程的<strong>系统调用</strong>，它会立即终止当前进程，并通知操作系统回收资源，但不执行任何用户空间的清理操作。</p>\n</blockquote>\n<pre><code class=\"lang-prism\">#include &lt;unistd.h&gt;\nvoid _exit(int status);\n</code></pre>\n<ul>\n<li>参数 <strong><code>status</code></strong> ：进程的退出状态码，范围是 <strong><code>0~255</code></strong> 。父进程可以通过 <strong><code>wait()</code></strong> 或 <strong><code>waitpid()</code></strong> 获取该状态码。</li>\n<li>返回值：无（进程直接终止，不会返回调用者）。</li>\n</ul>\n<p>当前进程调用 <strong><code>_exit()</code></strong> 后，操作系统会立即介入，会从用户态陷入内核态，执行以下操作：</p>\n<ul>\n<li>关闭所有文件描述符：内核会关闭进程打开的文件、套接字、管道等资源，但不会刷新标准 I/O 库（如 <strong><code>stdio</code></strong>）的缓冲区。</li>\n<li>释放用户空间内存：回收进程的代码段、数据段、堆、栈等内存资源。</li>\n<li>发送 <strong><code>SIGCHLD</code></strong> 信号： 通知父进程子进程已终止，并传递退出状态码 <strong><code>status</code></strong>。</li>\n<li>终止进程：进程的状态变为 <strong><code>ZOMBIE</code></strong> （僵尸进程），直到父进程通过 <strong><code>wait()</code></strong> 回收其资源。</li>\n</ul>\n<p>本质上，<strong><code>_exit()</code></strong> 最终会调用 Linux 内核的 <strong><code>exit_group</code></strong> 系统调用（<strong><code>sys_exit_group</code></strong>），终止整个进程及其所有线程。其内核处理流程如下：</p>\n<p>释放进程资源：</p>\n<ul>\n<li>关闭所有文件描述符。</li>\n<li>释放内存映射（mmap）和虚拟内存区域。</li>\n<li>解除信号处理程序绑定。</li>\n</ul>\n<p>更新进程状态：</p>\n<ul>\n<li>将进程状态设为 <strong><code>TASK_DEAD</code></strong></li>\n<li>向父进程发送 <strong><code>SIGCHLD</code></strong> 信号。</li>\n</ul>\n<p>调度器介入：</p>\n<ul>\n<li>从运行队列中移除进程。</li>\n<li>切换到下一个进程执行。</li>\n</ul>\n<hr />\n<p><strong><code>exit函数</code></strong></p>\n<blockquote>\n<p>在 C/C++ 语言中，<strong><code>exit</code></strong> 是一个用于正常终止程序执行的<strong>标准库函数</strong>。它会执行一系列清理操作后终止进程，并将控制权交还给操作系统。</p>\n</blockquote>\n<pre><code class=\"lang-prism\">#include &lt;stdlib.h&gt;\nvoid exit(int status);  // C \n\n#include &lt;cstdlib&gt;\nvoid exit(int status);  // C++ \n</code></pre>\n<ul>\n<li>参数 <strong><code>status</code></strong> ：进程的退出状态码，范围 <strong><code>0~255</code></strong>（0 通常表示成功，非零表示异常）。</li>\n<li>返回值：无（进程终止，不会返回调用者）。</li>\n</ul>\n<p>进程调用 <strong>exit</strong> 时，按以下顺序执行操作：</p>\n<ol>\n<li>调用 <strong><code>atexit</code></strong> 注册的函数：按注册的逆序执行所有通过 <strong><code>atexit</code></strong> 或<br />\n<strong><code>at_quick_exit</code></strong>（若使用quick_exit）注册的函数。</li>\n<li>刷新所有标准 I/O 缓冲区：清空 <strong><code>stdout</code></strong> 、<strong><code>stderr</code></strong> 等流的缓冲区。 <strong>注意：</strong> <strong>stderr</strong> 默认无缓冲，<strong>stdout</strong> 在交互式设备上是行缓冲。</li>\n<li>关闭所有打开的文件流：调用 <strong><code>fclose</code></strong> 关闭所有通过 <strong><code>fopen</code></strong> 打开的文件。 注意：不会关闭底层文件描述符（需手动 <strong><code>close</code></strong>）。</li>\n<li>删除临时文件：删除由 <strong><code>tmpfile</code></strong> 创建的临时文件。</li>\n<li>终止进程：向操作系统返回状态码 <strong><code>status</code></strong> 。父进程可通过 <strong><code>wait</code></strong> 或 <strong><code>waitpid</code></strong> 获取该状态码。</li>\n</ol>\n<hr />\n<p><strong>其实本质上，exit 是一个标准库函数，最后也会调用_exit,但是在这之前，exit还做了其他的清理工作：</strong></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/a6e4a33b99b34cc2aec360b4a48cf19d.png\" alt=\"在这里插入图片描述\" /></p>\n<p>我们举个例子，帮大家直观的感受一下这两者的区别：</p>\n<p><strong>示例一：使用 exit 函数</strong></p>\n<pre><code class=\"lang-prism\">int main()\n{\n    printf(&quot;hello&quot;);\n    exit(0);\n}\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"lang-prism\">[root@localhost linux]# ./a.out\nhello[root@localhost linux]#\n</code></pre>\n<p><strong>示例二：使用 _exit 函数</strong></p>\n<pre><code class=\"lang-prism\">int main()\n{\n    printf(&quot;hello&quot;);\n    _exit(0);\n}\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"lang-prism\">[root@localhost linux]# ./a.out\n[root@localhost linux]#\n</code></pre>\n<blockquote>\n<p>聪明的同学很快就知道了，我们通过 <strong><code>printf</code></strong> 打印 “hello” 并没有加上换行符，所以&quot;hello&quot;<br />\n在缓冲区内没有被立即刷新，所以当我们使用exit终止进程时，exit会帮我们做相应的清理工作，包括刷新I/O缓冲区。而调用_exit时则不会刷新，进程直接退出。</p>\n</blockquote>\n<h3><a id=\"return__944return__971\"></a>{#return__944}return 退出</h3>\n<blockquote>\n<p>return是⼀种更常见的进程退出方法。执行 <strong><code>return n</code></strong> 等同于执行 <strong><code>exit(n)</code></strong>,因为调用main的运行时函数会将main函数的返回值当做 exit 的参数。</p>\n</blockquote>\n<p>状态码传递：</p>\n<p>main函数中的 <strong><code>return</code></strong> 语句返回一个整数值（通常称为退出状态码），表示程序的执行结果：</p>\n<ul>\n<li>0：表示程序成功执行。</li>\n<li>非0：表示程序异常终止（具体数值由程序员定义）。</li>\n</ul>\n<p><strong>return与exit()的关系</strong></p>\n<p>隐式调用exit()：</p>\n<ul>\n<li>在 main 函数中使用 return 时，C/C++运行时会自动调用 exit() 函数，并将返回值作为参数传递给它。</li>\n</ul>\n<pre><code class=\"lang-prism\">int main()\n{\n    return 42;  // 等价于 exit(42);\n}\n</code></pre>\n<p><strong>return的执行流程</strong></p>\n<p>当在main函数中执行return时，程序会做以下几件事：</p>\n<ul>\n<li>返回值传递：将返回值传递给运行时环境。</li>\n</ul>\n<p>清理操作：</p>\n<ul>\n<li>调用局部对象的析构函数（按照创建顺序的逆序）。</li>\n<li>调用全局对象的析构函数（同样逆序）。</li>\n</ul>\n<p>调用exit()：运行时调用exit()，执行以下操作：</p>\n<ul>\n<li>刷新所有I/O缓冲区（如 <strong><code>std::cout</code></strong>）。</li>\n<li>关闭通过 <strong><code>fopen</code></strong> 打开的文件流。</li>\n<li>执行通过 <strong><code>atexit()</code></strong> 注册的函数。</li>\n</ul>\n<p>终止进程：将控制权交还给操作系统。</p>\n<p><strong>值得注意的一点是：在非main函数的其他函数中使用 return 仅退出当前函数，返回到调用者，不会终止进程。</strong></p>\n<hr />\n<h3><a id=\"_exitexit__return__989_exitexit__return__1018\"></a>{#_exitexit__return__989}<code>_exit</code>、<code>exit</code> 和 <code>return</code> 对比</h3>\n<p><strong>以下是一个详细的表格供大家理解参考</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>_exit() (系统调用)</th>\n<th>exit() (标准库函数)</th>\n<th>return (在 main 中)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>所属标准</td>\n<td>POSIX 系统调用</td>\n<td>C/C++ 标准库函数</td>\n<td>C/C++ 语言关键字</td>\n</tr>\n<tr>\n<td>头文件</td>\n<td><code>&lt;unistd.h&gt;</code></td>\n<td><code>&lt;stdlib.h&gt;</code>（C）、<code>&lt;cstdlib&gt;</code>（C++）</td>\n<td>无（语言内置）</td>\n</tr>\n<tr>\n<td>执行流程</td>\n<td>立即终止进程，不执行任何用户空间清理。</td>\n<td>1. 调用 atexit 注册的函数 2. 刷新 I/O 缓冲区 3. 关闭文件流</td>\n<td>1. 调用 C++ 局部对象析构函数 2. 隐式调用 exit() 完成后续清理</td>\n</tr>\n<tr>\n<td>清理操作</td>\n<td>内核自动回收进程资源（内存、文件描述符），不刷新缓冲区、不调用析构函数</td>\n<td>清理标准库资源（刷新缓冲区、关闭文件流），但不调用 C++ 局部对象析构函数</td>\n<td>调用 C++ 局部和全局对象析构函数，并触发 exit() 的清理逻辑</td>\n</tr>\n<tr>\n<td>多线程行为</td>\n<td>立即终止所有线程，可能导致资源泄漏</td>\n<td>终止整个进程，但可能跳过部分线程资源释放（如线程局部存储）</td>\n<td>同 exit()，但在 C++ 中会正确析构主线程的局部对象</td>\n</tr>\n<tr>\n<td>C++ 析构函数调用</td>\n<td>❌ 不调用任何对象的析构函数（包括全局对象）</td>\n<td>❌ 不调用局部对象析构函数 ✅ 调用全局对象析构函数（C++）</td>\n<td>✅ 调用局部和全局对象析构函数（C++）</td>\n</tr>\n<tr>\n<td>缓冲区处理</td>\n<td>❌ 不刷新 stdio 缓冲区（如 printf 的输出可能丢失）</td>\n<td>✅ 刷新所有 stdio 缓冲区</td>\n<td>✅ 通过隐式调用 exit() 刷新缓冲区</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>1. 子进程退出（避免重复刷新缓冲区） 2. 需要立即终止进程（绕过清理逻辑）</td>\n<td>1. 非 main 函数的程序终止 2. 需要执行注册的清理函数（如日志收尾）</td>\n<td>1. 在 main 函数中正常退出 2. 需要确保 C++ 对象析构（RAII 资源管理）</td>\n</tr>\n<tr>\n<td>错误处理</td>\n<td>直接传递状态码给操作系统，无错误反馈机制</td>\n<td>可通过 atexit 注册错误处理函数，但无法捕获局部对象析构异常</td>\n<td>可通过 C++ 异常机制处理错误（需在 main 中捕获）</td>\n</tr>\n<tr>\n<td>信号安全</td>\n<td>✅ 可在信号处理函数中安全调用（如 SIGINT）</td>\n<td>❌ 不可在信号处理函数中调用（可能死锁）</td>\n<td>❌ 不可在信号处理函数中使用（仅限 main 函数流程）</td>\n</tr>\n<tr>\n<td>资源泄漏风险</td>\n<td>高（临时文件、未释放的手动内存等需内核回收）</td>\n<td>中（未关闭的文件描述符、手动内存需提前处理）</td>\n<td>低（依赖 RAII 自动释放资源）</td>\n</tr>\n<tr>\n<td>底层实现</td>\n<td>直接调用内核的 exit_group 系统调用</td>\n<td>调用 C 标准库的清理逻辑后，最终调用 _exit()</td>\n<td>编译器生成代码调用析构函数，并跳转到 main 结尾触发 exit()</td>\n</tr>\n</tbody>\n</table>\n<p>最后总结下：</p>\n<ul>\n<li><strong><code>_exit()</code></strong>：最底层的终止方式，适合需要绕过所有用户空间清理的场景（如子进程退出）。</li>\n<li><strong><code>exit()</code></strong>：平衡安全与效率，适合非 main 函数的程序终止，但需注意 C++ 对象析构问题。</li>\n<li><strong><code>return</code></strong>：C++ 中最安全的退出方式，优先在 main 函数中使用，确保资源自动释放。</li>\n</ul>\n<hr />\n<h2><a id=\"_1019_1045\"></a>{#_1019}写在最后</h2>\n<p>本文到这里就结束了，后面的文章我们会展开讲解有关 Linux操作系统的更多话题，带你从新手小白 成长为一名 Linux 糕手， 感谢您的观看！</p>\n<blockquote>\n<p>如果你觉得这篇文章对你有所帮助，请为我的博客 点赞👍收藏⭐️ 评论💬或 分享🔗 支持一下！你的每一个支持都是我继续创作的动力✨！🙏<br />\n如果你有任何问题或想法，也欢迎 留言💬 交流，一起进步📚！❤️ 感谢你的阅读和支持🌟！🎉<br />\n祝各位大佬吃得饱🍖，睡得好🛌，日有所得📈，逐梦扬帆⛵！</p>\n</blockquote>\n', '> 欢迎来到一整颗红豆的博客✨，一个关于探索技术的角落，记录学习的点滴📖，分享实用的技巧🛠️，偶尔还有一些奇思妙想💡  \n> 本文由一整颗红豆原创✍️，感谢支持❤️！请尊重原创📩！欢迎评论区留言交流🌟  \n> 个人主页 👉 [一整颗红豆](https://blog.csdn.net/bite_zwy?spm=1000.2115.3001.5343)  \n> 本文专栏➡️[Linux驾驭之道 掌控操作系统的艺术与哲学](https://blog.csdn.net/bite_zwy/category_12860166.html)\n\n\n<br />\n\n#### 生生不息：起于鸿蒙，守若空谷，归于太虚\n\n* [进程创建](#_11)\n*\n  * [再识fork函数](#fork_12)\n  * [fork函数返回值](#fork_81)\n  * [写时拷贝 \\`Copy-On-Write\\`](#_CopyOnWrite_123)\n* [进程等待](#_168)\n*\n  * [进程等待的方法](#_183)\n  *\n    * [\\`wait\\`](#wait_185)\n    * [\\`waitpid\\`](#waitpid_205)\n  * [获取子进程 status](#_status_247)\n  * [阻塞等待与非阻塞等待](#_389)\n  *\n    * [阻塞等待（\\`Blocking Wait\\`）](#Blocking_Wait_393)\n    * [非阻塞等待（\\`Non-blocking Wait\\`）](#Nonblocking_Wait_424)\n* [进程终止](#_484)\n*\n  * [进程退出场景](#_491)\n  * [进程退出码](#_604)\n  * [错误码](#_624)\n  * [_exit函数和exit函数](#_exitexit_832)\n  * [return 退出](#return__944)\n  * [\\`_exit\\`、\\`exit\\` 和 \\`return\\` 对比](#_exitexit__return__989)\n* [写在最后](#_1019)\n\n<br />\n\n{#_11}进程创建 {#content_views}\n---------------------------\n\n### {#fork_12}再识fork函数\n\n> 之前在 [Linux进程状态](https://blog.csdn.net/bite_zwy/article/details/145863781?spm=1001.2014.3001.5501) 这篇文章中，我们已经为大家介绍过Linux系统中一个非常重要的系统调用 --- **`fork`** ，今天我们在来重谈 **`fork`** 函数，让大家对这个系统调用有更深刻的理解。\n\n在 Linux中 **`fork`** 函数是非常重要的函数，它从已存在进程中创建⼀个新进程。创建出来的新进程叫做子进程，而原进程则称为父进程。\n\n在Linux参考手册中，fork函数的原型如下：（`man 2 fork` 指令查看）\n\n```prism language-bash\nNAME\n       fork - create a child process\n\nSYNOPSIS\n       #include <sys/types.h>\n       #include <unistd.h>\n\n       pid_t fork(void);\n```\n\n如上不难看出：\n\n* **`fork`** 函数的功能是创建一个子进程\n* 头文件有 **`<sys/types.h>`** 和 **`<unistd.h>`**\n* 参数为 **`void`** ，返回值为 **`pid_t`** (实际上是Linux内核中typedef出来的一个类型)\n\n*** ** * ** ***\n\n进程调用 fork，当控制转移到内核中的 fork 代码后，内核做如下几件事：\n\n* 分配新的内存块和内核数据结构给子进程\n* 将父进程部分数据结构内容拷贝至子进程\n* 添加子进程到系统进程列表当中\n* fork返回，开始调度器调度\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b0da0e26c11b454b934fbdf009216003.png)\n\n当⼀个进程调用fork之后，就有两个⼆进制代码相同的进程。并且它们都运行到相同的地方。但每个进程都将可以开始属于它们自己的旅程，看如下程序：\n\n```prism language-c\nint main(void)\n{\n    pid_t pid;\n    printf(\"Before: pid is %d\\n\", getpid());\n    if ((pid = fork()) == -1)\n        perror(\"fork()\"), exit(1);\n    printf(\"After:pid is %d, fork return %d\\n\", getpid(), pid);\n    sleep(1);\n    return 0;\n}\n```\n\n输出：\n\n```prism language-bash\nBefore: pid is 40176\nAfter:pid is 40176, fork return 40177\nAfter:pid is 40177, fork return 0\n```\n\n*** ** * ** ***\n\n> 这里看到了三行输出，⼀行before，两行after。其中 40176就是父进程啦，40177就是子进程。进程40176先打印before消息，然后它有打印after。另⼀个after消息是进程40177打印的。注意到进程40177没有打印before，为什么呢？\n\n如下图所示：\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8ebde01960aa4fb98e450fe488d4f5b0.png)\n> 当父进程执行到fork创建出子进程时，已经执行了上面的before代码，而创建出子进程后，子进程不会去执行父进程已经执行过的代码，而是和父进程一同执行fork之后的代码。这就是为什么子进程没有打印before的原因\n\n**所以，fork之前父进程独立执行，fork之后，父子进程两个执行流分别执行之后的代码。`值得注意的是，fork之后，谁先执行完全由调度器决定，并没有明确的先后关系！`**\n\n*** ** * ** ***\n\n### {#fork_81}fork函数返回值\n\n> 类型定义：fork() 返回 **`pid_t`** 类型（通常为 int 通过 typedef 定义），用于表示进程ID（PID）。\n\n**`fork`创建成功：**\n\n* 子进程返回0\n* 父进程返回的是子进程的 pid\n\n**为什么给父进程返回子进程的pid，这个问题我们之前已经讨论过：**\n> 一个父进程可以创建一个或者多个子进程，父进程需要通过返回值获得新创建的子进程的唯一标识符（正整数），从而可以管理创建的多个子进程（如发送信号、等待终止等）\n\n**为什么子进程返回0**\n> 子进程返回0，标识自己为子进程，子进程通过返回值 0 确认自己的身份。子进程无需知晓父进程的PID（实际上可以通过 **`getppid()`** 获取）\n\n*** ** * ** ***\n\n**`fork`创建失败：**\n\n返回 -1并设置错误码：\n\n* 当系统资源不足（如进程数超限、内存耗尽）时，fork() 失败。\n\n错误码：\n\n* 需检查 errno 确定具体原因\n\n```prism language-c\nif (pid == -1) {\n    perror(\"fork failed\"); // 输出类似 \"fork failed: Resource temporarily unavailable\"\n}\n```\n\n常见错误码：\n\n* **`EAGAIN`**：进程数超过限制（RLIMIT_NPROC）或内存不足。\n* **`ENOMEM`**：内核无法分配必要数据结构所需内存。\n\n*** ** * ** ***\n\n### {#_CopyOnWrite_123}写时拷贝 `Copy-On-Write`\n\n> 写时拷贝（COW）是 Linux 中 fork() 系统调用的核心优化机制，它使得进程创建变得高效且资源友好，通常，父子代码共享，父子再不写入时，数据也是共享的，当任意一方试图写入，便以写时拷贝的方式各自⼀份副本。\n\n**为什么需要写时拷贝？**\n\n在传统的进程创建方式中，fork() 会直接复制父进程的所有内存空间给子进程。这种方式存在明显问题：\n\n* 内存浪费：如果父进程占用 1GB 内存，子进程即使不修改任何数据，也会立即消耗额外 1GB 内存。\n* 性能低下：复制大量内存需要时间，尤其是对大型进程而言，fork() 会显著延迟程序运行。\n\nCOW 的解决思路：\n\n* 推迟实际的内存复制，直到父子进程中某一方尝试修改内存页时，才进行真正的拷贝。在此之前，父子进程共享同一份物理内存。\n\n具体见下图:\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8833d10b92034fe8bc0b2d3232ea0329.png)\n\n因为有写时拷贝技术的存在,所以父子进程得以彻底分离！完成了进程独立性的技术保证! 写时拷贝,是⼀种延时申请技术,可以提高整机内存的使用率。\n\n**写时拷贝的工作流程**\n\n1、 fork() 调用时\n\n* 共享内存页：内核仅为子进程创建虚拟内存结构（页表），但物理内存页仍与父进程共享。\n* 标记为只读：内核将共享的物理内存页标记为只读（即使父进程原本可写）。\n\n2、进程尝试写入内存\n\n* 触发页错误：当父进程或子进程尝试修改某个共享内存页时，由于页被标记为只读，CPU 会触发页错误（**`Page Fault`**）。\n\n内核介入处理：操作系统会由用户态陷入内核态处理异常\n\n* 分配新的物理内存页，复制原页内容到新页。\n* 修改触发写入的进程的页表，使其指向新页。\n* 将新页标记为可写，恢复进程执行。\n\n3、后续操作\n\n* 修改后的进程独享新内存页，另一进程仍使用原页。\n* 未修改的内存页继续共享，不做复制，操作系统不做任何无意义的事情。\n\n*** ** * ** ***\n\n{#_168}进程等待\n-----------\n\n之前我们在讲进程概念的时候讲过，如果父进程创建出子进程后，如果子进程已经退出，父进程却没有对子进程回收，那么就子进程就会变成 **\"僵尸进程\"** ，造成内存泄露等问题。\n> 在Linux系统中，进程等待是父进程通过系统调用等待子进程终止并获取其退出状态的过程，主要目的是避免僵尸进程并回收子进程资源。\n\n**进程等待的必要性**\n\n**僵尸进程问题：**\n\n* 子进程终止后，其退出状态会保留在进程表中，直到父进程读取。若父进程未处理，子进程将保持僵尸状态（**`Zombie`**），占用系统资源。\n* 状态收集：父进程需知晓子进程的执行结果（成功、错误代码、信号终止等）。\n* 资源回收：内核释放子进程占用的内存、文件描述符等资源。\n\n### {#_183}进程等待的方法\n\n#### {#wait_185}`wait`\n\n```prism language-cpp\n#include<sys/types.h>\n#include<sys/wait.h>\npid_t wait(int* status);\n```\n\n具体功能：\n\n* 阻塞父进程，直到等待到任意一个子进程终止。\n\n参数：\n\n* **`status`** ：输出型参数，用来存储子进程退出状态的指针（可为 **`NULL`**，表示不关心状态）。\n\n返回值：\n\n* 成功：返回终止的子进程PID。失败：返回-1（如无子进程）。\n\n*** ** * ** ***\n\n#### {#waitpid_205}`waitpid`\n\n```prism language-cpp\n#include <sys/wait.h>\npid_t waitpid(pid_t pid, int *status, int options);\n```\n\n* 功能：更灵活的等待方式，可指定子进程或非阻塞等待模式。\n\n参数：\n\n**`pid：`**\n\n* **`>0`**：等待指定 PID 的子进程。\n* **`-1`**：等待任意子进程（等效于 wait）。\n* **`0`**：等待同一进程组的子进程。\n\n**`status`** ：同 **wait**，输出型参数，表明子进程的退出状态。\n\n**`options`：** 默认为0，表示阻塞等待\n\n* **`WNOHANG`**：非阻塞模式，无子进程终止时立即返回 0。\n* **`WUNTRACED`**：报告已停止的子进程（如被信号暂停）。\n\n返回值：\n\n* 成功：返回子进程PID。\n* **`WNOHANG`** 且无子进程终止：返回0。\n* 失败：返回-1。\n\n**做个总结：**\n\n* 如果子进程已经退出，调用 **wait / waitpid** 时，**wait / waitpid** 会立即返回，并且释放资源，获得子进程退出信息。\n* 如果在任意时刻调用 **wait / waitpid**，子进程存在且正常运行，则进程可能阻塞。 如果不存在该子进程，则立即出错返回。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a0412fcc88f24cfc9f5e9a38f4278147.png)\n\n*** ** * ** ***\n\n### {#_status_247}获取子进程 status\n\n**`wait`** 和 **`waitpid`** ，都有⼀个 **`status`** 参数，该参数是⼀个输出型参数，由操作系统填充。\n\n* 如果传递 **`NULL`**，表示不关心子进程的退出状态信息。\n* 否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程。\n\n**`status`** 不能简单的当作整形来看待，可以当作位图来看待，具体细节如下图  \n（只研究 status 低16比特位）：\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f8291ebf08c043cc8e5c7fe6a840148b.png)\n\n*** ** * ** ***\n\n如何理解呢？  \n子进程的退出分为两种情况：\n\n1. 正常终止\n\n高 8 位（第 8 \\~ 15 位）：保存子进程的退出状态（退出码）（即 **`exit(code)`** 或 **`return code`** 中的 **`code`** 值）。\n\n第 7 位：通常为 0，表示正常终止。\n\n示例：\n\n若子进程调用 exit(5)，表明子进程是正常退出，则 status 的高 8 位为 00000101（即十进制 5）。\n\n2. 被信号所杀导致终止\n\n低 7 位（第 0 \\~ 6 位）：保存导致子进程终止的信号编号。\n\n第 7 位：若为 1，表示子进程在终止时生成了 **`core dump`** 文件（用于调试）。有关 **`core dump`** 文件，后面会讲，大家这里先了解一下即可。\n\n第 8 \\~ 15 位：未使用（通常为 0）。\n\n示例：\n\n若子进程因 **`SIGKILL`**（信号编号 9）终止，则 status 的低 7 位为 0001001（即十进制 9）。\n\n* **做个小总结：**\n\n```prism language-bash\n低 16 位结构：\n| 15 14 13 12 11 10 9 8 | 7 | 6 5 4 3 2 1 0 |\n---------------------------------------------\n正常终止 → [ 退出状态（高8位） ]  0  [ 未使用 ]\n被信号终止 → [   未使用（全0）   ] c  [ 信号编号 ]\n```\n\n*** ** * ** ***\n\n**如何解析 status？**\n> 难道真的需要我们将 status 当作位图，使用位操作来提取子进程的退出信息吗？  \n> 这么做对我们程序员来说当然小菜一碟，不过有点多余了，没必要。Linux系统为我们定义了多种宏用来提取 status，方便且专业。\n\n**使用宏定义检查 status 的值：**\n\n|          宏          |                       功能                       |\n|---------------------|------------------------------------------------|\n| WIFEXITED(status)   | 若子进程正常终止（exit 或 return）返回真。                    |\n| WEXITSTATUS(status) | 若 WIFEXITED 为真，返回子进程的退出码（exit 的参数或 return 的值）。 |\n| WIFSIGNALED(status) | 若子进程因信号终止返回真。                                  |\n| WTERMSIG(status)    | 若 WIFSIGNALED 为真，返回导致终止的信号编号。                  |\n| WCOREDUMP(status)   | 若子进程生成了核心转储文件返回真。                              |\n\n**常用的两个宏：**\n\n* **`WIFEXITED`**(status): 若为正常终止子进程返回的状态，则为真。（查看进程是 否是正常退出）\n* **`WEXITSTATUS`**(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的 退出码）\n\n示例一：子进程正常退出\n\n```prism language-cpp\nint main()\n{\n    pid_t pid = fork();\n    if (pid == 0)\n    { // 子进程\n        printf(\"子进程运行中... PID=%d\\n\", getpid());\n        // 1. 正常退出：调用 exit(42)\n        exit(42);\n    }\n    else\n    { // 父进程\n        int status;\n        waitpid(pid, &status, 0); // 等待子进程结束\n        if (WIFEXITED(status))\n        { // 正常退出\n            printf(\"子进程正常退出，退出码: %d\\n\", WEXITSTATUS(status));\n        }\n        else if (WIFSIGNALED(status))\n        { // 被信号终止\n            printf(\"子进程被信号终止，信号编号: %d\\n\", WTERMSIG(status));\n        }\n    }\n    return 0;\n}\n```\n\n输出：\n\n```prism language-bash\n子进程运行中... PID=56153\n子进程正常退出，退出码: 42\n```\n\n示例二：子进程被信号终止\n\n```prism language-cpp\nint main()\n{\n    pid_t pid = fork();\n    if (pid == 0)\n    { // 子进程\n        printf(\"子进程运行中... PID=%d\\n\", getpid());\n        int *p = NULL;\n        *p = 100;  // 对空指针解引用，触发 SIGSEGV 被信号终止\n    }\n    else\n    { // 父进程\n        int status;\n        waitpid(pid, &status, 0); // 等待子进程结束\n        if (WIFEXITED(status))\n        { // 正常退出\n            printf(\"子进程正常退出，退出码: %d\\n\", WEXITSTATUS(status));\n        }\n        else if (WIFSIGNALED(status))\n        { // 被信号终止\n            printf(\"子进程被信号终止，信号编号: %d\\n\", WTERMSIG(status));\n        }\n    }\n    return 0;\n}\n```\n\n输出：\n\n```prism language-bash\n子进程运行中... PID=56203\n子进程被信号终止，信号编号: 11\n```\n\n### {#_389}阻塞等待与非阻塞等待\n\n> 在 Unix/Linux 中，父进程通过 wait 或 waitpid 函数等待子进程结束。它们的核心区别在于是否允许父进程在等待子进程时继续执行其他任务。\n\n#### {#Blocking_Wait_393}阻塞等待（`Blocking Wait`）\n\n> 父进程调用 waitpid 后，会一直挂起（阻塞），直到目标子进程终止。在阻塞期间，父进程无法执行其他操作，直到子进程退出。\n\n```prism language-cpp\npid_t waitpid(pid_t pid, int *status, 0);  // options 参数为 0\n```\n\n示例：\n\n```prism language-cpp\nint main()\n{\n    int status;\n    pid_t child_pid = fork();\n    if (child_pid == 0)\n    {\n        // 子进程执行任务\n        exit(10);\n    }\n    else\n    {\n        // 父进程阻塞等待子进程结束\n        waitpid(child_pid, &status, 0);\n        if (WIFEXITED(status))\n        {\n            printf(\"子进程退出码: %d\\n\", WEXITSTATUS(status));\n        }\n    }\n}\n```\n\n#### {#Nonblocking_Wait_424}非阻塞等待（`Non-blocking Wait`）\n\n> 父进程调用 waitpid 时，若子进程未结束，则父进程立即返回，而不是挂起。父进程可以继续执行其他任务，同时定期检查子进程状态。需结合循环实现非阻塞式轮询（`polling`）。\n\n关键选项：宏 **`WNOHANG`** （定义在 **`<sys/wait.h>`** 中）。\n\n```prism language-cpp\npid_t waitpid(pid_t pid, int *status, WNOHANG);\n```\n\n示例：非阻塞轮询方式\n\n```prism language-cpp\nint main()\n{\n    int status;\n    pid_t child_pid = fork();\n    if (child_pid == 0)\n    {\n        sleep(3); // 子进程休眠 3 秒后退出\n        exit(10);\n    }\n    else\n    {\n        while (1)\n        {\n            pid_t ret = waitpid(child_pid, &status, WNOHANG);\n            if (ret == -1)\n            {\n                perror(\"waitpid\");\n                break;\n            }\n            else if (ret == 0)\n            {\n                printf(\"子进程未结束，父进程继续工作...\\n\");\n                sleep(1); // 避免频繁轮询消耗 CPU\n            }\n            else\n            {\n                if (WIFEXITED(status))\n                {\n                    printf(\"子进程退出码: %d\\n\", WEXITSTATUS(status));\n                }\n                break;\n            }\n        }\n    }\n}\n```\n\n**阻塞等待和非阻塞等待的对比：**\n\n|    场景    |     阻塞等待     |     非阻塞等待      |\n|----------|--------------|----------------|\n| 父进程任务优先级 | 必须立即处理子进程结果  | 需同时处理其他任务      |\n| 子进程执行时间  | 较短或确定        | 较长或不确定         |\n| 资源消耗     | CPU 空闲，无额外开销 | 需轮询，可能占用更多 CPU |\n| 典型应用     | 简单脚本、单任务场景   | 多进程管理、事件驱动程序   |\n\n*** ** * ** ***\n\n{#_484}进程终止\n-----------\n\n**`进程= 内核数据结构 + 进程自己的代码和数据`**\n> 进程终止是进程生命周期的最后一个阶段，涉及资源释放、状态通知及父进程回收等关键步骤。进程终止的本质是释放系统资源，就是释放进程申请的相关内核数据结构和对应的代码和数据。\n\n### {#_491}进程退出场景\n\n* **代码运行完毕，结果正确**\n* **代码运行完毕，结果不正确**\n* **代码异常终止**\n\n如何理解这三种进程退出的场景呢？举个例子\n\n**代码运行完毕，结果正确**\n\n* 程序完整执行了所有逻辑，未触发任何错误或异常。\n* 输出结果与预期完全一致，符合功能需求或算法目标。\n\n```prism language-cpp\nint sum(int a, int b)\n{\n    return a + b;\n}\n\nint main()\n{\n    int result = sum(3, 5);\n    printf(\"Result: %d\\n\", result); // 输出 8，结果正确\n    return 0;\n}\n```\n\n**输出：**\n\n```prism language-c\nResult: 8\n```\n\n*** ** * ** ***\n\n**代码运行完毕，结果不正确**\n\n* 程序正常结束（无崩溃或异常），但输出结果与预期不符。\n* 通常由逻辑错误、算法错误或数据处理错误导致。\n\n例如：\n\n```prism language-cpp\n// 错误实现：本应计算阶乘，但初始值错误\nint factorial(int n)\n{\n    int result = 0; // 错误！应为 result = 1\n    for (int i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\n\nint main()\n{\n    printf(\"5! = %d\\n\", factorial(5)); // 输出 0，结果错误\n    return 0;\n}\n```\n\n*** ** * ** ***\n\n**代码未执行完毕，异常终止**\n\n* 程序未执行完毕就中途崩溃或被强制终止。\n* 通常由运行时错误、资源限制或外部信号触发。\n* 比如除零错误，对空指针解引用等异常\n\n**例如**：\n\n```prism language-cpp\nint main()\n{\n    int *ptr = NULL;\n    *ptr = 42;  // 对空指针解引用，触发段错误\n    printf(\"Value: %d\\n\", *ptr);\n    return 0;\n}\n```\n\n**段错误：**\n\n```prism language-bash\nSegmentation fault\n```\n\n**再比如：**\n\n```prism language-cpp\nint main()\n{\n    int a = 10;\n    int b = a / 0; // 程序除零异常\n    printf(\"Value: %d\\n\", b);\n    return 0;\n}\n```\n\n**浮点数异常：**\n\n```prism language-cpp\nFloating point exception\n```\n\n**进程常见退出方法**\n\n正常终止（可以通过 **`echo $?`** 查看进程退出码）\n\n1. 从main返回\n2. 调用exit\n3. _exit\n\n异常退出：\n\n1. **`ctrl + c`**，信号终止\n\n*** ** * ** ***\n\n### {#_604}进程退出码\n\n> 进程退出码（退出状态）可以告诉我们最后⼀次执行的命令的状态。在命令结束以后，我们可以知道命令是成功完成的还是以错误结束的。通常是你程序中mian函数的返回值，其基本思想是，程序返回退出代码 0 时表示执行成功，没有问题。 0 以外的任何代码都被视为不成功。\n\n退出码是一个 8 位无符号整数（8-bit unsigned integer），因此取值范围为 2\\^8=256 个值。\n\n**`Linux Shell`** 中的常见退出码：\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/21cab7befcc3476a84fb8c918829a806.png)\n\n* 退出码 0 表示命令执行有误，这是完成命令的理想状态。\n* 退出码 1 我们也可以将其解释为 \"不被允许的操作\"。例如在没有 **`sudo`** 权限的情况下使用 **`yum`**；\n* 130 （ **`SIGINT 或 ^C`** ）和 143 （ **`SIGTERM`** ）等终止信号是非常典型的，它们属于 **`128+n`** 信号，其中 n 代表信号编号。\n\n*** ** * ** ***\n\n**这里需要补充一点：**\n\n进程退出码和错误码是两个完全不同的概念，不要混为一谈！\n\n### {#_624}错误码\n\n> 在 Linux 系统中，错误码（**`Error Codes`** ）是操作系统用于标识程序运行中遇到的各类问题的核心机制。这些错误码通过全局变量 **`errno`** （定义在 **`<errno.h>`** 头文件中）传递，帮助开发者快速定位和调试问题。\n\n要理解错误码，首先要认识全局变量 **`error`**\n\n例如：fork函数调用失败后，会立刻返回-1，并设置全局变量 **`error`**\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/08b99043e9ca463d9d0b960ccada77e0.png)\n\n* 定义：**`errno`** 是一个线程安全的整型变量，用于存储最近一次系统调用或库函数调用失败的错误码。\n\n特性：\n\n* 成功调用不会重置 errno，因此必须在调用后立即检查其值。\n* 每个线程有独立的 errno 副本（多线程安全）。\n\n头文件：\n\n```prism language-cpp\n#include <errno.h>\n```\n\n与之对应的是 **`strerror`** 函数，该函数可以将对应的错误码转化成字符串描述的错误信息打印出来，方便程序员调试代码。\n\n实际上，我们可以通过 **`for`** 循环来打印查看Linux系统下所有的错误码以及其错误信息：\n\n```prism language-cpp\nint main()\n{\n    for (int i = 0; i < 135; ++i)\n    {\n        printf(\"%d-> %s\\n\", i, strerror(i));\n    }\n    return 0;\n}\n```\n\n**不难看出，在Linux系统下，一共有 `0 ~ 133` 总共`134`个错误码，其中 `0` 表示 `success` ，即程序运行成功， `1 ~ 133` 则分别对应一个错误信息。**\n\n```prism language-cpp\n0-> Success\n1-> Operation not permitted\n2-> No such file or directory\n3-> No such process\n4-> Interrupted system call\n5-> Input/output error\n6-> No such device or address\n7-> Argument list too long\n8-> Exec format error\n9-> Bad file descriptor\n10-> No child processes\n11-> Resource temporarily unavailable\n12-> Cannot allocate memory\n13-> Permission denied\n14-> Bad address\n15-> Block device required\n16-> Device or resource busy\n17-> File exists\n18-> Invalid cross-device link\n19-> No such device\n20-> Not a directory\n21-> Is a directory\n22-> Invalid argument\n23-> Too many open files in system\n24-> Too many open files\n25-> Inappropriate ioctl for device\n26-> Text file busy\n27-> File too large\n28-> No space left on device\n29-> Illegal seek\n30-> Read-only file system\n31-> Too many links\n32-> Broken pipe\n33-> Numerical argument out of domain\n34-> Numerical result out of range\n35-> Resource deadlock avoided\n36-> File name too long\n37-> No locks available\n38-> Function not implemented\n39-> Directory not empty\n40-> Too many levels of symbolic links\n41-> Unknown error 41\n42-> No message of desired type\n43-> Identifier removed\n44-> Channel number out of range\n45-> Level 2 not synchronized\n46-> Level 3 halted\n47-> Level 3 reset\n48-> Link number out of range\n49-> Protocol driver not attached\n50-> No CSI structure available\n51-> Level 2 halted\n52-> Invalid exchange\n53-> Invalid request descriptor\n54-> Exchange full\n55-> No anode\n56-> Invalid request code\n57-> Invalid slot\n58-> Unknown error 58\n59-> Bad font file format\n60-> Device not a stream\n61-> No data available\n62-> Timer expired\n63-> Out of streams resources\n64-> Machine is not on the network\n65-> Package not installed\n66-> Object is remote\n67-> Link has been severed\n68-> Advertise error\n69-> Srmount error\n70-> Communication error on send\n71-> Protocol error\n72-> Multihop attempted\n73-> RFS specific error\n74-> Bad message\n75-> Value too large for defined data type\n76-> Name not unique on network\n77-> File descriptor in bad state\n78-> Remote address changed\n79-> Can not access a needed shared library\n80-> Accessing a corrupted shared library\n81-> .lib section in a.out corrupted\n82-> Attempting to link in too many shared libraries\n83-> Cannot exec a shared library directly\n84-> Invalid or incomplete multibyte or wide character\n85-> Interrupted system call should be restarted\n86-> Streams pipe error\n87-> Too many users\n88-> Socket operation on non-socket\n89-> Destination address required\n90-> Message too long\n91-> Protocol wrong type for socket\n92-> Protocol not available\n93-> Protocol not supported\n94-> Socket type not supported\n95-> Operation not supported\n96-> Protocol family not supported\n97-> Address family not supported by protocol\n98-> Address already in use\n99-> Cannot assign requested address\n100-> Network is down\n101-> Network is unreachable\n102-> Network dropped connection on reset\n103-> Software caused connection abort\n104-> Connection reset by peer\n105-> No buffer space available\n106-> Transport endpoint is already connected\n107-> Transport endpoint is not connected\n108-> Cannot send after transport endpoint shutdown\n109-> Too many references: cannot splice\n110-> Connection timed out\n111-> Connection refused\n112-> Host is down\n113-> No route to host\n114-> Operation already in progress\n115-> Operation now in progress\n116-> Stale file handle\n117-> Structure needs cleaning\n118-> Not a XENIX named type file\n119-> No XENIX semaphores available\n120-> Is a named type file\n121-> Remote I/O error\n122-> Disk quota exceeded\n123-> No medium found\n124-> Wrong medium type\n125-> Operation canceled\n126-> Required key not available\n127-> Key has expired\n128-> Key has been revoked\n129-> Key was rejected by service\n130-> Owner died\n131-> State not recoverable\n132-> Operation not possible due to RF-kill\n133-> Memory page has hardware error\n134-> Unknown error 134\n```\n\n**错误码的应用：**\n\n```prism language-c\nint main()\n{\n    FILE *fp = fopen(\"invalid.txt\", \"r\");//以只读方式打开不存在的文件会出错\n    if (fp == NULL)\n    {\n        // 使用 strerror 获取错误描述\n        printf(\"%d->%s\\n\", errno,strerror(errno));            \n        return 1; //退出码设为1\n    }\n    return 0;\n}\n```\n\n输出：\n\n```prism language-bash\n2->No such file or directory\n```\n\n**使用错误码和对应的错误信息可以帮助程序员快速定位错误模块，调试程序，掌握错误码的使用与调试技巧，是提升 Linux 编程效率和系统可靠性的关键。**\n\n*** ** * ** ***\n\n### {#_exitexit_832}_exit函数和exit函数\n\n**`_exit函数`**\n> 在 Linux 系统中，**`_exit()`** 是一个直接终止进程的**系统调用**，它会立即终止当前进程，并通知操作系统回收资源，但不执行任何用户空间的清理操作。\n\n```prism language-bash\n#include <unistd.h>\nvoid _exit(int status);\n```\n\n* 参数 **`status`** ：进程的退出状态码，范围是 **`0~255`** 。父进程可以通过 **`wait()`** 或 **`waitpid()`** 获取该状态码。\n* 返回值：无（进程直接终止，不会返回调用者）。\n\n当前进程调用 **`_exit()`** 后，操作系统会立即介入，会从用户态陷入内核态，执行以下操作：\n\n* 关闭所有文件描述符：内核会关闭进程打开的文件、套接字、管道等资源，但不会刷新标准 I/O 库（如 **`stdio`**）的缓冲区。\n* 释放用户空间内存：回收进程的代码段、数据段、堆、栈等内存资源。\n* 发送 **`SIGCHLD`** 信号： 通知父进程子进程已终止，并传递退出状态码 **`status`**。\n* 终止进程：进程的状态变为 **`ZOMBIE`** （僵尸进程），直到父进程通过 **`wait()`** 回收其资源。\n\n本质上，**`_exit()`** 最终会调用 Linux 内核的 **`exit_group`** 系统调用（**`sys_exit_group`**），终止整个进程及其所有线程。其内核处理流程如下：\n\n释放进程资源：\n\n* 关闭所有文件描述符。\n* 释放内存映射（mmap）和虚拟内存区域。\n* 解除信号处理程序绑定。\n\n更新进程状态：\n\n* 将进程状态设为 **`TASK_DEAD`**\n* 向父进程发送 **`SIGCHLD`** 信号。\n\n调度器介入：\n\n* 从运行队列中移除进程。\n* 切换到下一个进程执行。\n\n*** ** * ** ***\n\n**`exit函数`**\n> 在 C/C++ 语言中，**`exit`** 是一个用于正常终止程序执行的**标准库函数**。它会执行一系列清理操作后终止进程，并将控制权交还给操作系统。\n\n```prism language-cpp\n#include <stdlib.h>\nvoid exit(int status);  // C \n\n#include <cstdlib>\nvoid exit(int status);  // C++ \n```\n\n* 参数 **`status`** ：进程的退出状态码，范围 **`0~255`**（0 通常表示成功，非零表示异常）。\n* 返回值：无（进程终止，不会返回调用者）。\n\n进程调用 **exit** 时，按以下顺序执行操作：\n\n1. 调用 **`atexit`** 注册的函数：按注册的逆序执行所有通过 **`atexit`** 或  \n   **`at_quick_exit`**（若使用quick_exit）注册的函数。\n2. 刷新所有标准 I/O 缓冲区：清空 **`stdout`** 、**`stderr`** 等流的缓冲区。 **注意：** **stderr** 默认无缓冲，**stdout** 在交互式设备上是行缓冲。\n3. 关闭所有打开的文件流：调用 **`fclose`** 关闭所有通过 **`fopen`** 打开的文件。 注意：不会关闭底层文件描述符（需手动 **`close`**）。\n4. 删除临时文件：删除由 **`tmpfile`** 创建的临时文件。\n5. 终止进程：向操作系统返回状态码 **`status`** 。父进程可通过 **`wait`** 或 **`waitpid`** 获取该状态码。\n\n*** ** * ** ***\n\n**其实本质上，exit 是一个标准库函数，最后也会调用_exit,但是在这之前，exit还做了其他的清理工作：**\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a6e4a33b99b34cc2aec360b4a48cf19d.png)\n\n我们举个例子，帮大家直观的感受一下这两者的区别：\n\n**示例一：使用 exit 函数**\n\n```prism language-cpp\nint main()\n{\n    printf(\"hello\");\n    exit(0);\n}\n```\n\n输出：\n\n```prism language-bash\n[root@localhost linux]# ./a.out\nhello[root@localhost linux]#\n```\n\n**示例二：使用 _exit 函数**\n\n```prism language-cpp\nint main()\n{\n    printf(\"hello\");\n    _exit(0);\n}\n```\n\n输出：\n\n```prism language-bash\n[root@localhost linux]# ./a.out\n[root@localhost linux]#\n```\n\n> 聪明的同学很快就知道了，我们通过 **`printf`** 打印 \"hello\" 并没有加上换行符，所以\"hello\"  \n> 在缓冲区内没有被立即刷新，所以当我们使用exit终止进程时，exit会帮我们做相应的清理工作，包括刷新I/O缓冲区。而调用_exit时则不会刷新，进程直接退出。\n\n### {#return__944}return 退出\n\n> return是⼀种更常见的进程退出方法。执行 **`return n`** 等同于执行 **`exit(n)`**,因为调用main的运行时函数会将main函数的返回值当做 exit 的参数。\n\n状态码传递：\n\nmain函数中的 **`return`** 语句返回一个整数值（通常称为退出状态码），表示程序的执行结果：\n\n* 0：表示程序成功执行。\n* 非0：表示程序异常终止（具体数值由程序员定义）。\n\n**return与exit()的关系**\n\n隐式调用exit()：\n\n* 在 main 函数中使用 return 时，C/C++运行时会自动调用 exit() 函数，并将返回值作为参数传递给它。\n\n```prism language-cpp\nint main()\n{\n    return 42;  // 等价于 exit(42);\n}\n```\n\n**return的执行流程**\n\n当在main函数中执行return时，程序会做以下几件事：\n\n* 返回值传递：将返回值传递给运行时环境。\n\n清理操作：\n\n* 调用局部对象的析构函数（按照创建顺序的逆序）。\n* 调用全局对象的析构函数（同样逆序）。\n\n调用exit()：运行时调用exit()，执行以下操作：\n\n* 刷新所有I/O缓冲区（如 **`std::cout`**）。\n* 关闭通过 **`fopen`** 打开的文件流。\n* 执行通过 **`atexit()`** 注册的函数。\n\n终止进程：将控制权交还给操作系统。\n\n**值得注意的一点是：在非main函数的其他函数中使用 return 仅退出当前函数，返回到调用者，不会终止进程。**\n\n*** ** * ** ***\n\n### {#_exitexit__return__989}`_exit`、`exit` 和 `return` 对比\n\n**以下是一个详细的表格供大家理解参考**\n\n|     特性     |             _exit() (系统调用)              |              exit() (标准库函数)               |               return (在 main 中)               |\n|------------|-----------------------------------------|-------------------------------------------|-----------------------------------------------|\n| 所属标准       | POSIX 系统调用                              | C/C++ 标准库函数                               | C/C++ 语言关键字                                   |\n| 头文件        | `<unistd.h>`                            | `<stdlib.h>`（C）、`<cstdlib>`（C++）          | 无（语言内置）                                       |\n| 执行流程       | 立即终止进程，不执行任何用户空间清理。                     | 1. 调用 atexit 注册的函数 2. 刷新 I/O 缓冲区 3. 关闭文件流 | 1. 调用 C++ 局部对象析构函数 2. 隐式调用 exit() 完成后续清理      |\n| 清理操作       | 内核自动回收进程资源（内存、文件描述符），不刷新缓冲区、不调用析构函数     | 清理标准库资源（刷新缓冲区、关闭文件流），但不调用 C++ 局部对象析构函数    | 调用 C++ 局部和全局对象析构函数，并触发 exit() 的清理逻辑           |\n| 多线程行为      | 立即终止所有线程，可能导致资源泄漏                       | 终止整个进程，但可能跳过部分线程资源释放（如线程局部存储）             | 同 exit()，但在 C++ 中会正确析构主线程的局部对象                |\n| C++ 析构函数调用 | ❌ 不调用任何对象的析构函数（包括全局对象）                  | ❌ 不调用局部对象析构函数 ✅ 调用全局对象析构函数（C++）           | ✅ 调用局部和全局对象析构函数（C++）                          |\n| 缓冲区处理      | ❌ 不刷新 stdio 缓冲区（如 printf 的输出可能丢失）       | ✅ 刷新所有 stdio 缓冲区                          | ✅ 通过隐式调用 exit() 刷新缓冲区                         |\n| 适用场景       | 1. 子进程退出（避免重复刷新缓冲区） 2. 需要立即终止进程（绕过清理逻辑） | 1. 非 main 函数的程序终止 2. 需要执行注册的清理函数（如日志收尾）   | 1. 在 main 函数中正常退出 2. 需要确保 C++ 对象析构（RAII 资源管理） |\n| 错误处理       | 直接传递状态码给操作系统，无错误反馈机制                    | 可通过 atexit 注册错误处理函数，但无法捕获局部对象析构异常         | 可通过 C++ 异常机制处理错误（需在 main 中捕获）                 |\n| 信号安全       | ✅ 可在信号处理函数中安全调用（如 SIGINT）               | ❌ 不可在信号处理函数中调用（可能死锁）                      | ❌ 不可在信号处理函数中使用（仅限 main 函数流程）                  |\n| 资源泄漏风险     | 高（临时文件、未释放的手动内存等需内核回收）                  | 中（未关闭的文件描述符、手动内存需提前处理）                    | 低（依赖 RAII 自动释放资源）                             |\n| 底层实现       | 直接调用内核的 exit_group 系统调用                 | 调用 C 标准库的清理逻辑后，最终调用 _exit()               | 编译器生成代码调用析构函数，并跳转到 main 结尾触发 exit()           |\n\n最后总结下：\n\n* **`_exit()`**：最底层的终止方式，适合需要绕过所有用户空间清理的场景（如子进程退出）。\n* **`exit()`**：平衡安全与效率，适合非 main 函数的程序终止，但需注意 C++ 对象析构问题。\n* **`return`**：C++ 中最安全的退出方式，优先在 main 函数中使用，确保资源自动释放。\n\n*** ** * ** ***\n\n{#_1019}写在最后\n------------\n\n本文到这里就结束了，后面的文章我们会展开讲解有关 Linux操作系统的更多话题，带你从新手小白 成长为一名 Linux 糕手， 感谢您的观看！\n> 如果你觉得这篇文章对你有所帮助，请为我的博客 点赞👍收藏⭐️ 评论💬或 分享🔗 支持一下！你的每一个支持都是我继续创作的动力✨！🙏  \n> 如果你有任何问题或想法，也欢迎 留言💬 交流，一起进步📚！❤️ 感谢你的阅读和支持🌟！🎉  \n> 祝各位大佬吃得饱🍖，睡得好🛌，日有所得📈，逐梦扬帆⛵！\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/bite_zwy/article/details/147062981?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-05-23 16:54:42', '2025-05-23 17:10:22');
INSERT INTO `sys_article` VALUES (313, 1, 16, '【运维监控】Prometheus+grafana+blackbox_exporter+alertmanager监控业务接口异常预警（完整版）', 'img/【运维监控】Prometheus+grafana+blackbox_exporter+alertmanager监控业务接口异常预警（完整版）.png', '监控业务接口异常预警', '<ul>\n<li>运维监控系列文章入口：<a href=\"https://alanchan2win.blog.csdn.net/article/details/142202323\" target=\"_blank\">【运维监控】系列文章汇总索引</a></li>\n</ul>\n<hr />\n<br />\n<h4><a id=\"_6\"></a>文章目录</h4>\n<ul>\n<li><a href=\"#prometheus_15\">一、prometheus部署</a></li>\n<li><a href=\"#grafana_17\">二、grafana部署</a></li>\n<li><a href=\"#blackbox_exporter_19\">三、blackbox_exporter部署</a></li>\n<li>\n<ul>\n<li><a href=\"#1_31\">1、下载</a></li>\n<li><a href=\"#2_34\">2、解压</a></li>\n<li><a href=\"#3_48\">3、启动</a></li>\n<li><a href=\"#4_130\">4、验证</a></li>\n</ul>\n</li>\n<li><a href=\"#prometheusblackbox_exporter_135\">四、prometheus集成blackbox_exporter</a></li>\n<li>\n<ul>\n<li><a href=\"#1prometheus_136\">1、添加prometheus监控规则</a></li>\n<li><a href=\"#2prometheus_218\">2、添加prometheus的预警规则</a></li>\n<li><a href=\"#3prometheus_228\">3、添加prometheus的监控信息收集</a></li>\n<li><a href=\"#4prometheus_287\">4、重启prometheus</a></li>\n<li><a href=\"#5_317\">5、验证</a></li>\n</ul>\n</li>\n<li><a href=\"#prometheusgrfanablackbox_exporter_331\">五、prometheus、grfana和blackbox_exporter集成</a></li>\n<li><a href=\"#alertmanager_336\">六、alertmanager部署与集成</a></li>\n<li>\n<ul>\n<li><a href=\"#1_339\">1、下载</a></li>\n<li><a href=\"#2_342\">2、解压</a></li>\n<li><a href=\"#3_358\">3、启动</a></li>\n<li><a href=\"#4prometheus_426\">4、添加prometheus的预警配置</a></li>\n<li><a href=\"#5_440\">5、验证</a></li>\n</ul>\n</li>\n</ul>\n<br />\n<hr />\n<ul>\n<li>\n<p>本示例通过blackbox_exporter收集http/https（业务接口）、tcp、ping、dns的监控指标，然后将数据收集到prometheus中，配置预警规则，出现警告信息时通过邮件通知相关人员，同时也通过grafana的dashboard导入模板进行可视化。</p>\n</li>\n<li>\n<p>本示例分为六个部分，即prometheus、grafana、blackbox_exporter部署，prometheus与blackbox_exporter集成，prometheus、blackbox_exporter与grafana集成，prometheus、blackbox_exporter与alertmanager集成。</p>\n</li>\n<li>\n<p>说明：<br />\n1、本示例中的部署环境没有要求，即应用部署的机器根据实际情况而定，只要网络连通即可。<br />\n2、prometheus与alertmanager可直接集成，与blackbox_exporter无关，其只是在本示例中使用其进行一些信息的收集。</p>\n</li>\n</ul>\n<h2><a id=\"prometheus_15prometheus_content_views_44\"></a>{#prometheus_15}一、prometheus部署 {#content_views}</h2>\n<p>参考：<a href=\"https://alanchan2win.blog.csdn.net/article/details/141818565\" target=\"_blank\">【运维监控】prometheus+node exporter+grafana 监控linux机器运行情况</a>关于prometheus的部署。</p>\n<h2><a id=\"grafana_17grafana_49\"></a>{#grafana_17}二、grafana部署</h2>\n<p>参考：<a href=\"https://alanchan2win.blog.csdn.net/article/details/141818565\" target=\"_blank\">【运维监控】prometheus+node exporter+grafana 监控linux机器运行情况</a> 关于grafana的部署。</p>\n<h2><a id=\"blackbox_exporter_19blackbox_exporter_54\"></a>{#blackbox_exporter_19}三、blackbox_exporter部署</h2>\n<p>blackbox_exporter 是 Prometheus 官方提供的官方黑盒监控解决方案，其中 exporter 之一，可以提供 http(s)、dns、tcp、icmp 的方式对网络进行探测。<br />\n目前支持的应用场景：</p>\n<ul>\n<li>ICMP 测试，主机探活机制</li>\n<li>TCP 测试，端口状态监听和应用层协议定义与监听</li>\n<li>HTTP 测试，定义 Request Header 信息、判断 Http status / Http Respones Header / Http Body 内容</li>\n<li>POST 测试，接口联通性</li>\n<li>SSL 证书过期时间</li>\n<li>自定义测试（扩展）</li>\n</ul>\n<p>本服务部署在server2上。</p>\n<h3><a id=\"1_311_69\"></a>{#1_31}1、下载</h3>\n<p>下载地址：https://github.com/prometheus/blackbox_exporter<br />\n下载版本：blackbox_exporter-0.25.0.linux-amd64.tar.gz</p>\n<h3><a id=\"2_342_74\"></a>{#2_34}2、解压</h3>\n<pre><code class=\"lang-prism\">[alanchan@server2 bigdata]$ tar xf blackbox_exporter-0.25.0.linux-amd64.tar.gz -C /usr/local/bigdata\n[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ pwd\n/usr/local/bigdata/blackbox_exporter-0.25.0.linux-amd64\n[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ ll\ntotal 21124\n-rwxr-xr-x 1 alanchan root 21606608 Apr  9 12:59 blackbox_exporter\n-rw-r--r-- 1 alanchan root     1404 Sep 11 06:46 blackbox.yml\n-rw-r--r-- 1 alanchan root    11357 Apr  9 13:00 LICENSE\n-rw-r--r-- 1 alanchan root       94 Apr  9 13:00 NOTICE\n</code></pre>\n<h3><a id=\"3_483_88\"></a>{#3_48}3、启动</h3>\n<p>blackbox.yml的默认配置文件内容如下。可以根据自己的需要进行修改或保持默认。</p>\n<pre><code class=\"lang-prism\">[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ cat blackbox.yml \nmodules:\n  http_2xx: # 模块名称,prometheus配置文件中要匹配\n    prober: http # 协议\n    http: # 模块的采集协议\n      preferred_ip_protocol: &quot;ip4&quot; # 使用的ipv4协议 \n\n  http_post_2xx:\n    prober: http\n    http:\n      method: POST # http请求的方法\n      # headers:   # 配置post请求的header头 \n      # Content-Type: application/json \n      # body: \'\'{&quot;username&quot;: &quot;alanchanchn&quot;, &quot;password&quot;: &quot;123456&quot;}\'\' # post请求参数\n  tcp_connect:\n    prober: tcp\n  pop3s_banner:\n    prober: tcp\n    tcp:\n      query_response:\n      - expect: &quot;^+OK&quot;\n      tls: true\n      tls_config:\n        insecure_skip_verify: false\n  grpc:\n    prober: grpc\n    grpc:\n      tls: true\n      preferred_ip_protocol: &quot;ip4&quot;\n  grpc_plain:\n    prober: grpc\n    grpc:\n      tls: false\n      service: &quot;service1&quot;\n  ssh_banner:\n    prober: tcp\n    tcp:\n      query_response:\n      - expect: &quot;^SSH-2.0-&quot;\n      - send: &quot;SSH-2.0-blackbox-ssh-check&quot;\n  irc_banner:\n    prober: tcp\n    tcp:\n      query_response:\n      - send: &quot;NICK prober&quot;\n      - send: &quot;USER prober prober prober :prober&quot;\n      - expect: &quot;PING :([^ ]+)&quot;\n        send: &quot;PONG ${1}&quot;\n      - expect: &quot;^:[^ ]+ 001&quot;\n  icmp:\n    prober: icmp\n  icmp_ttl5:\n    prober: icmp\n    timeout: 5s\n    icmp:\n      ttl: 5\n</code></pre>\n<p>启动命令如下。</p>\n<pre><code class=\"lang-prism\">[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ ll\ntotal 21124\n-rwxr-xr-x 1 alanchan root 21606608 Apr  9 12:59 blackbox_exporter\n-rw-r--r-- 1 alanchan root      956 Apr  9 13:00 blackbox.yml\n-rw-r--r-- 1 alanchan root    11357 Apr  9 13:00 LICENSE\n-rw-r--r-- 1 alanchan root       94 Apr  9 13:00 NOTICE\n[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ blackbox_exporter \nts=2024-09-11T06:45:43.194Z caller=main.go:87 level=info msg=&quot;Starting blackbox_exporter&quot; version=&quot;(version=0.25.0, branch=HEAD, revision=ef3ff4fef195333fb8ee0039fb487b2f5007908f)&quot;\nts=2024-09-11T06:45:43.194Z caller=main.go:88 level=info build_context=&quot;(go=go1.22.2, platform=linux/amd64, user=root@47d5b0d99f18, date=20240409-12:58:39, tags=unknown)&quot;\nts=2024-09-11T06:45:43.194Z caller=main.go:91 level=error msg=&quot;Error loading config&quot; err=&quot;error parsing config file: yaml: unmarshal errors:\\n  line 52: mapping key \\&quot;modules\\&quot; already defined at line 1&quot;\n[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ blackbox_exporter \nts=2024-09-11T06:46:08.036Z caller=main.go:87 level=info msg=&quot;Starting blackbox_exporter&quot; version=&quot;(version=0.25.0, branch=HEAD, revision=ef3ff4fef195333fb8ee0039fb487b2f5007908f)&quot;\nts=2024-09-11T06:46:08.036Z caller=main.go:88 level=info build_context=&quot;(go=go1.22.2, platform=linux/amd64, user=root@47d5b0d99f18, date=20240409-12:58:39, tags=unknown)&quot;\nts=2024-09-11T06:46:08.036Z caller=main.go:100 level=info msg=&quot;Loaded config file&quot;\nts=2024-09-11T06:46:08.037Z caller=tls_config.go:313 level=info msg=&quot;Listening on&quot; address=[::]:9115\nts=2024-09-11T06:46:08.037Z caller=tls_config.go:316 level=info msg=&quot;TLS is disabled.&quot; http2=false address=[::]:9115\n</code></pre>\n<h3><a id=\"4_1304_172\"></a>{#4_130}4、验证</h3>\n<p>正常启动后，可在浏览器中输入http://server2:9115/，查看信息，界面如下。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/f3daa800461e45f8ba0e979d84ea73c0.png\" alt=\"在这里插入图片描述\" /><br />\n刚启动应该是没有数据的。至此，blackbox_exporter部署完成。</p>\n<h2><a id=\"prometheusblackbox_exporter_135prometheusblackbox_exporter_178\"></a>{#prometheusblackbox_exporter_135}四、prometheus集成blackbox_exporter</h2>\n<h3><a id=\"1prometheus_1361prometheus_181\"></a>{#1prometheus_136}1、添加prometheus监控规则</h3>\n<p>命名blackbox_exporter.yml，其内容如下</p>\n<pre><code class=\"lang-prism\">groups:\n- name: Blackbox_alanchan\n  rules:\n  - alert:blackbox探测失败警告\n    expr: probe_success == 0\n    for: 1m\n    labels:\n      severity: critical\n    annotations:\n      summary: &quot;blackbox探测失败{{ $labels.instance }}&quot;\n      description: &quot;blackbox检测失败，当前值：{{ $value }}&quot;\n      \n  - alert: 请求慢预警\n    expr: avg_over_time(probe_duration_seconds[1m]) &gt; 3\n    for: 1m\n    labels:\n      severity: warning\n    annotations:\n      summary: &quot;请求慢{{ $labels.instance }}&quot;\n      description: &quot;请求时间超过3秒，值为：{{ $value }}&quot;\n      \n  - alert: http状态码检测失败\n    expr: probe_http_status_code &lt;= 199 OR probe_http_status_code &gt;= 400\n    for: 1m\n    labels:\n      severity: critical\n    annotations:\n      summary: &quot;http状态码检测失败{{ $labels.instance }}&quot;\n      description: &quot;HTTP状态码不在 200-399 区间，当前状态码是{{ $value }}&quot;\n  \n</code></pre>\n<p>Prometheus alert 预警状态有三种状态：Inactive、Pending、Firing。</p>\n<ul>\n<li>Inactive：非活动状态，表示正在监控，但是还未有任何警报触发。</li>\n<li>Pending：已触发阈值，但未满足告警持续时间（即rule中的for字段）。由于警报可以被分组、抑制或静默，所以等待验证，一旦所有的验证都通过，则将转到 Firing 状态。</li>\n<li>Firing：将警报发送到 AlertManager，它将按照配置将警报的发送给所有接收者。一旦警报解除，则将状态转到 Inactive，如此循环。</li>\n</ul>\n<p>Prometheus支持两种类型的规则，即记录规则和警报规则。它们可以进行配置，然后定期进行评估。 要将规则包含在Prometheus中，需要先创建一个包含必要规则的文件，并让Prometheus通过Prometheus配置中的rule_fies字段加载该文件。 默认情况下，prometheus的规则文件使用YAML。<br />\n规则的使用流程如下：</p>\n<ul>\n<li>创建一个满足规则标准的规则</li>\n<li>发送SIGHUP给Prometheus进程，prometheus在运行时重新加载规则文件，从而让规则在prometheus运行环境中生效。</li>\n</ul>\n<p>规则文件的语法</p>\n<pre><code class=\"lang-prism\">groups:\n [ - &lt;rule_group&gt; ]\n</code></pre>\n<p>规则文件属性</p>\n<pre><code class=\"lang-prism\">name 规则组名，必须是唯一的\ninterval 定制规则执行的间隔时间\nrules 设定规则具体信息\n  record 定制指标的名称\n  expr 执行成功的PromQL\n  labels 为该规则设定标签\n</code></pre>\n<p>示例</p>\n<pre><code class=\"lang-prism\">groups:\n- name: Blackbox_alanchan\n  rules:\n  - alert: blackbox探测失败警告 #自定义预警的动作名称\n    expr: probe_success == 0\n    for: 1m # expr动作触发后，持续的时间，达到该条件就会预警\n    labels:\n      severity: critical # 预警级别\n    annotations: # 注释信息，注释信息中的变量需要从模板中或者系统中读取\n      summary: &quot;blackbox探测失败{{ $labels.instance }}&quot;\n      description: &quot;blackbox检测失败，当前值：{{ $value }}&quot;\n</code></pre>\n<p>规则语法检测命令</p>\n<pre><code class=\"lang-prism\">promtool check rules /usr/local/bigdata/prometheus-2.54.0.linux-amd64/rules/blackbox_exporter.yml\n</code></pre>\n<h3><a id=\"2prometheus_2182prometheus_270\"></a>{#2prometheus_218}2、添加prometheus的预警规则</h3>\n<p>去掉prometheus.yml中关于预警规则的注释，修改内容为如下。具体视环境而定，下文是作者的规则文件存放目录。</p>\n<pre><code class=\"lang-prism\">rule_files:\n  - &quot;/usr/local/bigdata/prometheus-2.54.0.linux-amd64/rules/blackbox_exporter.yml&quot;\n</code></pre>\n<p>添加好的预警规则可以在http://server2:9090/rules中查看，示例如下。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/8cda6a4ea331486192804c64290b88be.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"3prometheus_2283prometheus_282\"></a>{#3prometheus_228}3、添加prometheus的监控信息收集</h3>\n<p>在prometheus.yml中添加如下信息。</p>\n<pre><code class=\"lang-prism\">scrape_configs:\n# blackbox \n #http配置\n  - job_name: &quot;blackbox_http&quot;\n    metrics_path: /probe\n    params:\n      module: [http_2xx]\n    static_configs:\n      - targets:\n        - https://www.baidu.com\n        - http://192.168.3.105:8080/test/example/test.json \n        - http://192.168.3.105:8080/test/example\n        - https://github.com/prometheus/blackbox_exporter\n    relabel_configs:\n      - source_labels: [__address__]\n        target_label: __param_target\n      - source_labels: [__param_target]\n        target_label: instance\n      - target_label: __address__\n        replacement: server2:9115  # blackbox安装在哪台机器\n\n #tcp检查配置\n  - job_name: &quot;blackbox_tcp&quot;\n    metrics_path: /probe\n    params:\n      module: [tcp_connect]\n    static_configs:\n      - targets: \n        - server8:22\n        - server2:9090\n    relabel_configs:\n      - source_labels: [__address__]\n        target_label: __param_target\n      - source_labels: [__param_target]\n        target_label: instance\n      - target_label: __address__\n        replacement: server2:9115\n\n #icmp检查配置 ping\n  - job_name: &quot;blackbox_icmp&quot;\n    metrics_path: /probe\n    params:\n      module: [icmp]\n    static_configs:\n      - targets: \n        - 192.168.10.71\n        - 192.168.10.118\n    relabel_configs:\n      - source_labels: [__address__]\n        target_label: __param_target\n      - source_labels: [__param_target]\n        target_label: instance\n      - target_label: __address__\n        replacement: server2:9115\n</code></pre>\n<h3><a id=\"4prometheus_2874prometheus_343\"></a>{#4prometheus_287}4、重启prometheus</h3>\n<pre><code class=\"lang-prism\">[alanchan@server2 prometheus-2.54.0.linux-amd64]$ ./prometheus \nts=2024-09-12T05:50:17.005Z caller=main.go:601 level=info msg=&quot;No time or size retention was set so using the default time retention&quot; duration=15d\nts=2024-09-12T05:50:17.005Z caller=main.go:645 level=info msg=&quot;Starting Prometheus Server&quot; mode=server version=&quot;(version=2.54.0, branch=HEAD, revision=5354e87a70d3eb26b81b601b286d66ff983990f6)&quot;\nts=2024-09-12T05:50:17.005Z caller=main.go:650 level=info build_context=&quot;(go=go1.22.6, platform=linux/amd64, user=root@68a9e2472a68, date=20240809-11:36:32, tags=netgo,builtinassets,stringlabels)&quot;\nts=2024-09-12T05:50:17.005Z caller=main.go:651 level=info host_details=&quot;(Linux 2.6.32-754.35.1.el6.x86_64 #1 SMP Sat Nov 7 12:42:14 UTC 2020 x86_64 server2 (none))&quot;\nts=2024-09-12T05:50:17.005Z caller=main.go:652 level=info fd_limits=&quot;(soft=131072, hard=131072)&quot;\nts=2024-09-12T05:50:17.005Z caller=main.go:653 level=info vm_limits=&quot;(soft=unlimited, hard=unlimited)&quot;\nts=2024-09-12T05:50:17.009Z caller=web.go:571 level=info component=web msg=&quot;Start listening for connections&quot; address=0.0.0.0:9090\nts=2024-09-12T05:50:17.009Z caller=main.go:1160 level=info msg=&quot;Starting TSDB ...&quot;\n\nts=2024-09-12T05:50:17.012Z caller=tls_config.go:313 level=info component=web msg=&quot;Listening on&quot; address=[::]:9090\nts=2024-09-12T05:50:17.012Z caller=tls_config.go:316 level=info component=web msg=&quot;TLS is disabled.&quot; http2=false address=[::]:9090\nts=2024-09-12T05:50:17.027Z caller=head.go:626 level=info component=tsdb msg=&quot;Replaying on-disk memory mappable chunks if any&quot;\nts=2024-09-12T05:50:17.036Z caller=head.go:713 level=info component=tsdb msg=&quot;On-disk memory mappable chunks replay completed&quot; duration=9.269999ms\nts=2024-09-12T05:50:17.036Z caller=head.go:721 level=info component=tsdb msg=&quot;Replaying WAL, this may take a while&quot;\nts=2024-09-12T05:50:17.048Z caller=head.go:758 level=info component=tsdb msg=&quot;WAL checkpoint loaded&quot;\n\nts=2024-09-12T05:50:17.483Z caller=head.go:830 level=info component=tsdb msg=&quot;WAL replay completed&quot; checkpoint_replay_duration=11.904575ms wal_replay_duration=435.015809ms wbl_replay_duration=158ns chunk_snapshot_load_duration=0s mmap_chunk_replay_duration=9.269999ms total_replay_duration=456.234198ms\nts=2024-09-12T05:50:17.487Z caller=main.go:1181 level=info fs_type=EXT4_SUPER_MAGIC\nts=2024-09-12T05:50:17.487Z caller=main.go:1184 level=info msg=&quot;TSDB started&quot;\nts=2024-09-12T05:50:17.488Z caller=main.go:1367 level=info msg=&quot;Loading configuration file&quot; filename=prometheus.yml\nts=2024-09-12T05:50:17.490Z caller=main.go:1404 level=info msg=&quot;updated GOGC&quot; old=100 new=75\nts=2024-09-12T05:50:17.490Z caller=main.go:1415 level=info msg=&quot;Completed loading of configuration file&quot; filename=prometheus.yml totalDuration=2.770824ms db_storage=7.513µs remote_storage=4.818µs web_handler=941ns query_engine=3.672µs scrape=412.441µs scrape_sd=261.046µs notify=44.541µs notify_sd=10.73µs rules=1.118939ms tracing=13.933µs\nts=2024-09-12T05:50:17.490Z caller=main.go:1145 level=info msg=&quot;Server is ready to receive web requests.&quot;\nts=2024-09-12T05:50:17.491Z caller=manager.go:164 level=info component=&quot;rule manager&quot; msg=&quot;Starting rule manager...&quot;\n</code></pre>\n<p>启动成功后，可以通过下面验证部分进行验证。</p>\n<h3><a id=\"5_3175_375\"></a>{#5_317}5、验证</h3>\n<p>验证分为2个部分，即添加的预警规则是否正常显示以及监控的信息是否收集到。添加的监控信息如下图可以看到已经加载进来。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/eabfb72e771c4f6993c02e912591a514.png\" alt=\"在这里插入图片描述\" /><br />\n可以通过prometheus的预警按钮查看，如下图。由于监控的服务没有启动，所以会出现预警。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/f9f5b256ab33427aa4b5441aef9ef389.png\" alt=\"在这里插入图片描述\" /><br />\n点击详细进去可以看看，如下图。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/acdeada08e1f429b9c6442a33cd0b26b.png\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/925ba6eba6fc40dea4b9da69398974a5.png\" alt=\"在这里插入图片描述\" /></p>\n<p>启动我们提前创建好的接口服务，再观察监控的情况。<br />\n接口服务为简单的2个spring boot创建的restful接口，其中一个接口设置延迟时间600毫秒。<br />\n另外，我们监控的192.168.10.71机器不存在，49机器不能访问。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/4a2daf3397664c3bbb6e538ea920908c.png\" alt=\"在这里插入图片描述\" /><br />\n以上就完成了prometheus和blackbox_expoerter监控http协议的接口、tcp的连接等操作了，并可进行预警。</p>\n<h2><a id=\"prometheusgrfanablackbox_exporter_331prometheusgrfanablackbox_exporter_391\"></a>{#prometheusgrfanablackbox_exporter_331}五、prometheus、grfana和blackbox_exporter集成</h2>\n<p>在完成前四步操作后，我们基本上已经完成了主要监控功能，如果我们想更加直观的展示更多的信息，我们可以将grafana集成进来。<br />\n集成grafana需要先添加数据源、导入模板，本示例导入的模板ID是13659（blackbox-exporter-http-prober），导入成功后，数据展示图如下。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/922644844d044cc9960b523c33f01fdd.png\" alt=\"在这里插入图片描述\" /><br />\n以上五步完成后，我们完成了监控信息的预警、展示，基本上能满足使用需要了。一般可能需要增加出现了警告信息能通知到具体的人，如此则需要使用prometheus的警告服务了。</p>\n<h2><a id=\"alertmanager_336alertmanager_399\"></a>{#alertmanager_336}六、alertmanager部署与集成</h2>\n<p>该服务是prometheus的警告服务，出现警告信息后可给相关人员发送邮件等告知信息。下面就在上面五步的基础上进行alertmanager的集成。当然，也可以不集成grafana直接在前四步的基础上进行集成，也可以直接在grafana的系统中完成警告信息的邮件发送等功能。<br />\n本服务部署在server2上。</p>\n<h3><a id=\"1_3391_405\"></a>{#1_339}1、下载</h3>\n<p>可以在prometheus下载页面直接找到alertmanager下载链接。<br />\n下载版本：alertmanager-0.27.0.linux-amd64.tar.gz</p>\n<h3><a id=\"2_3422_410\"></a>{#2_342}2、解压</h3>\n<pre><code class=\"lang-prism\">[alanchan@server2 ~]$ cd /usr/local/bigdata\n[alanchan@server2 bigdata]$ tar xf alertmanager-0.27.0.linux-amd64.tar.gz -C /usr/local/bigdata\n[alanchan@server2 bigdata]$ cd alertmanager-0.27.0.linux-amd64\n[alanchan@server2 alertmanager-0.27.0.linux-amd64]$ ll\ntotal 65916\n-rwxr-xr-x 1 alanchan root 37345962 Feb 28  2024 alertmanager\n-rw-r--r-- 1 alanchan root      356 Feb 28  2024 alertmanager.yml\n-rwxr-xr-x 1 alanchan root 30130103 Feb 28  2024 amtool\n-rw-r--r-- 1 alanchan root    11357 Feb 28  2024 LICENSE\n-rw-r--r-- 1 alanchan root      457 Feb 28  2024 NOTICE\n\n</code></pre>\n<h3><a id=\"3_3583_426\"></a>{#3_358}3、启动</h3>\n<p>解压完成后，alertmanager的默认配置文件alertmanager.yml内容如下</p>\n<pre><code class=\"lang-prism\">[alanchan@server2 alertmanager-0.27.0.linux-amd64]$ cat alertmanager.yml \nroute:\n  group_by: [\'alertname\']\n  group_wait: 30s\n  group_interval: 5m\n  repeat_interval: 1h\n  receiver: \'web.hook\'\nreceivers:\n  - name: \'web.hook\'\n    webhook_configs:\n      - url: \'http://127.0.0.1:5001/\'\ninhibit_rules:\n  - source_match:\n      severity: \'critical\'\n    target_match:\n      severity: \'warning\'\n    equal: [\'alertname\', \'dev\', \'instance\']\n</code></pre>\n<p>由于我们的目标是将预警信息发送至邮件，所以我们需要配置将配置文件alertmanager.yml改成如下内容。</p>\n<pre><code class=\"lang-prism\">global:\n  resolve_timeout: 5m\n  smtp_from: \'alan.chan.chn@163.com\' # 发送者邮箱\n  smtp_smarthost: \'smtp.163.com:465\' #需要登录邮箱系统，设置开启 POP3/SMTP 服务\n  smtp_auth_username: \'alan.chan.chn@163.com\'\n  smtp_auth_password: \'CXFZQSXTYTxxxxxFU\'# 这个是在开启stmp服务的时候由邮箱服务器自动生成的授权码\n  smtp_require_tls: false # 是否使用 tls，视环境情况来选择开启和关闭。报错 email.loginAuth failed: 530 Must issue a STARTTLS command first，就需要设置为 true。如果开启了 tls报错 starttls failed: x509: certificate signed by unknown authority，需要在 email_configs 下配置 insecure_skip_verify: true 来跳过 tls 验证。\n  smtp_hello: \'163.com\'\nroute:\n  group_by: [\'alertname\']\n  group_wait: 5s\n  group_interval: 5s\n  repeat_interval: 6m #repeat_inerval配置项，用于降低告警收敛，减少报警，发送关键报警，对于email来说，此项不可以设置过低，否则将会由于邮件发送太多频繁，被smtp服务器拒绝\n  receiver: \'email\'\nreceivers:\n- name: \'email\'\n  email_configs:\n  - to: \'alanchanchn@163.com\'\n    send_resolved: true\ninhibit_rules:\n  - source_match:\n      severity: \'critical\'\n    target_match:\n      severity: \'warning\'\n    equal: [\'alertname\', \'dev\', \'instance\']\n</code></pre>\n<p>然后启动alertmanager服务，启动信息如下。</p>\n<pre><code class=\"lang-prism\">[alanchan@server2 alertmanager-0.27.0.linux-amd64]$ alertmanager \nts=2024-09-11T08:05:24.114Z caller=main.go:181 level=info msg=&quot;Starting Alertmanager&quot; version=&quot;(version=0.27.0, branch=HEAD, revision=0aa3c2aad14cff039931923ab16b26b7481783b5)&quot;\nts=2024-09-11T08:05:24.114Z caller=main.go:182 level=info build_context=&quot;(go=go1.21.7, platform=linux/amd64, user=root@22cd11f671e9, date=20240228-11:51:20, tags=netgo)&quot;\nts=2024-09-11T08:05:24.115Z caller=cluster.go:186 level=info component=cluster msg=&quot;setting advertise address explicitly&quot; addr=192.168.10.42 port=9094\nts=2024-09-11T08:05:24.116Z caller=cluster.go:683 level=info component=cluster msg=&quot;Waiting for gossip to settle...&quot; interval=2s\nts=2024-09-11T08:05:24.146Z caller=coordinator.go:113 level=info component=configuration msg=&quot;Loading configuration file&quot; file=alertmanager.yml\nts=2024-09-11T08:05:24.147Z caller=coordinator.go:126 level=info component=configuration msg=&quot;Completed loading of configuration file&quot; file=alertmanager.yml\nts=2024-09-11T08:05:24.150Z caller=tls_config.go:313 level=info msg=&quot;Listening on&quot; address=[::]:9093\nts=2024-09-11T08:05:24.150Z caller=tls_config.go:316 level=info msg=&quot;TLS is disabled.&quot; http2=false address=[::]:9093\nts=2024-09-11T08:05:26.116Z caller=cluster.go:708 level=info component=cluster msg=&quot;gossip not settled&quot; polls=0 before=0 now=1 elapsed=2.000435063s\nts=2024-09-11T08:05:34.118Z caller=cluster.go:700 level=info component=cluster msg=&quot;gossip settled; proceeding&quot; elapsed=10.001893362s\n^Cts=2024-09-11T08:36:32.702Z caller=main.go:542 level=info msg=&quot;Received SIGTERM, exiting gracefully...&quot;\n\n</code></pre>\n<h3><a id=\"4prometheus_4264prometheus_498\"></a>{#4prometheus_426}4、添加prometheus的预警配置</h3>\n<p>修改prometheus.yml配置增加，取消注释，并修改target为alertmanager服务所在的地址，示例如下。</p>\n<pre><code class=\"lang-prism\"># Alertmanager configuration\nalerting:\n  alertmanagers:\n    - static_configs:\n        - targets:\n           - server2:9093\n</code></pre>\n<p>重启prometheus服务。启动成功后，可通过以下示例页面（页面最下方）查看配置的alertmanager服务。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/757743db5bcc41b8a1ed7c749ec6c32f.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"5_4405_514\"></a>{#5_440}5、验证</h3>\n<p>alertmanager服务的默认端口是9093，通过浏览器访问server2:9093，可见如下界面，则表示成功。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/2f605c4850234ef4a30a4fe2cbf37ea8.png\" alt=\"在这里插入图片描述\" /><br />\n如果有告警信息后，则该界面显示告警信息，如下<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/308fe969571b47b19784337d44861576.png\" alt=\"在这里插入图片描述\" /><br />\n有预警信息的同时，如果你的有邮箱配置正的话，应该会收到预警信息的邮件，如下图所示。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/6c515c54a2054440af4d447a19345b8b.png\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/82c6965cde2247efb15c20a0fbe4e682.png\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/c1624dcf06d44190903be0ae8eea28e4.png\" alt=\"在这里插入图片描述\" /><br />\n如果我们将自己创建的接口服务关闭，报警信息如下。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/56c91b6b81c3410c942d2bb4de79ae94.png\" alt=\"在这里插入图片描述\" /><br />\n我们将接口服务中的一个接口延迟60秒，看看邮件预警信息如下。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/9ef025f703574e9d80d0b81c3bad3984.png\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/d2a84a71c7024b7db677b5d67c7c12b1.png\" alt=\"在这里插入图片描述\" /><br />\ngrafana的dashboard显示内容如下。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/868b71feb3dc41bfaf83d201b07974da.png\" alt=\"在这里插入图片描述\" /></p>\n<p>以上，简单的完成了Prometheus+grafana+blackbox_exporter监控业务接口异常预警示例。其中关于规则配置以及预警配置有很多的内容需要参考官方介绍。</p>\n', '* 运维监控系列文章入口：[【运维监控】系列文章汇总索引](https://alanchan2win.blog.csdn.net/article/details/142202323)\n\n*** ** * ** ***\n\n<br />\n\n#### 文章目录\n\n* [一、prometheus部署](#prometheus_15)\n* [二、grafana部署](#grafana_17)\n* [三、blackbox_exporter部署](#blackbox_exporter_19)\n*\n  * [1、下载](#1_31)\n  * [2、解压](#2_34)\n  * [3、启动](#3_48)\n  * [4、验证](#4_130)\n* [四、prometheus集成blackbox_exporter](#prometheusblackbox_exporter_135)\n*\n  * [1、添加prometheus监控规则](#1prometheus_136)\n  * [2、添加prometheus的预警规则](#2prometheus_218)\n  * [3、添加prometheus的监控信息收集](#3prometheus_228)\n  * [4、重启prometheus](#4prometheus_287)\n  * [5、验证](#5_317)\n* [五、prometheus、grfana和blackbox_exporter集成](#prometheusgrfanablackbox_exporter_331)\n* [六、alertmanager部署与集成](#alertmanager_336)\n*\n  * [1、下载](#1_339)\n  * [2、解压](#2_342)\n  * [3、启动](#3_358)\n  * [4、添加prometheus的预警配置](#4prometheus_426)\n  * [5、验证](#5_440)\n\n<br />\n\n*** ** * ** ***\n\n* 本示例通过blackbox_exporter收集http/https（业务接口）、tcp、ping、dns的监控指标，然后将数据收集到prometheus中，配置预警规则，出现警告信息时通过邮件通知相关人员，同时也通过grafana的dashboard导入模板进行可视化。\n\n* 本示例分为六个部分，即prometheus、grafana、blackbox_exporter部署，prometheus与blackbox_exporter集成，prometheus、blackbox_exporter与grafana集成，prometheus、blackbox_exporter与alertmanager集成。\n\n* 说明：  \n  1、本示例中的部署环境没有要求，即应用部署的机器根据实际情况而定，只要网络连通即可。  \n  2、prometheus与alertmanager可直接集成，与blackbox_exporter无关，其只是在本示例中使用其进行一些信息的收集。\n\n{#prometheus_15}一、prometheus部署 {#content_views}\n-----------------------------------------------\n\n参考：[【运维监控】prometheus+node exporter+grafana 监控linux机器运行情况](https://alanchan2win.blog.csdn.net/article/details/141818565)关于prometheus的部署。\n\n{#grafana_17}二、grafana部署\n------------------------\n\n参考：[【运维监控】prometheus+node exporter+grafana 监控linux机器运行情况](https://alanchan2win.blog.csdn.net/article/details/141818565) 关于grafana的部署。\n\n{#blackbox_exporter_19}三、blackbox_exporter部署\n--------------------------------------------\n\nblackbox_exporter 是 Prometheus 官方提供的官方黑盒监控解决方案，其中 exporter 之一，可以提供 http(s)、dns、tcp、icmp 的方式对网络进行探测。  \n目前支持的应用场景：\n\n* ICMP 测试，主机探活机制\n* TCP 测试，端口状态监听和应用层协议定义与监听\n* HTTP 测试，定义 Request Header 信息、判断 Http status / Http Respones Header / Http Body 内容\n* POST 测试，接口联通性\n* SSL 证书过期时间\n* 自定义测试（扩展）\n\n本服务部署在server2上。\n\n### {#1_31}1、下载\n\n下载地址：https://github.com/prometheus/blackbox_exporter  \n下载版本：blackbox_exporter-0.25.0.linux-amd64.tar.gz\n\n### {#2_34}2、解压\n\n```prism language-bash\n[alanchan@server2 bigdata]$ tar xf blackbox_exporter-0.25.0.linux-amd64.tar.gz -C /usr/local/bigdata\n[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ pwd\n/usr/local/bigdata/blackbox_exporter-0.25.0.linux-amd64\n[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ ll\ntotal 21124\n-rwxr-xr-x 1 alanchan root 21606608 Apr  9 12:59 blackbox_exporter\n-rw-r--r-- 1 alanchan root     1404 Sep 11 06:46 blackbox.yml\n-rw-r--r-- 1 alanchan root    11357 Apr  9 13:00 LICENSE\n-rw-r--r-- 1 alanchan root       94 Apr  9 13:00 NOTICE\n```\n\n### {#3_48}3、启动\n\nblackbox.yml的默认配置文件内容如下。可以根据自己的需要进行修改或保持默认。\n\n```prism language-bash\n[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ cat blackbox.yml \nmodules:\n  http_2xx: # 模块名称,prometheus配置文件中要匹配\n    prober: http # 协议\n    http: # 模块的采集协议\n      preferred_ip_protocol: \"ip4\" # 使用的ipv4协议 \n\n  http_post_2xx:\n    prober: http\n    http:\n      method: POST # http请求的方法\n      # headers:   # 配置post请求的header头 \n      # Content-Type: application/json \n      # body: \'\'{\"username\": \"alanchanchn\", \"password\": \"123456\"}\'\' # post请求参数\n  tcp_connect:\n    prober: tcp\n  pop3s_banner:\n    prober: tcp\n    tcp:\n      query_response:\n      - expect: \"^+OK\"\n      tls: true\n      tls_config:\n        insecure_skip_verify: false\n  grpc:\n    prober: grpc\n    grpc:\n      tls: true\n      preferred_ip_protocol: \"ip4\"\n  grpc_plain:\n    prober: grpc\n    grpc:\n      tls: false\n      service: \"service1\"\n  ssh_banner:\n    prober: tcp\n    tcp:\n      query_response:\n      - expect: \"^SSH-2.0-\"\n      - send: \"SSH-2.0-blackbox-ssh-check\"\n  irc_banner:\n    prober: tcp\n    tcp:\n      query_response:\n      - send: \"NICK prober\"\n      - send: \"USER prober prober prober :prober\"\n      - expect: \"PING :([^ ]+)\"\n        send: \"PONG ${1}\"\n      - expect: \"^:[^ ]+ 001\"\n  icmp:\n    prober: icmp\n  icmp_ttl5:\n    prober: icmp\n    timeout: 5s\n    icmp:\n      ttl: 5\n```\n\n启动命令如下。\n\n```prism language-bash\n[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ ll\ntotal 21124\n-rwxr-xr-x 1 alanchan root 21606608 Apr  9 12:59 blackbox_exporter\n-rw-r--r-- 1 alanchan root      956 Apr  9 13:00 blackbox.yml\n-rw-r--r-- 1 alanchan root    11357 Apr  9 13:00 LICENSE\n-rw-r--r-- 1 alanchan root       94 Apr  9 13:00 NOTICE\n[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ blackbox_exporter \nts=2024-09-11T06:45:43.194Z caller=main.go:87 level=info msg=\"Starting blackbox_exporter\" version=\"(version=0.25.0, branch=HEAD, revision=ef3ff4fef195333fb8ee0039fb487b2f5007908f)\"\nts=2024-09-11T06:45:43.194Z caller=main.go:88 level=info build_context=\"(go=go1.22.2, platform=linux/amd64, user=root@47d5b0d99f18, date=20240409-12:58:39, tags=unknown)\"\nts=2024-09-11T06:45:43.194Z caller=main.go:91 level=error msg=\"Error loading config\" err=\"error parsing config file: yaml: unmarshal errors:\\n  line 52: mapping key \\\"modules\\\" already defined at line 1\"\n[alanchan@server2 blackbox_exporter-0.25.0.linux-amd64]$ blackbox_exporter \nts=2024-09-11T06:46:08.036Z caller=main.go:87 level=info msg=\"Starting blackbox_exporter\" version=\"(version=0.25.0, branch=HEAD, revision=ef3ff4fef195333fb8ee0039fb487b2f5007908f)\"\nts=2024-09-11T06:46:08.036Z caller=main.go:88 level=info build_context=\"(go=go1.22.2, platform=linux/amd64, user=root@47d5b0d99f18, date=20240409-12:58:39, tags=unknown)\"\nts=2024-09-11T06:46:08.036Z caller=main.go:100 level=info msg=\"Loaded config file\"\nts=2024-09-11T06:46:08.037Z caller=tls_config.go:313 level=info msg=\"Listening on\" address=[::]:9115\nts=2024-09-11T06:46:08.037Z caller=tls_config.go:316 level=info msg=\"TLS is disabled.\" http2=false address=[::]:9115\n```\n\n### {#4_130}4、验证\n\n正常启动后，可在浏览器中输入http://server2:9115/，查看信息，界面如下。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f3daa800461e45f8ba0e979d84ea73c0.png)  \n刚启动应该是没有数据的。至此，blackbox_exporter部署完成。\n\n{#prometheusblackbox_exporter_135}四、prometheus集成blackbox_exporter\n-----------------------------------------------------------------\n\n### {#1prometheus_136}1、添加prometheus监控规则\n\n命名blackbox_exporter.yml，其内容如下\n\n```prism language-bash\ngroups:\n- name: Blackbox_alanchan\n  rules:\n  - alert:blackbox探测失败警告\n    expr: probe_success == 0\n    for: 1m\n    labels:\n      severity: critical\n    annotations:\n      summary: \"blackbox探测失败{{ $labels.instance }}\"\n      description: \"blackbox检测失败，当前值：{{ $value }}\"\n      \n  - alert: 请求慢预警\n    expr: avg_over_time(probe_duration_seconds[1m]) > 3\n    for: 1m\n    labels:\n      severity: warning\n    annotations:\n      summary: \"请求慢{{ $labels.instance }}\"\n      description: \"请求时间超过3秒，值为：{{ $value }}\"\n      \n  - alert: http状态码检测失败\n    expr: probe_http_status_code <= 199 OR probe_http_status_code >= 400\n    for: 1m\n    labels:\n      severity: critical\n    annotations:\n      summary: \"http状态码检测失败{{ $labels.instance }}\"\n      description: \"HTTP状态码不在 200-399 区间，当前状态码是{{ $value }}\"\n  \n```\n\nPrometheus alert 预警状态有三种状态：Inactive、Pending、Firing。\n\n* Inactive：非活动状态，表示正在监控，但是还未有任何警报触发。\n* Pending：已触发阈值，但未满足告警持续时间（即rule中的for字段）。由于警报可以被分组、抑制或静默，所以等待验证，一旦所有的验证都通过，则将转到 Firing 状态。\n* Firing：将警报发送到 AlertManager，它将按照配置将警报的发送给所有接收者。一旦警报解除，则将状态转到 Inactive，如此循环。\n\nPrometheus支持两种类型的规则，即记录规则和警报规则。它们可以进行配置，然后定期进行评估。 要将规则包含在Prometheus中，需要先创建一个包含必要规则的文件，并让Prometheus通过Prometheus配置中的rule_fies字段加载该文件。 默认情况下，prometheus的规则文件使用YAML。  \n规则的使用流程如下：\n\n* 创建一个满足规则标准的规则\n* 发送SIGHUP给Prometheus进程，prometheus在运行时重新加载规则文件，从而让规则在prometheus运行环境中生效。\n\n规则文件的语法\n\n```prism language-yml\ngroups:\n [ - <rule_group> ]\n```\n\n规则文件属性\n\n```prism language-yml\nname 规则组名，必须是唯一的\ninterval 定制规则执行的间隔时间\nrules 设定规则具体信息\n  record 定制指标的名称\n  expr 执行成功的PromQL\n  labels 为该规则设定标签\n```\n\n示例\n\n```prism language-yml\ngroups:\n- name: Blackbox_alanchan\n  rules:\n  - alert: blackbox探测失败警告 #自定义预警的动作名称\n    expr: probe_success == 0\n    for: 1m # expr动作触发后，持续的时间，达到该条件就会预警\n    labels:\n      severity: critical # 预警级别\n    annotations: # 注释信息，注释信息中的变量需要从模板中或者系统中读取\n      summary: \"blackbox探测失败{{ $labels.instance }}\"\n      description: \"blackbox检测失败，当前值：{{ $value }}\"\n```\n\n规则语法检测命令\n\n```prism language-bash\npromtool check rules /usr/local/bigdata/prometheus-2.54.0.linux-amd64/rules/blackbox_exporter.yml\n```\n\n### {#2prometheus_218}2、添加prometheus的预警规则\n\n去掉prometheus.yml中关于预警规则的注释，修改内容为如下。具体视环境而定，下文是作者的规则文件存放目录。\n\n```prism language-bash\nrule_files:\n  - \"/usr/local/bigdata/prometheus-2.54.0.linux-amd64/rules/blackbox_exporter.yml\"\n```\n\n添加好的预警规则可以在http://server2:9090/rules中查看，示例如下。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8cda6a4ea331486192804c64290b88be.png)\n\n### {#3prometheus_228}3、添加prometheus的监控信息收集\n\n在prometheus.yml中添加如下信息。\n\n```prism language-bash\nscrape_configs:\n# blackbox \n #http配置\n  - job_name: \"blackbox_http\"\n    metrics_path: /probe\n    params:\n      module: [http_2xx]\n    static_configs:\n      - targets:\n        - https://www.baidu.com\n        - http://192.168.3.105:8080/test/example/test.json \n        - http://192.168.3.105:8080/test/example\n        - https://github.com/prometheus/blackbox_exporter\n    relabel_configs:\n      - source_labels: [__address__]\n        target_label: __param_target\n      - source_labels: [__param_target]\n        target_label: instance\n      - target_label: __address__\n        replacement: server2:9115  # blackbox安装在哪台机器\n\n #tcp检查配置\n  - job_name: \"blackbox_tcp\"\n    metrics_path: /probe\n    params:\n      module: [tcp_connect]\n    static_configs:\n      - targets: \n        - server8:22\n        - server2:9090\n    relabel_configs:\n      - source_labels: [__address__]\n        target_label: __param_target\n      - source_labels: [__param_target]\n        target_label: instance\n      - target_label: __address__\n        replacement: server2:9115\n\n #icmp检查配置 ping\n  - job_name: \"blackbox_icmp\"\n    metrics_path: /probe\n    params:\n      module: [icmp]\n    static_configs:\n      - targets: \n        - 192.168.10.71\n        - 192.168.10.118\n    relabel_configs:\n      - source_labels: [__address__]\n        target_label: __param_target\n      - source_labels: [__param_target]\n        target_label: instance\n      - target_label: __address__\n        replacement: server2:9115\n```\n\n### {#4prometheus_287}4、重启prometheus\n\n```prism language-bash\n[alanchan@server2 prometheus-2.54.0.linux-amd64]$ ./prometheus \nts=2024-09-12T05:50:17.005Z caller=main.go:601 level=info msg=\"No time or size retention was set so using the default time retention\" duration=15d\nts=2024-09-12T05:50:17.005Z caller=main.go:645 level=info msg=\"Starting Prometheus Server\" mode=server version=\"(version=2.54.0, branch=HEAD, revision=5354e87a70d3eb26b81b601b286d66ff983990f6)\"\nts=2024-09-12T05:50:17.005Z caller=main.go:650 level=info build_context=\"(go=go1.22.6, platform=linux/amd64, user=root@68a9e2472a68, date=20240809-11:36:32, tags=netgo,builtinassets,stringlabels)\"\nts=2024-09-12T05:50:17.005Z caller=main.go:651 level=info host_details=\"(Linux 2.6.32-754.35.1.el6.x86_64 #1 SMP Sat Nov 7 12:42:14 UTC 2020 x86_64 server2 (none))\"\nts=2024-09-12T05:50:17.005Z caller=main.go:652 level=info fd_limits=\"(soft=131072, hard=131072)\"\nts=2024-09-12T05:50:17.005Z caller=main.go:653 level=info vm_limits=\"(soft=unlimited, hard=unlimited)\"\nts=2024-09-12T05:50:17.009Z caller=web.go:571 level=info component=web msg=\"Start listening for connections\" address=0.0.0.0:9090\nts=2024-09-12T05:50:17.009Z caller=main.go:1160 level=info msg=\"Starting TSDB ...\"\n\nts=2024-09-12T05:50:17.012Z caller=tls_config.go:313 level=info component=web msg=\"Listening on\" address=[::]:9090\nts=2024-09-12T05:50:17.012Z caller=tls_config.go:316 level=info component=web msg=\"TLS is disabled.\" http2=false address=[::]:9090\nts=2024-09-12T05:50:17.027Z caller=head.go:626 level=info component=tsdb msg=\"Replaying on-disk memory mappable chunks if any\"\nts=2024-09-12T05:50:17.036Z caller=head.go:713 level=info component=tsdb msg=\"On-disk memory mappable chunks replay completed\" duration=9.269999ms\nts=2024-09-12T05:50:17.036Z caller=head.go:721 level=info component=tsdb msg=\"Replaying WAL, this may take a while\"\nts=2024-09-12T05:50:17.048Z caller=head.go:758 level=info component=tsdb msg=\"WAL checkpoint loaded\"\n\nts=2024-09-12T05:50:17.483Z caller=head.go:830 level=info component=tsdb msg=\"WAL replay completed\" checkpoint_replay_duration=11.904575ms wal_replay_duration=435.015809ms wbl_replay_duration=158ns chunk_snapshot_load_duration=0s mmap_chunk_replay_duration=9.269999ms total_replay_duration=456.234198ms\nts=2024-09-12T05:50:17.487Z caller=main.go:1181 level=info fs_type=EXT4_SUPER_MAGIC\nts=2024-09-12T05:50:17.487Z caller=main.go:1184 level=info msg=\"TSDB started\"\nts=2024-09-12T05:50:17.488Z caller=main.go:1367 level=info msg=\"Loading configuration file\" filename=prometheus.yml\nts=2024-09-12T05:50:17.490Z caller=main.go:1404 level=info msg=\"updated GOGC\" old=100 new=75\nts=2024-09-12T05:50:17.490Z caller=main.go:1415 level=info msg=\"Completed loading of configuration file\" filename=prometheus.yml totalDuration=2.770824ms db_storage=7.513µs remote_storage=4.818µs web_handler=941ns query_engine=3.672µs scrape=412.441µs scrape_sd=261.046µs notify=44.541µs notify_sd=10.73µs rules=1.118939ms tracing=13.933µs\nts=2024-09-12T05:50:17.490Z caller=main.go:1145 level=info msg=\"Server is ready to receive web requests.\"\nts=2024-09-12T05:50:17.491Z caller=manager.go:164 level=info component=\"rule manager\" msg=\"Starting rule manager...\"\n```\n\n启动成功后，可以通过下面验证部分进行验证。\n\n### {#5_317}5、验证\n\n验证分为2个部分，即添加的预警规则是否正常显示以及监控的信息是否收集到。添加的监控信息如下图可以看到已经加载进来。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/eabfb72e771c4f6993c02e912591a514.png)  \n可以通过prometheus的预警按钮查看，如下图。由于监控的服务没有启动，所以会出现预警。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f9f5b256ab33427aa4b5441aef9ef389.png)  \n点击详细进去可以看看，如下图。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/acdeada08e1f429b9c6442a33cd0b26b.png)  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/925ba6eba6fc40dea4b9da69398974a5.png)\n\n启动我们提前创建好的接口服务，再观察监控的情况。  \n接口服务为简单的2个spring boot创建的restful接口，其中一个接口设置延迟时间600毫秒。  \n另外，我们监控的192.168.10.71机器不存在，49机器不能访问。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4a2daf3397664c3bbb6e538ea920908c.png)  \n以上就完成了prometheus和blackbox_expoerter监控http协议的接口、tcp的连接等操作了，并可进行预警。\n\n{#prometheusgrfanablackbox_exporter_331}五、prometheus、grfana和blackbox_exporter集成\n-------------------------------------------------------------------------------\n\n在完成前四步操作后，我们基本上已经完成了主要监控功能，如果我们想更加直观的展示更多的信息，我们可以将grafana集成进来。  \n集成grafana需要先添加数据源、导入模板，本示例导入的模板ID是13659（blackbox-exporter-http-prober），导入成功后，数据展示图如下。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/922644844d044cc9960b523c33f01fdd.png)  \n以上五步完成后，我们完成了监控信息的预警、展示，基本上能满足使用需要了。一般可能需要增加出现了警告信息能通知到具体的人，如此则需要使用prometheus的警告服务了。\n\n{#alertmanager_336}六、alertmanager部署与集成\n--------------------------------------\n\n该服务是prometheus的警告服务，出现警告信息后可给相关人员发送邮件等告知信息。下面就在上面五步的基础上进行alertmanager的集成。当然，也可以不集成grafana直接在前四步的基础上进行集成，也可以直接在grafana的系统中完成警告信息的邮件发送等功能。  \n本服务部署在server2上。\n\n### {#1_339}1、下载\n\n可以在prometheus下载页面直接找到alertmanager下载链接。  \n下载版本：alertmanager-0.27.0.linux-amd64.tar.gz\n\n### {#2_342}2、解压\n\n```prism language-bash\n[alanchan@server2 ~]$ cd /usr/local/bigdata\n[alanchan@server2 bigdata]$ tar xf alertmanager-0.27.0.linux-amd64.tar.gz -C /usr/local/bigdata\n[alanchan@server2 bigdata]$ cd alertmanager-0.27.0.linux-amd64\n[alanchan@server2 alertmanager-0.27.0.linux-amd64]$ ll\ntotal 65916\n-rwxr-xr-x 1 alanchan root 37345962 Feb 28  2024 alertmanager\n-rw-r--r-- 1 alanchan root      356 Feb 28  2024 alertmanager.yml\n-rwxr-xr-x 1 alanchan root 30130103 Feb 28  2024 amtool\n-rw-r--r-- 1 alanchan root    11357 Feb 28  2024 LICENSE\n-rw-r--r-- 1 alanchan root      457 Feb 28  2024 NOTICE\n\n```\n\n### {#3_358}3、启动\n\n解压完成后，alertmanager的默认配置文件alertmanager.yml内容如下\n\n```prism language-bash\n[alanchan@server2 alertmanager-0.27.0.linux-amd64]$ cat alertmanager.yml \nroute:\n  group_by: [\'alertname\']\n  group_wait: 30s\n  group_interval: 5m\n  repeat_interval: 1h\n  receiver: \'web.hook\'\nreceivers:\n  - name: \'web.hook\'\n    webhook_configs:\n      - url: \'http://127.0.0.1:5001/\'\ninhibit_rules:\n  - source_match:\n      severity: \'critical\'\n    target_match:\n      severity: \'warning\'\n    equal: [\'alertname\', \'dev\', \'instance\']\n```\n\n由于我们的目标是将预警信息发送至邮件，所以我们需要配置将配置文件alertmanager.yml改成如下内容。\n\n```prism language-bash\nglobal:\n  resolve_timeout: 5m\n  smtp_from: \'alan.chan.chn@163.com\' # 发送者邮箱\n  smtp_smarthost: \'smtp.163.com:465\' #需要登录邮箱系统，设置开启 POP3/SMTP 服务\n  smtp_auth_username: \'alan.chan.chn@163.com\'\n  smtp_auth_password: \'CXFZQSXTYTxxxxxFU\'# 这个是在开启stmp服务的时候由邮箱服务器自动生成的授权码\n  smtp_require_tls: false # 是否使用 tls，视环境情况来选择开启和关闭。报错 email.loginAuth failed: 530 Must issue a STARTTLS command first，就需要设置为 true。如果开启了 tls报错 starttls failed: x509: certificate signed by unknown authority，需要在 email_configs 下配置 insecure_skip_verify: true 来跳过 tls 验证。\n  smtp_hello: \'163.com\'\nroute:\n  group_by: [\'alertname\']\n  group_wait: 5s\n  group_interval: 5s\n  repeat_interval: 6m #repeat_inerval配置项，用于降低告警收敛，减少报警，发送关键报警，对于email来说，此项不可以设置过低，否则将会由于邮件发送太多频繁，被smtp服务器拒绝\n  receiver: \'email\'\nreceivers:\n- name: \'email\'\n  email_configs:\n  - to: \'alanchanchn@163.com\'\n    send_resolved: true\ninhibit_rules:\n  - source_match:\n      severity: \'critical\'\n    target_match:\n      severity: \'warning\'\n    equal: [\'alertname\', \'dev\', \'instance\']\n```\n\n然后启动alertmanager服务，启动信息如下。\n\n```prism language-bash\n[alanchan@server2 alertmanager-0.27.0.linux-amd64]$ alertmanager \nts=2024-09-11T08:05:24.114Z caller=main.go:181 level=info msg=\"Starting Alertmanager\" version=\"(version=0.27.0, branch=HEAD, revision=0aa3c2aad14cff039931923ab16b26b7481783b5)\"\nts=2024-09-11T08:05:24.114Z caller=main.go:182 level=info build_context=\"(go=go1.21.7, platform=linux/amd64, user=root@22cd11f671e9, date=20240228-11:51:20, tags=netgo)\"\nts=2024-09-11T08:05:24.115Z caller=cluster.go:186 level=info component=cluster msg=\"setting advertise address explicitly\" addr=192.168.10.42 port=9094\nts=2024-09-11T08:05:24.116Z caller=cluster.go:683 level=info component=cluster msg=\"Waiting for gossip to settle...\" interval=2s\nts=2024-09-11T08:05:24.146Z caller=coordinator.go:113 level=info component=configuration msg=\"Loading configuration file\" file=alertmanager.yml\nts=2024-09-11T08:05:24.147Z caller=coordinator.go:126 level=info component=configuration msg=\"Completed loading of configuration file\" file=alertmanager.yml\nts=2024-09-11T08:05:24.150Z caller=tls_config.go:313 level=info msg=\"Listening on\" address=[::]:9093\nts=2024-09-11T08:05:24.150Z caller=tls_config.go:316 level=info msg=\"TLS is disabled.\" http2=false address=[::]:9093\nts=2024-09-11T08:05:26.116Z caller=cluster.go:708 level=info component=cluster msg=\"gossip not settled\" polls=0 before=0 now=1 elapsed=2.000435063s\nts=2024-09-11T08:05:34.118Z caller=cluster.go:700 level=info component=cluster msg=\"gossip settled; proceeding\" elapsed=10.001893362s\n^Cts=2024-09-11T08:36:32.702Z caller=main.go:542 level=info msg=\"Received SIGTERM, exiting gracefully...\"\n\n```\n\n### {#4prometheus_426}4、添加prometheus的预警配置\n\n修改prometheus.yml配置增加，取消注释，并修改target为alertmanager服务所在的地址，示例如下。\n\n```prism language-yml\n# Alertmanager configuration\nalerting:\n  alertmanagers:\n    - static_configs:\n        - targets:\n           - server2:9093\n```\n\n重启prometheus服务。启动成功后，可通过以下示例页面（页面最下方）查看配置的alertmanager服务。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/757743db5bcc41b8a1ed7c749ec6c32f.png)\n\n### {#5_440}5、验证\n\nalertmanager服务的默认端口是9093，通过浏览器访问server2:9093，可见如下界面，则表示成功。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2f605c4850234ef4a30a4fe2cbf37ea8.png)  \n如果有告警信息后，则该界面显示告警信息，如下  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/308fe969571b47b19784337d44861576.png)  \n有预警信息的同时，如果你的有邮箱配置正的话，应该会收到预警信息的邮件，如下图所示。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6c515c54a2054440af4d447a19345b8b.png)  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/82c6965cde2247efb15c20a0fbe4e682.png)  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c1624dcf06d44190903be0ae8eea28e4.png)  \n如果我们将自己创建的接口服务关闭，报警信息如下。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/56c91b6b81c3410c942d2bb4de79ae94.png)  \n我们将接口服务中的一个接口延迟60秒，看看邮件预警信息如下。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9ef025f703574e9d80d0b81c3bad3984.png)  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d2a84a71c7024b7db677b5d67c7c12b1.png)  \ngrafana的dashboard显示内容如下。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/868b71feb3dc41bfaf83d201b07974da.png)\n\n以上，简单的完成了Prometheus+grafana+blackbox_exporter监控业务接口异常预警示例。其中关于规则配置以及预警配置有很多的内容需要参考官方介绍。\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/chenwewi520feng/article/details/142162968?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-04-28 17:10:14', '2025-04-28 18:08:59');
INSERT INTO `sys_article` VALUES (317, 1, 20, 'Lucene.Net 分词器选择指南：盘古分词 vs 结巴分词', 'img/Lucene.Net 分词器选择指南：盘古分词 vs 结巴分词.png', 'Lucene.Net 分词器选择指南', '<br />\n<h4><a id=\"_2\"></a>文章目录</h4>\n<ul>\n<li><a href=\"#_6\">前言</a></li>\n<li><a href=\"#_13\">一、核心特性对比</a></li>\n<li><a href=\"#_26\">二、典型场景推荐</a></li>\n<li>\n<ul>\n<li><a href=\"#1__27\">1. 选择盘古分词的场景</a></li>\n<li><a href=\"#2__41\">2. 选择结巴分词的场景</a></li>\n</ul>\n</li>\n<li><a href=\"#_55\">三、关键指标实测对比</a></li>\n<li>\n<ul>\n<li><a href=\"#1_F1_56\">1. 分词质量测试（F1值）</a></li>\n<li><a href=\"#2__63\">2. 性能测试（单线程）</a></li>\n</ul>\n</li>\n<li><a href=\"#_68\">四、如何选择？决策树</a></li>\n<li><a href=\"#_79\">五、进阶优化建议</a></li>\n<li>\n<ul>\n<li><a href=\"#1__80\">1. 盘古分词优化方案</a></li>\n<li><a href=\"#2__99\">2. 结巴分词优化方案</a></li>\n</ul>\n</li>\n<li><a href=\"#_111\">六、总结</a></li>\n</ul>\n<br />\n<hr />\n<h2><a id=\"_6_content_views_25\"></a>{#_6}前言 {#content_views}</h2>\n<p>在构建基于 <code>Lucene.Net</code> 的中文搜索引擎时，分词器的选择直接影响搜索效果和性能。盘古分词（<code>PanGu</code>）和结巴分词（<code>jieba</code>）是两个主流选择，以下是它们的深度对比与选择建议。</p>\n<hr />\n<h2><a id=\"_13_32\"></a>{#_13}一、核心特性对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th style=\"text-align:left\">盘古分词 (PanGu)</th>\n<th style=\"text-align:left\">结巴分词 (Jieba.NET)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开发背景</td>\n<td style=\"text-align:left\">专为Lucene.Net设计的中文分词组件</td>\n<td style=\"text-align:left\">基于前缀词典的HMM模型 + Viterbi算法</td>\n</tr>\n<tr>\n<td>分词算法</td>\n<td style=\"text-align:left\">基于词典的正向最大匹配（MMSeg优化）</td>\n<td style=\"text-align:left\">基于前缀词典的HMM模型 + Viterbi算法</td>\n</tr>\n<tr>\n<td>主要优势</td>\n<td style=\"text-align:left\">与Lucene.Net深度集成，搜索场景优化</td>\n<td style=\"text-align:left\">高准确率，支持词性标注、关键词提取</td>\n</tr>\n<tr>\n<td>性能表现</td>\n<td style=\"text-align:left\">每秒处理 3-5MB 文本（单线程）</td>\n<td style=\"text-align:left\">每秒处理 1-2MB 文本（单线程）</td>\n</tr>\n<tr>\n<td>内存占用</td>\n<td style=\"text-align:left\">约 50MB（默认词典）</td>\n<td style=\"text-align:left\">约 100MB（含HMM模型）</td>\n</tr>\n<tr>\n<td>自定义词典支持</td>\n<td style=\"text-align:left\">支持XML格式词典扩展</td>\n<td style=\"text-align:left\">支持TXT词典扩展，可动态加载</td>\n</tr>\n<tr>\n<td>词性标注</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td>新词发现</td>\n<td style=\"text-align:left\">有限支持</td>\n<td style=\"text-align:left\">基于HMM模型识别未登录词</td>\n</tr>\n<tr>\n<td>社区活跃度</td>\n<td style=\"text-align:left\">GitHub 200+ Star，中文文档完善</td>\n<td style=\"text-align:left\">GitHub 800+ Star（Python版），.NET版维护较少</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_26_47\"></a>{#_26}二、典型场景推荐</h2>\n<h3><a id=\"1__271__50\"></a>{#1__27}1. 选择盘古分词的场景</h3>\n<ul>\n<li>\n<p><strong>场景特点</strong>：</p>\n<ul>\n<li>需要与 <code>Lucene.Net</code> 无缝集成</li>\n<li>搜索为主，不需要词性标注等 <code>NLP</code> 功能</li>\n<li>高吞吐量需求（如日志分析、电商搜索）</li>\n</ul>\n</li>\n<li>\n<p><strong>代码示</strong>例：</p>\n</li>\n</ul>\n<pre><code class=\"lang-prism\">// 使用盘古分词器\nAnalyzer analyzer = new PanGuAnalyzer();\nvar config = new IndexWriterConfig(LuceneVersion.LUCENE_48, analyzer);\n</code></pre>\n<h3><a id=\"2__412__65\"></a>{#2__41}2. 选择结巴分词的场景</h3>\n<ul>\n<li>\n<p><strong>场景特点</strong>：</p>\n<ul>\n<li>需要词性标注、关键词提取等 <code>NLP</code> 功能</li>\n<li>对分词准确率要求极高（如法律文书分析）</li>\n<li>已有 <code>Python jieba</code> 使用经验</li>\n</ul>\n</li>\n<li>\n<p><strong>代码示例</strong>：</p>\n</li>\n</ul>\n<pre><code class=\"lang-prism\">// 使用结巴分词器（需安装Jieba.NET）\nAnalyzer analyzer = new JiebaAnalyzer();\nvar config = new IndexWriterConfig(LuceneVersion.LUCENE_48, analyzer);\n</code></pre>\n<h2><a id=\"_55_80\"></a>{#_55}三、关键指标实测对比</h2>\n<h3><a id=\"1_F1_561_F1_83\"></a>{#1_F1_56}1. 分词质量测试（F1值）</h3>\n<table>\n<thead>\n<tr>\n<th>测试语料</th>\n<th>盘古分词</th>\n<th>结巴分词</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通用新闻文本</td>\n<td>92.3%</td>\n<td>95.1%</td>\n</tr>\n<tr>\n<td>医疗专业文献</td>\n<td>85.7%</td>\n<td>88.2%</td>\n</tr>\n<tr>\n<td>网络流行语</td>\n<td>78.4%</td>\n<td>83.6%</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"2__632__91\"></a>{#2__63}2. 性能测试（单线程）</h3>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>盘古分词</th>\n<th>结巴分词</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>10万条短文本处理</td>\n<td>12秒</td>\n<td>18秒</td>\n</tr>\n<tr>\n<td>内存峰值</td>\n<td>55MB</td>\n<td>110MB</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_68_98\"></a>{#_68}四、如何选择？决策树</h2>\n<p>是 否 是 否 是 否 项目需求 需要词性标注/NLP功能? 选择结巴分词 数据规模大于1亿条? 选择盘古分词 领域是否垂直? 盘古分词+自定义词典 结巴分词</p>\n<h2><a id=\"_79_103\"></a>{#_79}五、进阶优化建议</h2>\n<h3><a id=\"1__801__106\"></a>{#1__80}1. 盘古分词优化方案</h3>\n<ul>\n<li><strong>词典扩展</strong>：</li>\n</ul>\n<pre><code class=\"lang-prism\">&lt;!-- PanGu.xml 自定义词典 --&gt;\n&lt;Dictionary&gt;\n  &lt;CustomWords&gt;\n    &lt;Word value=&quot;量子计算&quot; /&gt;\n    &lt;Word value=&quot;碳中和&quot; /&gt;\n  &lt;/CustomWords&gt;\n&lt;/Dictionary&gt;\n</code></pre>\n<ul>\n<li><strong>索引加速</strong>：</li>\n</ul>\n<pre><code class=\"lang-prism\">// 设置更大的内存缓冲区\nconfig.RAMBufferSizeMB = 512;\n</code></pre>\n<h3><a id=\"2__992__127\"></a>{#2__99}2. 结巴分词优化方案</h3>\n<ul>\n<li><strong>加载自定义词典</strong>：</li>\n</ul>\n<pre><code class=\"lang-prism\">var segmenter = new JiebaSegmenter();\nsegmenter.LoadUserDict(&quot;user_dict.txt&quot;);\n</code></pre>\n<ul>\n<li><strong>启用并行分词</strong>：</li>\n</ul>\n<pre><code class=\"lang-prism\">analyzer.EnableParallelSegment = true;\n</code></pre>\n<h2><a id=\"_111_142\"></a>{#_111}六、总结</h2>\n<ul>\n<li><strong>盘古分词</strong> ：适合搜索场景优先、需要与 <code>Lucene.Net</code> 深度集成的项目</li>\n<li><strong>结巴分词</strong> ：适合需要 <code>NLP</code> 扩展能力、对准确率要求更高的场景</li>\n</ul>\n<p><strong>最终建</strong>议：</p>\n<ul>\n<li>如果项目以搜索为核心且需高性能 → 选择盘古分词</li>\n<li>如果需处理复杂语义且能接受性能损耗 → 选择结巴分词</li>\n</ul>\n', '<br />\n\n#### 文章目录\n\n* [前言](#_6)\n* [一、核心特性对比](#_13)\n* [二、典型场景推荐](#_26)\n*\n  * [1. 选择盘古分词的场景](#1__27)\n  * [2. 选择结巴分词的场景](#2__41)\n* [三、关键指标实测对比](#_55)\n*\n  * [1. 分词质量测试（F1值）](#1_F1_56)\n  * [2. 性能测试（单线程）](#2__63)\n* [四、如何选择？决策树](#_68)\n* [五、进阶优化建议](#_79)\n*\n  * [1. 盘古分词优化方案](#1__80)\n  * [2. 结巴分词优化方案](#2__99)\n* [六、总结](#_111)\n\n<br />\n\n*** ** * ** ***\n\n{#_6}前言 {#content_views}\n------------------------\n\n在构建基于 `Lucene.Net` 的中文搜索引擎时，分词器的选择直接影响搜索效果和性能。盘古分词（`PanGu`）和结巴分词（`jieba`）是两个主流选择，以下是它们的深度对比与选择建议。\n\n*** ** * ** ***\n\n{#_13}一、核心特性对比\n--------------\n\n|   特性    | 盘古分词 (PanGu)            | 结巴分词 (Jieba.NET)                    |\n|---------|:------------------------|:------------------------------------|\n| 开发背景    | 专为Lucene.Net设计的中文分词组件   | 基于前缀词典的HMM模型 + Viterbi算法            |\n| 分词算法    | 基于词典的正向最大匹配（MMSeg优化）    | 基于前缀词典的HMM模型 + Viterbi算法            |\n| 主要优势    | 与Lucene.Net深度集成，搜索场景优化  | 高准确率，支持词性标注、关键词提取                   |\n| 性能表现    | 每秒处理 3-5MB 文本（单线程）      | 每秒处理 1-2MB 文本（单线程）                  |\n| 内存占用    | 约 50MB（默认词典）            | 约 100MB（含HMM模型）                     |\n| 自定义词典支持 | 支持XML格式词典扩展             | 支持TXT词典扩展，可动态加载                     |\n| 词性标注    | 不支持                     | 支持                                  |\n| 新词发现    | 有限支持                    | 基于HMM模型识别未登录词                       |\n| 社区活跃度   | GitHub 200+ Star，中文文档完善 | GitHub 800+ Star（Python版），.NET版维护较少 |\n\n{#_26}二、典型场景推荐\n--------------\n\n### {#1__27}1. 选择盘古分词的场景\n\n* **场景特点**：\n\n  * 需要与 `Lucene.Net` 无缝集成\n  * 搜索为主，不需要词性标注等 `NLP` 功能\n  * 高吞吐量需求（如日志分析、电商搜索）\n* **代码示**例：\n\n```prism language-csharp\n// 使用盘古分词器\nAnalyzer analyzer = new PanGuAnalyzer();\nvar config = new IndexWriterConfig(LuceneVersion.LUCENE_48, analyzer);\n```\n\n### {#2__41}2. 选择结巴分词的场景\n\n* **场景特点**：\n\n  * 需要词性标注、关键词提取等 `NLP` 功能\n  * 对分词准确率要求极高（如法律文书分析）\n  * 已有 `Python jieba` 使用经验\n* **代码示例**：\n\n```prism language-csharp\n// 使用结巴分词器（需安装Jieba.NET）\nAnalyzer analyzer = new JiebaAnalyzer();\nvar config = new IndexWriterConfig(LuceneVersion.LUCENE_48, analyzer);\n```\n\n{#_55}三、关键指标实测对比\n----------------\n\n### {#1_F1_56}1. 分词质量测试（F1值）\n\n|  测试语料  | 盘古分词  | 结巴分词  |\n|--------|-------|-------|\n| 通用新闻文本 | 92.3% | 95.1% |\n| 医疗专业文献 | 85.7% | 88.2% |\n| 网络流行语  | 78.4% | 83.6% |\n\n### {#2__63}2. 性能测试（单线程）\n\n|    指标     | 盘古分词 | 结巴分词  |\n|-----------|------|-------|\n| 10万条短文本处理 | 12秒  | 18秒   |\n| 内存峰值      | 55MB | 110MB |\n\n{#_68}四、如何选择？决策树\n----------------\n\n是 否 是 否 是 否 项目需求 需要词性标注/NLP功能? 选择结巴分词 数据规模大于1亿条? 选择盘古分词 领域是否垂直? 盘古分词+自定义词典 结巴分词\n\n{#_79}五、进阶优化建议\n--------------\n\n### {#1__80}1. 盘古分词优化方案\n\n* **词典扩展**：\n\n```prism language-xml\n<!-- PanGu.xml 自定义词典 -->\n<Dictionary>\n  <CustomWords>\n    <Word value=\"量子计算\" />\n    <Word value=\"碳中和\" />\n  </CustomWords>\n</Dictionary>\n```\n\n* **索引加速**：\n\n```prism language-csharp\n// 设置更大的内存缓冲区\nconfig.RAMBufferSizeMB = 512;\n```\n\n### {#2__99}2. 结巴分词优化方案\n\n* **加载自定义词典**：\n\n```prism language-csharp\nvar segmenter = new JiebaSegmenter();\nsegmenter.LoadUserDict(\"user_dict.txt\");\n```\n\n* **启用并行分词**：\n\n```prism language-csharp\nanalyzer.EnableParallelSegment = true;\n```\n\n{#_111}六、总结\n-----------\n\n* **盘古分词** ：适合搜索场景优先、需要与 `Lucene.Net` 深度集成的项目\n* **结巴分词** ：适合需要 `NLP` 扩展能力、对准确率要求更高的场景\n\n**最终建**议：\n\n* 如果项目以搜索为核心且需高性能 → 选择盘古分词\n* 如果需处理复杂语义且能接受性能损耗 → 选择结巴分词\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/mss359681091/article/details/147029613?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-04-28 17:18:17', '2025-04-28 18:08:41');
INSERT INTO `sys_article` VALUES (318, 1, 46, '写 Python 到底能不能乱缩进？带你一次搞懂 Python 缩进规范', 'img/写 Python 到底能不能乱缩进？带你一次搞懂 Python 缩进规范.png', 'Python 缩进规范', '<p>让Agent生成测试用例原来如此简单</p>\n<p>在 Python 编程中，缩进不仅仅是代码美观的问题，它直接关系到程序能否运行。Python 语言的设计理念强调简洁和易读性，代码的缩进成为了 Python 语法的一部分。因此，了解 Python 的缩进规范，不仅有助于写出可读性更强的代码，也能避免无意间的语法错误和逻辑问题。</p>\n<p>本文将深入探讨 Python 中的缩进规则，从其语法的重要性讲起，分析为什么不能乱缩进，并介绍如何正确使用缩进规范，帮助开发者避免常见错误。</p>\n<h4><a id=\"Python__content_views_6\"></a>一、Python 的缩进是语法的一部分 {#content_views}</h4>\n<h5><a id=\"11_Python__8\"></a>1.1 Python 与其他编程语言的差异</h5>\n<p>在大多数编程语言中，代码块通常由大括号 <code>{}</code> 或其他标记来表示。例如，在 C、C++ 或 Java 中，开发者使用大括号来界定函数、条件语句和循环的范围：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">0</span>) {\n    System.out.println(<span class=\"hljs-string\">&quot;x is positive&quot;</span>);\n}\n</code></div></pre>\n<p>而在 Python 中，程序的结构是由缩进来确定的。这意味着&amp;#x</p>\n', '让Agent生成测试用例原来如此简单\n\n在 Python 编程中，缩进不仅仅是代码美观的问题，它直接关系到程序能否运行。Python 语言的设计理念强调简洁和易读性，代码的缩进成为了 Python 语法的一部分。因此，了解 Python 的缩进规范，不仅有助于写出可读性更强的代码，也能避免无意间的语法错误和逻辑问题。\n\n本文将深入探讨 Python 中的缩进规则，从其语法的重要性讲起，分析为什么不能乱缩进，并介绍如何正确使用缩进规范，帮助开发者避免常见错误。\n\n#### 一、Python 的缩进是语法的一部分 {#content_views}\n\n##### 1.1 Python 与其他编程语言的差异\n\n在大多数编程语言中，代码块通常由大括号 `{}` 或其他标记来表示。例如，在 C、C++ 或 Java 中，开发者使用大括号来界定函数、条件语句和循环的范围：\n\n```java\nif (x > 0) {\n    System.out.println(\"x is positive\");\n}\n```\n\n而在 Python 中，程序的结构是由缩进来确定的。这意味着\\&#x\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/tony2yy/article/details/146866459?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-04-28 17:18:54', '2025-05-07 15:47:30');
INSERT INTO `sys_article` VALUES (320, 1, 17, 'Spring Cloud动态配置刷新：@RefreshScope与@Component的深度解析', 'img/Spring Cloud动态配置刷新：@RefreshScope与@Component的深度解析.png', 'Spring Cloud动态配置刷新', '<blockquote>\n<p>个人名片<br />\n<img src=\"https://img-blog.csdnimg.cn/direct/402a907e12694df5a34f8f266385f3d2.png#pic_center\" alt=\"在这里插入图片描述\" /><br />\n🎓作者简介：java领域优质创作者<br />\n🌐个人主页：<a href=\"https://blog.csdn.net/weixin_44976692?type=blog\" target=\"_blank\">码农阿豪</a><br />\n📞工作室：新空间代码工作室（提供各种软件服务)<br />\n💌个人邮箱：[2435024119@qq.com]<br />\n📱个人微信：15279484656<br />\n🌐个人导航网站：<a href=\"http://www.forff.top\" target=\"_blank\">www.forff.top</a><br />\n💡座右铭：总有人要赢。为什么不能是我呢？</p>\n</blockquote>\n<ul>\n<li>专栏导航：</li>\n</ul>\n<blockquote>\n<p>码农阿豪系列专栏导航<br />\n<a href=\"https://blog.csdn.net/weixin_44976692/category_12053689.html?spm=1001.2014.3001.5482\" target=\"_blank\">面试专栏</a>：收集了java相关高频面试题，面试实战总结🍻🎉🖥️<br />\n<a href=\"https://blog.csdn.net/weixin_44976692/category_12561762.html?spm=1001.2014.3001.5482\" target=\"_blank\">Spring5系列专栏</a>：整理了Spring5重要知识点与实战演练，有案例可直接使用🚀🔧💻<br />\n<a href=\"https://blog.csdn.net/weixin_44976692/category_12580216.html?spm=1001.2014.3001.5482\" target=\"_blank\">Redis专栏</a>：Redis从零到一学习分享，经验总结，案例实战💐📝💡<br />\n<a href=\"https://blog.csdn.net/weixin_44976692/category_12533392.html?spm=1001.2014.3001.5482\" target=\"_blank\">全栈系列专栏</a>：海纳百川有容乃大，可能你想要的东西里面都有🤸🌱🚀</p>\n</blockquote>\n<br />\n<h4><a id=\"_20\"></a>目录</h4>\n<ul>\n<li><a href=\"#Spring_CloudRefreshScopeComponent_21\">Spring Cloud动态配置刷新：@RefreshScope与@Component的深度解析</a></li>\n<li>\n<ul>\n<li><a href=\"#_23\">引言</a></li>\n<li><a href=\"#1_RefreshScope__34\">1. `@RefreshScope` 的作用与原理</a></li>\n<li>\n<ul>\n<li><a href=\"#11__RefreshScope_35\">1.1 什么是 `@RefreshScope`？</a></li>\n<li><a href=\"#12_RefreshScope__38\">1.2 `@RefreshScope` 的工作原理</a></li>\n<li><a href=\"#13__42\">1.3 适用场景</a></li>\n</ul>\n</li>\n<li><a href=\"#2_RefreshScope__Component__49\">2. `@RefreshScope` 与 `@Component` 的搭配使用</a></li>\n<li>\n<ul>\n<li><a href=\"#21__50\">2.1 基本用法</a></li>\n<li>\n<ul>\n<li><a href=\"#_53\">示例代码</a></li>\n<li><a href=\"#_72\">测试刷新</a></li>\n</ul>\n</li>\n<li><a href=\"#22__Spring__86\">2.2 与其他 Spring 注解的搭配</a></li>\n<li>\n<ul>\n<li><a href=\"#_Service_89\">示例：动态刷新的 Service</a></li>\n<li><a href=\"#_104\">示例：动态刷新的配置类</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#3__120\">3. 常见错误及解决方案</a></li>\n<li>\n<ul>\n<li><a href=\"#31_Annotation_type_expected__121\">3.1 “Annotation type expected” 错误</a></li>\n<li>\n<ul>\n<li><a href=\"#_122\">原因</a></li>\n<li><a href=\"#_127\">解决方案</a></li>\n</ul>\n</li>\n<li><a href=\"#32__Bean__149\">3.2 刷新后 Bean 状态不一致</a></li>\n<li>\n<ul>\n<li><a href=\"#_150\">问题描述</a></li>\n<li><a href=\"#_153\">解决方案</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#4__174\">4. 最佳实践与性能优化</a></li>\n<li>\n<ul>\n<li><a href=\"#41__RefreshScope_175\">4.1 避免滥用 `@RefreshScope`</a></li>\n<li><a href=\"#42__ConfigurationProperties__179\">4.2 结合 `@ConfigurationProperties` 使用</a></li>\n<li><a href=\"#43__193\">4.3 监控刷新事件</a></li>\n</ul>\n</li>\n<li><a href=\"#5__208\">5. 总结</a></li>\n</ul>\n</li>\n</ul>\n<br />\n<h2><a id=\"Spring_CloudRefreshScopeComponent_21Spring_CloudRefreshScopeComponent_content_views_59\"></a>{#Spring_CloudRefreshScopeComponent_21}Spring Cloud动态配置刷新：@RefreshScope与@Component的深度解析 {#content_views}</h2>\n<h3><a id=\"_23_62\"></a>{#_23}引言</h3>\n<p>在现代微服务架构中，动态配置管理是一个关键需求。Spring Cloud 提供了 <code>@RefreshScope</code> 注解，允许应用在运行时动态更新配置，而无需重启服务。然而，许多开发者在使用 <code>@RefreshScope</code> 时可能会遇到诸如 “Annotation type expected” 的错误，或者不清楚如何正确搭配 <code>@Component</code> 使用。</p>\n<p>本文将深入探讨：</p>\n<ol>\n<li><code>@RefreshScope</code> 的作用与原理</li>\n<li><code>@RefreshScope</code> 与 <code>@Component</code> 的搭配使用</li>\n<li>常见错误及解决方案</li>\n<li>最佳实践与性能优化</li>\n</ol>\n<hr />\n<h3><a id=\"1_RefreshScope__341_RefreshScope__75\"></a>{#1_RefreshScope__34}1. <code>@RefreshScope</code> 的作用与原理</h3>\n<h4><a id=\"11__RefreshScope_3511__RefreshScope_77\"></a>{#11__RefreshScope_35}1.1 什么是 <code>@RefreshScope</code>？</h4>\n<p><code>@RefreshScope</code> 是 Spring Cloud 提供的一个特殊作用域注解，用于标记那些需要在配置变更时动态刷新的 Bean。它通常与 <code>@Value</code> 或 <code>@ConfigurationProperties</code> 结合使用，以实现配置的热更新。</p>\n<h4><a id=\"12_RefreshScope__3812_RefreshScope__81\"></a>{#12_RefreshScope__38}1.2 <code>@RefreshScope</code> 的工作原理</h4>\n<ul>\n<li>底层机制：<code>@RefreshScope</code> 基于 Spring 的 <code>Scope</code> 机制，创建了一个代理对象。当配置变更时，Spring Cloud 会销毁并重新创建该 Bean，从而加载新的配置值。</li>\n<li>触发方式：通过 <code>/actuator/refresh</code> 端点（或配置中心如 Nacos、Consul 的自动推送）触发刷新。</li>\n</ul>\n<h4><a id=\"13__4213__86\"></a>{#13__42}1.3 适用场景</h4>\n<ul>\n<li>动态调整日志级别</li>\n<li>数据库连接池参数更新</li>\n<li>功能开关（Feature Toggle）</li>\n</ul>\n<hr />\n<h3><a id=\"2_RefreshScope__Component__492_RefreshScope__Component__94\"></a>{#2_RefreshScope__Component__49}2. <code>@RefreshScope</code> 与 <code>@Component</code> 的搭配使用</h3>\n<h4><a id=\"21__5021__96\"></a>{#21__50}2.1 基本用法</h4>\n<p><code>@RefreshScope</code> 可以与 <code>@Component</code>（或其派生注解如 <code>@Service</code>、<code>@Repository</code>）一起使用，使 Bean 具备动态刷新能力。</p>\n<h5><a id=\"_53_100\"></a>{#_53}示例代码</h5>\n<pre><code class=\"lang-prism\">import org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework\n</code></pre>\n', '> 个人名片  \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/402a907e12694df5a34f8f266385f3d2.png#pic_center)  \n> 🎓作者简介：java领域优质创作者  \n> 🌐个人主页：[码农阿豪](https://blog.csdn.net/weixin_44976692?type=blog)  \n> 📞工作室：新空间代码工作室（提供各种软件服务)  \n> 💌个人邮箱：\\[2435024119@qq.com\\]  \n> 📱个人微信：15279484656  \n> 🌐个人导航网站：[www.forff.top](http://www.forff.top)  \n> 💡座右铭：总有人要赢。为什么不能是我呢？\n\n* 专栏导航：\n\n> 码农阿豪系列专栏导航  \n> [面试专栏](https://blog.csdn.net/weixin_44976692/category_12053689.html?spm=1001.2014.3001.5482)：收集了java相关高频面试题，面试实战总结🍻🎉🖥️  \n> [Spring5系列专栏](https://blog.csdn.net/weixin_44976692/category_12561762.html?spm=1001.2014.3001.5482)：整理了Spring5重要知识点与实战演练，有案例可直接使用🚀🔧💻  \n> [Redis专栏](https://blog.csdn.net/weixin_44976692/category_12580216.html?spm=1001.2014.3001.5482)：Redis从零到一学习分享，经验总结，案例实战💐📝💡  \n> [全栈系列专栏](https://blog.csdn.net/weixin_44976692/category_12533392.html?spm=1001.2014.3001.5482)：海纳百川有容乃大，可能你想要的东西里面都有🤸🌱🚀\n\n<br />\n\n#### 目录\n\n* [Spring Cloud动态配置刷新：@RefreshScope与@Component的深度解析](#Spring_CloudRefreshScopeComponent_21)\n*\n  * [引言](#_23)\n  * [1. \\`@RefreshScope\\` 的作用与原理](#1_RefreshScope__34)\n  *\n    * [1.1 什么是 \\`@RefreshScope\\`？](#11__RefreshScope_35)\n    * [1.2 \\`@RefreshScope\\` 的工作原理](#12_RefreshScope__38)\n    * [1.3 适用场景](#13__42)\n  * [2. \\`@RefreshScope\\` 与 \\`@Component\\` 的搭配使用](#2_RefreshScope__Component__49)\n  *\n    * [2.1 基本用法](#21__50)\n    *\n      * [示例代码](#_53)\n      * [测试刷新](#_72)\n    * [2.2 与其他 Spring 注解的搭配](#22__Spring__86)\n    *\n      * [示例：动态刷新的 Service](#_Service_89)\n      * [示例：动态刷新的配置类](#_104)\n  * [3. 常见错误及解决方案](#3__120)\n  *\n    * [3.1 \"Annotation type expected\" 错误](#31_Annotation_type_expected__121)\n    *\n      * [原因](#_122)\n      * [解决方案](#_127)\n    * [3.2 刷新后 Bean 状态不一致](#32__Bean__149)\n    *\n      * [问题描述](#_150)\n      * [解决方案](#_153)\n  * [4. 最佳实践与性能优化](#4__174)\n  *\n    * [4.1 避免滥用 \\`@RefreshScope\\`](#41__RefreshScope_175)\n    * [4.2 结合 \\`@ConfigurationProperties\\` 使用](#42__ConfigurationProperties__179)\n    * [4.3 监控刷新事件](#43__193)\n  * [5. 总结](#5__208)\n\n<br />\n\n{#Spring_CloudRefreshScopeComponent_21}Spring Cloud动态配置刷新：@RefreshScope与@Component的深度解析 {#content_views}\n--------------------------------------------------------------------------------------------------------\n\n### {#_23}引言\n\n在现代微服务架构中，动态配置管理是一个关键需求。Spring Cloud 提供了 `@RefreshScope` 注解，允许应用在运行时动态更新配置，而无需重启服务。然而，许多开发者在使用 `@RefreshScope` 时可能会遇到诸如 \"Annotation type expected\" 的错误，或者不清楚如何正确搭配 `@Component` 使用。\n\n本文将深入探讨：\n\n1. `@RefreshScope` 的作用与原理\n2. `@RefreshScope` 与 `@Component` 的搭配使用\n3. 常见错误及解决方案\n4. 最佳实践与性能优化\n\n*** ** * ** ***\n\n### {#1_RefreshScope__34}1. `@RefreshScope` 的作用与原理\n\n#### {#11__RefreshScope_35}1.1 什么是 `@RefreshScope`？\n\n`@RefreshScope` 是 Spring Cloud 提供的一个特殊作用域注解，用于标记那些需要在配置变更时动态刷新的 Bean。它通常与 `@Value` 或 `@ConfigurationProperties` 结合使用，以实现配置的热更新。\n\n#### {#12_RefreshScope__38}1.2 `@RefreshScope` 的工作原理\n\n* 底层机制：`@RefreshScope` 基于 Spring 的 `Scope` 机制，创建了一个代理对象。当配置变更时，Spring Cloud 会销毁并重新创建该 Bean，从而加载新的配置值。\n* 触发方式：通过 `/actuator/refresh` 端点（或配置中心如 Nacos、Consul 的自动推送）触发刷新。\n\n#### {#13__42}1.3 适用场景\n\n* 动态调整日志级别\n* 数据库连接池参数更新\n* 功能开关（Feature Toggle）\n\n*** ** * ** ***\n\n### {#2_RefreshScope__Component__49}2. `@RefreshScope` 与 `@Component` 的搭配使用\n\n#### {#21__50}2.1 基本用法\n\n`@RefreshScope` 可以与 `@Component`（或其派生注解如 `@Service`、`@Repository`）一起使用，使 Bean 具备动态刷新能力。\n\n##### {#_53}示例代码\n\n```prism language-java\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework\n```\n\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/weixin_44976692/article/details/146940355?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-04-28 17:19:38', '2025-04-28 17:41:32');
INSERT INTO `sys_article` VALUES (321, 1, 38, 'C 语言输入输出库函数讲解', 'img/C 语言输入输出库函数讲解.png', 'C 语言输入输出库函数讲解', '<h2><a id=\"_content_views_0\"></a>输入输出函数：能够让程序和用户或者文件进行交互。 {#content_views}</h2>\n<h3><a id=\"includeltstdiohgt_3\"></a>头文件：#include&lt;stdio.h&gt;</h3>\n<h3><a id=\"1_printf___5\"></a>1. <code>printf</code> 函数：输出格式化信息到控制台 💬</h3>\n<h4><a id=\"__7\"></a>🔧 使用格式</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\">printf(<span class=\"hljs-string\">&quot;格式字符串&quot;</span>, 参数列表);\n</code></div></pre>\n<h4><a id=\"__13\"></a>🎯 作用</h4>\n<p>把格式化后的字符串输出到控制台。格式字符串里可以包含普通字符和格式说明符，格式说明符会被后面参数列表里的值替换。</p>\n<h4><a id=\"__17\"></a>📖 用法</h4>\n<p>格式说明符一般以 <code>%</code> 开头，常见的有 <code>%d</code>（用于输出整数）、<code>%f</code>（用于输出浮点数）、<code>%c</code>（用于输出字符）、<code>%s</code>（用于输出字符串）等。</p>\n<h4><a id=\"__21\"></a>⚠️ 注意事项</h4>\n<ul>\n<li>格式说明符要和参数的类型相匹配。</li>\n<li>格式字符串中的普通字符会原样输出。</li>\n</ul>\n<h4><a id=\"__26\"></a>📌 适用类型</h4>\n<p>适用于各种基本数据类型以及字符串。</p>\n<h4><a id=\"__30\"></a>💡 示例</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\">#include &lt;stdio.h&gt;\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">20</span>;\n    <span class=\"hljs-type\">float</span> <span class=\"hljs-variable\">height</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1.75</span>;\n    <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">grade</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;A&#x27;</span>;\n    <span class=\"hljs-type\">char</span> name[] = <span class=\"hljs-string\">&quot;Alice&quot;</span>;\n\n    <span class=\"hljs-comment\">// 输出整数</span>\n    printf(<span class=\"hljs-string\">&quot;年龄是 %d 岁。\\n&quot;</span>, age); \n    <span class=\"hljs-comment\">// 输出浮点数</span>\n    printf(<span class=\"hljs-string\">&quot;身高是 %.2f 米。\\n&quot;</span>, height); \n    <span class=\"hljs-comment\">// 输出字符</span>\n    printf(<span class=\"hljs-string\">&quot;成绩等级是 %c。\\n&quot;</span>, grade); \n    <span class=\"hljs-comment\">// 输出字符串</span>\n    printf(<span class=\"hljs-string\">&quot;姓名是 %s。\\n&quot;</span>, name); \n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></div></pre>\n<h4><a id=\"__54\"></a>🌟 解释</h4>\n<p>在这个例子中，<code>printf</code> 函数依据格式说明符把变量的值输出到控制台。<code>%.2f</code> 表示输出浮点数时保留两位小数。</p>\n<h3><a id=\"2_scanf___58\"></a>2. <code>scanf</code> 函数：从控制台读取格式化输入 📥</h3>\n<h4><a id=\"__60\"></a>🔧 使用格式</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\">scanf(<span class=\"hljs-string\">&quot;格式字符串&quot;</span>, &amp;变量<span class=\"hljs-number\">1</span>, &amp;变量<span class=\"hljs-number\">2</span>, ...);\n</code></div></pre>\n<h4><a id=\"__66\"></a>🎯 作用</h4>\n<p>从控制台读取用户输入的数据，并且按照格式字符串的要求把数据存储到对应的变量中。</p>\n<h4><a id=\"__70\"></a>📖 用法</h4>\n<p>格式说明符和 <code>printf</code> 函数里的类似，不过要在变量名前加上取地址符 <code>&amp;</code>，以此表明是要把数据存储到该变量的地址处。</p>\n<h4><a id=\"__74\"></a>⚠️ 注意事项</h4>\n<ul>\n<li>输入的数据要和格式字符串匹配。</li>\n<li>输入多个数据时，一般用空格、制表符或者换行符分隔。</li>\n</ul>\n<h4><a id=\"__79\"></a>📌 适用类型</h4>\n<p>适用于各种基本数据类型。</p>\n<h4><a id=\"__83\"></a>💡 示例</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\">#include &lt;stdio.h&gt;\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">int</span> num;\n    <span class=\"hljs-type\">float</span> score;\n    <span class=\"hljs-type\">char</span> ch;\n\n    <span class=\"hljs-comment\">// 提示用户输入整数</span>\n    printf(<span class=\"hljs-string\">&quot;请输入一个整数：&quot;</span>); \n    scanf(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;num);\n\n    <span class=\"hljs-comment\">// 提示用户输入浮点数</span>\n    printf(<span class=\"hljs-string\">&quot;请输入一个浮点数：&quot;</span>); \n    scanf(<span class=\"hljs-string\">&quot;%f&quot;</span>, &amp;score);\n\n    <span class=\"hljs-comment\">// 提示用户输入字符</span>\n    printf(<span class=\"hljs-string\">&quot;请输入一个字符：&quot;</span>); \n    scanf(<span class=\"hljs-string\">&quot; %c&quot;</span>, &amp;ch); <span class=\"hljs-comment\">// 注意前面的空格，用于跳过之前输入的换行符</span>\n\n    <span class=\"hljs-comment\">// 输出用户输入的内容</span>\n    printf(<span class=\"hljs-string\">&quot;你输入的整数是 %d，浮点数是 %.2f，字符是 %c。\\n&quot;</span>, num, score, ch); \n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></div></pre>\n<h4><a id=\"__112\"></a>🌟 解释</h4>\n<p>这个例子中，<code>scanf</code> 函数按照格式说明符读取用户输入的数据，并把它们存储到对应的变量中。在读取字符前加空格是为了跳过之前输入的换行符。</p>\n<h3><a id=\"3_getchar___116\"></a>3. <code>getchar</code> 函数：读取单个字符 ⌨️</h3>\n<h4><a id=\"__118\"></a>🔧 使用格式</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getchar</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>)</span>;\n</code></div></pre>\n<h4><a id=\"__124\"></a>🎯 作用</h4>\n<p>从标准输入（通常是键盘）读取一个字符，并返回该字符的 ASCII 码值。</p>\n<h4><a id=\"__128\"></a>📖 用法</h4>\n<p>调用 <code>getchar</code> 函数时，程序会暂停，等待用户输入一个字符，按下回车键后，函数会返回该字符的 ASCII 码值。</p>\n<h4><a id=\"__132\"></a>⚠️ 注意事项</h4>\n<ul>\n<li><code>getchar</code> 会读取换行符，所以在连续使用时要注意处理换行符。</li>\n<li>函数返回值是 <code>int</code> 类型，不是 <code>char</code> 类型。</li>\n</ul>\n<h4><a id=\"__137\"></a>📌 适用类型</h4>\n<p>适用于字符类型。</p>\n<h4><a id=\"__141\"></a>💡 示例</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\">#include &lt;stdio.h&gt;\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">char</span> ch;\n    <span class=\"hljs-comment\">// 提示用户输入一个字符</span>\n    printf(<span class=\"hljs-string\">&quot;请输入一个字符：&quot;</span>); \n    ch = getchar();\n    <span class=\"hljs-comment\">// 输出用户输入的字符</span>\n    printf(<span class=\"hljs-string\">&quot;你输入的字符是 %c。\\n&quot;</span>, ch); \n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></div></pre>\n<h4><a id=\"__158\"></a>🌟 解释</h4>\n<p>此例中，<code>getchar</code> 函数读取用户输入的一个字符，并将其赋值给变量 <code>ch</code>，然后输出该字符。</p>\n<h3><a id=\"4_putchar___162\"></a>4. <code>putchar</code> 函数：输出单个字符 🖨️</h3>\n<h4><a id=\"__164\"></a>🔧 使用格式</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">putchar</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> c)</span>;\n</code></div></pre>\n<h4><a id=\"__170\"></a>🎯 作用</h4>\n<p>把一个字符输出到标准输出（通常是控制台）。</p>\n<h4><a id=\"__174\"></a>📖 用法</h4>\n<p>传入一个字符的 ASCII 码值或者字符常量，函数会将对应的字符输出到控制台。</p>\n<h4><a id=\"__178\"></a>⚠️ 注意事项</h4>\n<ul>\n<li>传入的参数可以是字符常量，也可以是字符变量的 ASCII 码值。</li>\n<li>函数返回值是输出的字符的 ASCII 码值。</li>\n</ul>\n<h4><a id=\"__183\"></a>📌 适用类型</h4>\n<p>适用于字符类型。</p>\n<h4><a id=\"__187\"></a>💡 示例</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\">#include &lt;stdio.h&gt;\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">ch</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;B&#x27;</span>;\n    <span class=\"hljs-comment\">// 输出字符</span>\n    putchar(ch); \n    putchar(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>); <span class=\"hljs-comment\">// 输出换行符</span>\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></div></pre>\n<h4><a id=\"__202\"></a>🌟 解释</h4>\n<p>在这个例子中，<code>putchar</code> 函数把字符 <code>B</code> 输出到控制台，然后输出一个换行符。</p>\n<h3><a id=\"5_fopen___206\"></a>5. <code>fopen</code> 函数：打开文件 📂</h3>\n<h4><a id=\"__208\"></a>🔧 使用格式</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\">FILE *fopen(const <span class=\"hljs-type\">char</span> *filename, const <span class=\"hljs-type\">char</span> *mode);\n</code></div></pre>\n<h4><a id=\"__214\"></a>🎯 作用</h4>\n<p>打开指定文件名的文件，并返回一个指向该文件的 <code>FILE</code> 指针。</p>\n<h4><a id=\"__218\"></a>📖 用法</h4>\n<p><code>filename</code> 是要打开的文件的名称，<code>mode</code> 是打开文件的模式，常见的模式有：</p>\n<br />\n<ul>\n<li><code>&quot;r&quot;</code>：以只读模式打开文件。</li>\n<li><code>&quot;w&quot;</code>：以写入模式打开文件，如果文件不存在则创建，如果存在则清空内容。</li>\n<li><code>&quot;a&quot;</code>：以追加模式打开文件，如果文件不存在则创建。</li>\n</ul>\n<h4><a id=\"__228\"></a>⚠️ 注意事项</h4>\n<ul>\n<li>打开文件后，要检查返回的指针是否为 <code>NULL</code>，若为 <code>NULL</code> 则表示打开文件失败。</li>\n<li>操作完文件后，要使用 <code>fclose</code> 函数关闭文件。</li>\n</ul>\n<h4><a id=\"__233\"></a>📌 适用类型</h4>\n<p>适用于文件操作。</p>\n<h4><a id=\"__237\"></a>💡 示例</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\">#include &lt;stdio.h&gt;\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {\n    FILE *file;\n    <span class=\"hljs-comment\">// 以只读模式打开文件</span>\n    file = fopen(<span class=\"hljs-string\">&quot;test.txt&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>); \n\n    <span class=\"hljs-keyword\">if</span> (file == NULL) {\n        <span class=\"hljs-comment\">// 输出错误信息</span>\n        printf(<span class=\"hljs-string\">&quot;无法打开文件！\\n&quot;</span>); \n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n    }\n\n    <span class=\"hljs-comment\">// 这里可以进行文件读取操作</span>\n\n    <span class=\"hljs-comment\">// 关闭文件</span>\n    fclose(file); \n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></div></pre>\n<h4><a id=\"__262\"></a>🌟 解释</h4>\n<p>此例中，<code>fopen</code> 函数尝试以只读模式打开 <code>test.txt</code> 文件，若打开失败则输出错误信息，打开成功后可以进行文件读取操作，最后使用 <code>fclose</code> 函数关闭文件。</p>\n<h3><a id=\"6_fclose___266\"></a>6. <code>fclose</code> 函数：关闭文件 ❌</h3>\n<h4><a id=\"__268\"></a>🔧 使用格式</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">fclose</span><span class=\"hljs-params\">(FILE *stream)</span>;\n</code></div></pre>\n<h4><a id=\"__274\"></a>🎯 作用</h4>\n<p>关闭指定的文件流，释放相关资源。</p>\n<h4><a id=\"__278\"></a>📖 用法</h4>\n<p>传入一个指向 <code>FILE</code> 类型的指针，该指针是通过 <code>fopen</code> 函数返回的。</p>\n<h4><a id=\"__282\"></a>⚠️ 注意事项</h4>\n<ul>\n<li>关闭文件后，就不能再对该文件进行读写操作了。</li>\n<li>函数返回值为 0 表示关闭成功，非 0 表示关闭失败。</li>\n</ul>\n<h4><a id=\"__287\"></a>📌 适用类型</h4>\n<p>适用于文件操作。</p>\n<h4><a id=\"__291\"></a>💡 示例</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\">#include &lt;stdio.h&gt;\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {\n    FILE *file;\n    <span class=\"hljs-comment\">// 以写入模式打开文件</span>\n    file = fopen(<span class=\"hljs-string\">&quot;test.txt&quot;</span>, <span class=\"hljs-string\">&quot;w&quot;</span>); \n\n    <span class=\"hljs-keyword\">if</span> (file == NULL) {\n        <span class=\"hljs-comment\">// 输出错误信息</span>\n        printf(<span class=\"hljs-string\">&quot;无法打开文件！\\n&quot;</span>); \n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n    }\n\n    <span class=\"hljs-comment\">// 这里可以进行文件写入操作</span>\n\n    <span class=\"hljs-comment\">// 关闭文件</span>\n    <span class=\"hljs-keyword\">if</span> (fclose(file) == <span class=\"hljs-number\">0</span>) {\n        printf(<span class=\"hljs-string\">&quot;文件关闭成功！\\n&quot;</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n        printf(<span class=\"hljs-string\">&quot;文件关闭失败！\\n&quot;</span>);\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></div></pre>\n<h4><a id=\"__320\"></a>🌟 解释</h4>\n<p>这个例子中，<code>fopen</code> 函数以写入模式打开 <code>test.txt</code> 文件，进行文件写入操作后，使用 <code>fclose</code> 函数关闭文件，并根据返回值判断关闭是否成功。</p>\n<h3><a id=\"7_fgets___324\"></a>7. <code>fgets</code> 函数：安全读取字符串 📃</h3>\n<h4><a id=\"__326\"></a>🔧 使用格式</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">char</span> *fgets(<span class=\"hljs-type\">char</span> *str, <span class=\"hljs-type\">int</span> n, FILE *stream);\n</code></div></pre>\n<h4><a id=\"__332\"></a>🎯 作用</h4>\n<p>从指定的文件流中读取一行字符串，并存储到 <code>str</code> 指向的字符数组中。</p>\n<h4><a id=\"__336\"></a>📖 用法</h4>\n<p><code>str</code> 是存储读取字符串的字符数组，<code>n</code> 是最多读取的字符数（包含换行符和字符串结束符 <code>\'\\0\'</code>），<code>stream</code> 是文件流指针，可以是 <code>stdin</code>（标准输入）或者通过 <code>fopen</code> 打开的文件指针。</p>\n<h4><a id=\"__340\"></a>⚠️ 注意事项</h4>\n<ul>\n<li>若读取的字符数达到 <code>n - 1</code> 或者遇到换行符，读取会停止，并且会在字符串末尾添加 <code>\'\\0\'</code>。</li>\n<li>若读取成功，返回 <code>str</code> 指针；若遇到文件结束符或者出错，返回 <code>NULL</code>。</li>\n</ul>\n<h4><a id=\"__345\"></a>📌 适用类型</h4>\n<p>适用于字符串类型。</p>\n<h4><a id=\"__349\"></a>💡 示例</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\">#include &lt;stdio.h&gt;\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">100</span>];\n    <span class=\"hljs-comment\">// 从标准输入读取一行字符串</span>\n    printf(<span class=\"hljs-string\">&quot;请输入一行字符串：&quot;</span>); \n    fgets(buffer, sizeof(buffer), stdin);\n\n    <span class=\"hljs-comment\">// 输出读取的字符串</span>\n    printf(<span class=\"hljs-string\">&quot;你输入的字符串是：%s&quot;</span>, buffer); \n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></div></pre>\n<h4><a id=\"__367\"></a>🌟 解释</h4>\n<p>在这个例子中，<code>fgets</code> 函数从标准输入读取一行字符串，最多读取 <code>sizeof(buffer) - 1</code> 个字符，然后将其存储到 <code>buffer</code> 数组中，并输出该字符串。</p>\n<h3><a id=\"8_fputs___371\"></a>8. <code>fputs</code> 函数：输出字符串到文件 📤</h3>\n<h4><a id=\"__373\"></a>🔧 使用格式</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">fputs</span><span class=\"hljs-params\">(const <span class=\"hljs-type\">char</span> *str, FILE *stream)</span>;\n</code></div></pre>\n<h4><a id=\"__379\"></a>🎯 作用</h4>\n<p>把字符串 <code>str</code> 输出到指定的文件流中。</p>\n<h4><a id=\"__383\"></a>📖 用法</h4>\n<p><code>str</code> 是要输出的字符串，<code>stream</code> 是文件流指针，可以是 <code>stdout</code>（标准输出）或者通过 <code>fopen</code> 打开的文件指针。</p>\n<h4><a id=\"__387\"></a>⚠️ 注意事项</h4>\n<ul>\n<li>函数不会自动添加换行符，若需要换行，要在字符串中手动添加 <code>\'\\n\'</code>。</li>\n<li>若输出成功，返回非负值；若出错，返回 <code>EOF</code>。</li>\n</ul>\n<h4><a id=\"__392\"></a>📌 适用类型</h4>\n<p>适用于字符串类型。</p>\n<h4><a id=\"__396\"></a>💡 示例</h4>\n<pre><div class=\"hljs\"><code class=\"lang-java\">#include &lt;stdio.h&gt;\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {\n    FILE *file;\n    <span class=\"hljs-comment\">// 以写入模式打开文件</span>\n    file = fopen(<span class=\"hljs-string\">&quot;test.txt&quot;</span>, <span class=\"hljs-string\">&quot;w&quot;</span>); \n\n    <span class=\"hljs-keyword\">if</span> (file == NULL) {\n        <span class=\"hljs-comment\">// 输出错误信息</span>\n        printf(<span class=\"hljs-string\">&quot;无法打开文件！\\n&quot;</span>); \n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n    }\n\n    <span class=\"hljs-comment\">// 向文件中写入字符串</span>\n    fputs(<span class=\"hljs-string\">&quot;Hello, World!\\n&quot;</span>, file); \n\n    <span class=\"hljs-comment\">// 关闭文件</span>\n    fclose(file); \n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></div></pre>\n<h4><a id=\"__422\"></a>🌟 解释</h4>\n<p>此例中，<code>fopen</code> 函数以写入模式打开 <code>test.txt</code> 文件，<code>fputs</code> 函数把字符串 <code>&quot;Hello, World!\\n&quot;</code> 写入文件，最后使用 <code>fclose</code> 函数关闭文件。</p>\n<br />\n<h4><a id=\"_428\"></a><strong>缓冲区管理技巧</strong></h4>\n<p><strong>通用清空方案</strong>：</p>\n<pre><code class=\"lang-\">void clear_buffer() {\n    int c;\n    while ((c = getchar()) != \'\\n\' &amp;&amp; c != EOF);\n}\n</code></pre>\n<p><strong>使用场景</strong>：</p>\n<ul>\n<li>\n<p>在<code>scanf()</code>后立即调用</p>\n</li>\n<li>\n<p>处理异常输入时</p>\n</li>\n</ul>\n<p><strong>💡 黄金法则</strong>：</p>\n<ol>\n<li>\n<p>所有输入函数都要考虑缓冲区溢出风险</p>\n</li>\n<li>\n<p>文件操作后必须检查返回值并关闭文件</p>\n</li>\n<li>\n<p>格式化IO要严格匹配类型</p>\n</li>\n</ol>\n<p>掌握这些核心函数，你的C语言IO操作将游刃有余！ 🎯</p>\n<br />\n', '输入输出函数：能够让程序和用户或者文件进行交互。 {#content_views}\n-----------------------------------------\n\n### 头文件：#include\\<stdio.h\\>\n\n### 1. `printf` 函数：输出格式化信息到控制台 💬\n\n#### 🔧 使用格式\n\n```java\nprintf(\"格式字符串\", 参数列表);\n```\n\n#### 🎯 作用\n\n把格式化后的字符串输出到控制台。格式字符串里可以包含普通字符和格式说明符，格式说明符会被后面参数列表里的值替换。\n\n#### 📖 用法\n\n格式说明符一般以 `%` 开头，常见的有 `%d`（用于输出整数）、`%f`（用于输出浮点数）、`%c`（用于输出字符）、`%s`（用于输出字符串）等。\n\n#### ⚠️ 注意事项\n\n* 格式说明符要和参数的类型相匹配。\n* 格式字符串中的普通字符会原样输出。\n\n#### 📌 适用类型\n\n适用于各种基本数据类型以及字符串。\n\n#### 💡 示例\n\n```java\n#include <stdio.h>\n\nint main() {\n    int age = 20;\n    float height = 1.75;\n    char grade = \'A\';\n    char name[] = \"Alice\";\n\n    // 输出整数\n    printf(\"年龄是 %d 岁。\\n\", age); \n    // 输出浮点数\n    printf(\"身高是 %.2f 米。\\n\", height); \n    // 输出字符\n    printf(\"成绩等级是 %c。\\n\", grade); \n    // 输出字符串\n    printf(\"姓名是 %s。\\n\", name); \n\n    return 0;\n}\n```\n\n#### 🌟 解释\n\n在这个例子中，`printf` 函数依据格式说明符把变量的值输出到控制台。`%.2f` 表示输出浮点数时保留两位小数。\n\n### 2. `scanf` 函数：从控制台读取格式化输入 📥\n\n#### 🔧 使用格式\n\n```java\nscanf(\"格式字符串\", &变量1, &变量2, ...);\n```\n\n#### 🎯 作用\n\n从控制台读取用户输入的数据，并且按照格式字符串的要求把数据存储到对应的变量中。\n\n#### 📖 用法\n\n格式说明符和 `printf` 函数里的类似，不过要在变量名前加上取地址符 `&`，以此表明是要把数据存储到该变量的地址处。\n\n#### ⚠️ 注意事项\n\n* 输入的数据要和格式字符串匹配。\n* 输入多个数据时，一般用空格、制表符或者换行符分隔。\n\n#### 📌 适用类型\n\n适用于各种基本数据类型。\n\n#### 💡 示例\n\n```java\n#include <stdio.h>\n\nint main() {\n    int num;\n    float score;\n    char ch;\n\n    // 提示用户输入整数\n    printf(\"请输入一个整数：\"); \n    scanf(\"%d\", &num);\n\n    // 提示用户输入浮点数\n    printf(\"请输入一个浮点数：\"); \n    scanf(\"%f\", &score);\n\n    // 提示用户输入字符\n    printf(\"请输入一个字符：\"); \n    scanf(\" %c\", &ch); // 注意前面的空格，用于跳过之前输入的换行符\n\n    // 输出用户输入的内容\n    printf(\"你输入的整数是 %d，浮点数是 %.2f，字符是 %c。\\n\", num, score, ch); \n\n    return 0;\n}\n```\n\n#### 🌟 解释\n\n这个例子中，`scanf` 函数按照格式说明符读取用户输入的数据，并把它们存储到对应的变量中。在读取字符前加空格是为了跳过之前输入的换行符。\n\n### 3. `getchar` 函数：读取单个字符 ⌨️\n\n#### 🔧 使用格式\n\n```java\nint getchar(void);\n```\n\n#### 🎯 作用\n\n从标准输入（通常是键盘）读取一个字符，并返回该字符的 ASCII 码值。\n\n#### 📖 用法\n\n调用 `getchar` 函数时，程序会暂停，等待用户输入一个字符，按下回车键后，函数会返回该字符的 ASCII 码值。\n\n#### ⚠️ 注意事项\n\n* `getchar` 会读取换行符，所以在连续使用时要注意处理换行符。\n* 函数返回值是 `int` 类型，不是 `char` 类型。\n\n#### 📌 适用类型\n\n适用于字符类型。\n\n#### 💡 示例\n\n```java\n#include <stdio.h>\n\nint main() {\n    char ch;\n    // 提示用户输入一个字符\n    printf(\"请输入一个字符：\"); \n    ch = getchar();\n    // 输出用户输入的字符\n    printf(\"你输入的字符是 %c。\\n\", ch); \n\n    return 0;\n}\n```\n\n#### 🌟 解释\n\n此例中，`getchar` 函数读取用户输入的一个字符，并将其赋值给变量 `ch`，然后输出该字符。\n\n### 4. `putchar` 函数：输出单个字符 🖨️\n\n#### 🔧 使用格式\n\n```java\nint putchar(int c);\n```\n\n#### 🎯 作用\n\n把一个字符输出到标准输出（通常是控制台）。\n\n#### 📖 用法\n\n传入一个字符的 ASCII 码值或者字符常量，函数会将对应的字符输出到控制台。\n\n#### ⚠️ 注意事项\n\n* 传入的参数可以是字符常量，也可以是字符变量的 ASCII 码值。\n* 函数返回值是输出的字符的 ASCII 码值。\n\n#### 📌 适用类型\n\n适用于字符类型。\n\n#### 💡 示例\n\n```java\n#include <stdio.h>\n\nint main() {\n    char ch = \'B\';\n    // 输出字符\n    putchar(ch); \n    putchar(\'\\n\'); // 输出换行符\n\n    return 0;\n}\n```\n\n#### 🌟 解释\n\n在这个例子中，`putchar` 函数把字符 `B` 输出到控制台，然后输出一个换行符。\n\n### 5. `fopen` 函数：打开文件 📂\n\n#### 🔧 使用格式\n\n```java\nFILE *fopen(const char *filename, const char *mode);\n```\n\n#### 🎯 作用\n\n打开指定文件名的文件，并返回一个指向该文件的 `FILE` 指针。\n\n#### 📖 用法\n\n`filename` 是要打开的文件的名称，`mode` 是打开文件的模式，常见的模式有：\n\n<br />\n\n* `\"r\"`：以只读模式打开文件。\n* `\"w\"`：以写入模式打开文件，如果文件不存在则创建，如果存在则清空内容。\n* `\"a\"`：以追加模式打开文件，如果文件不存在则创建。\n\n#### ⚠️ 注意事项\n\n* 打开文件后，要检查返回的指针是否为 `NULL`，若为 `NULL` 则表示打开文件失败。\n* 操作完文件后，要使用 `fclose` 函数关闭文件。\n\n#### 📌 适用类型\n\n适用于文件操作。\n\n#### 💡 示例\n\n```java\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    // 以只读模式打开文件\n    file = fopen(\"test.txt\", \"r\"); \n\n    if (file == NULL) {\n        // 输出错误信息\n        printf(\"无法打开文件！\\n\"); \n        return 1;\n    }\n\n    // 这里可以进行文件读取操作\n\n    // 关闭文件\n    fclose(file); \n\n    return 0;\n}\n```\n\n#### 🌟 解释\n\n此例中，`fopen` 函数尝试以只读模式打开 `test.txt` 文件，若打开失败则输出错误信息，打开成功后可以进行文件读取操作，最后使用 `fclose` 函数关闭文件。\n\n### 6. `fclose` 函数：关闭文件 ❌\n\n#### 🔧 使用格式\n\n```java\nint fclose(FILE *stream);\n```\n\n#### 🎯 作用\n\n关闭指定的文件流，释放相关资源。\n\n#### 📖 用法\n\n传入一个指向 `FILE` 类型的指针，该指针是通过 `fopen` 函数返回的。\n\n#### ⚠️ 注意事项\n\n* 关闭文件后，就不能再对该文件进行读写操作了。\n* 函数返回值为 0 表示关闭成功，非 0 表示关闭失败。\n\n#### 📌 适用类型\n\n适用于文件操作。\n\n#### 💡 示例\n\n```java\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    // 以写入模式打开文件\n    file = fopen(\"test.txt\", \"w\"); \n\n    if (file == NULL) {\n        // 输出错误信息\n        printf(\"无法打开文件！\\n\"); \n        return 1;\n    }\n\n    // 这里可以进行文件写入操作\n\n    // 关闭文件\n    if (fclose(file) == 0) {\n        printf(\"文件关闭成功！\\n\");\n    } else {\n        printf(\"文件关闭失败！\\n\");\n    }\n\n    return 0;\n}\n```\n\n#### 🌟 解释\n\n这个例子中，`fopen` 函数以写入模式打开 `test.txt` 文件，进行文件写入操作后，使用 `fclose` 函数关闭文件，并根据返回值判断关闭是否成功。\n\n### 7. `fgets` 函数：安全读取字符串 📃\n\n#### 🔧 使用格式\n\n```java\nchar *fgets(char *str, int n, FILE *stream);\n```\n\n#### 🎯 作用\n\n从指定的文件流中读取一行字符串，并存储到 `str` 指向的字符数组中。\n\n#### 📖 用法\n\n`str` 是存储读取字符串的字符数组，`n` 是最多读取的字符数（包含换行符和字符串结束符 `\'\\0\'`），`stream` 是文件流指针，可以是 `stdin`（标准输入）或者通过 `fopen` 打开的文件指针。\n\n#### ⚠️ 注意事项\n\n* 若读取的字符数达到 `n - 1` 或者遇到换行符，读取会停止，并且会在字符串末尾添加 `\'\\0\'`。\n* 若读取成功，返回 `str` 指针；若遇到文件结束符或者出错，返回 `NULL`。\n\n#### 📌 适用类型\n\n适用于字符串类型。\n\n#### 💡 示例\n\n```java\n#include <stdio.h>\n\nint main() {\n    char buffer[100];\n    // 从标准输入读取一行字符串\n    printf(\"请输入一行字符串：\"); \n    fgets(buffer, sizeof(buffer), stdin);\n\n    // 输出读取的字符串\n    printf(\"你输入的字符串是：%s\", buffer); \n\n    return 0;\n}\n```\n\n#### 🌟 解释\n\n在这个例子中，`fgets` 函数从标准输入读取一行字符串，最多读取 `sizeof(buffer) - 1` 个字符，然后将其存储到 `buffer` 数组中，并输出该字符串。\n\n### 8. `fputs` 函数：输出字符串到文件 📤\n\n#### 🔧 使用格式\n\n```java\nint fputs(const char *str, FILE *stream);\n```\n\n#### 🎯 作用\n\n把字符串 `str` 输出到指定的文件流中。\n\n#### 📖 用法\n\n`str` 是要输出的字符串，`stream` 是文件流指针，可以是 `stdout`（标准输出）或者通过 `fopen` 打开的文件指针。\n\n#### ⚠️ 注意事项\n\n* 函数不会自动添加换行符，若需要换行，要在字符串中手动添加 `\'\\n\'`。\n* 若输出成功，返回非负值；若出错，返回 `EOF`。\n\n#### 📌 适用类型\n\n适用于字符串类型。\n\n#### 💡 示例\n\n```java\n#include <stdio.h>\n\nint main() {\n    FILE *file;\n    // 以写入模式打开文件\n    file = fopen(\"test.txt\", \"w\"); \n\n    if (file == NULL) {\n        // 输出错误信息\n        printf(\"无法打开文件！\\n\"); \n        return 1;\n    }\n\n    // 向文件中写入字符串\n    fputs(\"Hello, World!\\n\", file); \n\n    // 关闭文件\n    fclose(file); \n\n    return 0;\n}\n```\n\n#### 🌟 解释\n\n此例中，`fopen` 函数以写入模式打开 `test.txt` 文件，`fputs` 函数把字符串 `\"Hello, World!\\n\"` 写入文件，最后使用 `fclose` 函数关闭文件。\n\n<br />\n\n#### **缓冲区管理技巧**\n\n**通用清空方案**：\n\n```\nvoid clear_buffer() {\n    int c;\n    while ((c = getchar()) != \'\\n\' && c != EOF);\n}\n```\n\n**使用场景**：\n\n* 在`scanf()`后立即调用\n\n* 处理异常输入时\n\n**💡 黄金法则**：\n\n1. 所有输入函数都要考虑缓冲区溢出风险\n\n2. 文件操作后必须检查返回值并关闭文件\n\n3. 格式化IO要严格匹配类型\n\n掌握这些核心函数，你的C语言IO操作将游刃有余！ 🎯\n\n<br />\n\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/2301_77025086/article/details/146886620?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-04-28 17:19:56', '2025-04-28 17:41:21');
INSERT INTO `sys_article` VALUES (324, 1, 41, 'Java详细安装配置教程(Windows)，从下载到配置——Java-1.8(jdk)安装', 'img/Java详细安装配置教程(Windows)，从下载到配置——Java-1.8(jdk)安装.png', 'Java-1.8(jdk)安装', '<h2><a id=\"1Java_01Java_content_views_0\"></a>{#1Java_0}1、Java简介 {#content_views}</h2>\n<p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。</p>\n<p>后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。</p>\n<p>Java分为三个体系：</p>\n<ul>\n<li>JavaSE(J2SE)(Java2 Platform Standard Edition，java平台标准版)</li>\n<li>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</li>\n<li>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</li>\n</ul>\n<p>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 “2”：J2EE 更名为 Java EE，J2SE 更名为Java SE，J2ME 更名为 Java ME。</p>\n<h2><a id=\"2Java_142Java_15\"></a>{#2Java_14}2、Java安装</h2>\n<p>Java安装分为以下几步：</p>\n<ul>\n<li>下载JDK源文件</li>\n<li>安装exe软件</li>\n<li>配置环境变量</li>\n<li>验证安装结果</li>\n</ul>\n<h3><a id=\"1JDK_211JDK_25\"></a>{#1JDK_21}1、下载JDK源文件</h3>\n<p>下载链接：<a href=\"https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html\" target=\"_blank\">https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html</a><br />\n选择自己系统对应的版本下载，如：当前系统是windows 64位版本，则选择框选的版本，点击后面的蓝色字即可下载。<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/82eb2e0f57e3cfde2dbaf81c35cf1e05.png\" alt=\"1\" /></p>\n<h3><a id=\"2exe_252exe_31\"></a>{#2exe_25}2、安装exe文件</h3>\n<p>开发环境能放到自定义目录就放到自定义目录，这样才能更好的管理，所以在开始之前，在C盘目录下新建一个<code>web</code>目录，用于存放Java环境。</p>\n<p>新建的web目录（maven请自动忽略）</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/19eadbf0a2315c7d48508ef74cda388a.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bbaPoUTZ-1646565105528)(img/image-20220101164050399.png)]\" /></p>\n<p>双击打开文件<code>jdk-8u301-windows-x64.exe</code>，点击下一步：<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/92812e158b787c1a94ad13f58e6dd165.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sPewdwGz-1646565105531)(img/image-20220101163817442.png)]\" /><br />\n点击更改：<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/0e441be4b30606a8b7e8e8b07e8c03c6.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-98iatvDR-1646565105534)(img/image-20220101163849687.png)]\" /><br />\n将文件目录修改成：<code>C:\\web\\Java\\jdk1.8.0_301\\</code><br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/f3fe89774818cf3b47e05506569bc790.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jfUXhSvz-1646565105535)(img/image-20220101164230177.png)]\" /><br />\n点击确定并下一步，等待安装，此时在<code>C:\\web\\Java\\</code>下面创建文件夹<code>jre1.8.0_301</code>，与<code>C:\\web\\Java\\jdk1.8.0_301\\</code>平级：<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/1b0597c3c2d2aaf4b827a9858087bf58.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7iOsLwr2-1646565105535)(img/image-20220101164608143.png)]\" /><br />\n将此目录更改成创建的目录，点击更改选择即可：<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/5eca77a40f9548a431e3ea8f1409a7ef.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AvwDdscb-1646565105536)(img/image-20220101164536790.png)]\" /><br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/e8f10ca19529c54eb66f3be68a37f823.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-olW7GF1s-1646565105537)(img/image-20220101164733318.png)]\" /><br />\n点击下一步，在最后弹出的窗口点击关闭即可。<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/65211a0d1eb51aaa9a87337f343184e1.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-slSq3uU7-1646565105538)(img/image-20220101164751772.png)]\" /></p>\n<h4><a id=\"psjdk__jre___49psjdk__jre___53\"></a>{#psjdk__jre___49}ps：jdk 和 jre 是什么？ 有什么区别？</h4>\n<ul>\n<li>jre</li>\n</ul>\n<p>Jre 是java runtime environment, 是java程序的运行环境。既然是运行，当然要包含jvm，也就是大家熟悉的虚拟机啦，还有所有java类库的class文件，都在lib目录下打包成了jar。大家可以自己验证。至于在windows上的虚拟机是哪个文件呢？学过MFC的都知道什么是dll文件吧，那么大家看看jre/bin/client里面是不是有一个jvm.dll呢？那就是虚拟机。</p>\n<ul>\n<li>jdk</li>\n</ul>\n<p>Jdk 是java development kit，是java的开发工具包， 主要是给ide 用的，里面包含了各种类库和工具。当然也包括了另外一个Jre.， 而且jdk/jre/bin 里面也有一个server文件夹， server文件夹下面也有一个jvm.dll 虚拟机。</p>\n<p>为什么要将jre和jdk分开？这个问题可以留到课程学习的时候进行解答。</p>\n<h3><a id=\"3_613_65\"></a>{#3_61}3、配置环境变量</h3>\n<p>配置原因：</p>\n<p>因为JDK装好后的两个重要执行文件<strong>javac.exe</strong> (代码编译文件)和<strong>java.exe</strong>(代码执行文件)存在于所装的JDK的bin目录下，而我们写的Java或者跑的别人的程序一般是放在一个新的目录，主要是方便管理，如果都放在这里，会很混乱，更何况编译还有class文件生成。但是，当我们要运行Java程序时，我们需要编译（需要使用javac.exe）和执行（需要使用java.exe）,而系统默认的是在当前程序所在的文件夹目录下去寻找这两个执行文件，而不会去其他地方找，此时我们就需要配置Path环境变量，使得每次程序运行就自动到安装JDK的bin目录下去搜索javac.exe和java.exe文件。</p>\n<p>打开此电脑，空白处右键属性：<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/9e7d5223016636c0b2d8ad3969682f01.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fhIDxnQ0-1646565105539)(img/image-20220101171438577.png)]\" /><br />\n依次点击高级系统设置-&gt;环境变量-&gt;新建 ，一共需要添加三个变量，依次为<code>JAVA_HOME</code>, <code>JRE_HOME</code>,<code>CLASSPATH</code><img src=\"https://i-blog.csdnimg.cn/blog_migrate/180a4fdd02c3ec1768c7ab48eaed678d.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kcB1FxQ6-1646565105540)(img/image-20220101171531918.png)]\" /></p>\n<p>变量名：<code>JAVA_HOME</code>，变量值：<code>C:\\web\\Java\\jdk1.8.0_301</code>，点击确定；<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/491c11199eb6d56cf954a4f3c99c8203.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7kq5gWRV-1646565105540)(img/image-20220101171708895.png)]\" /></p>\n<p>变量名：<code>JRE_HOME</code>，变量值：<code>C:\\web\\Java\\jre1.8.0_301</code>，点击确定；<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/de2f8bb98cf1fa1c6e2740764b424135.png\" alt=\"在这里插入图片描述\" /><br />\n变量名：<code>CLASSPATH</code>，变量值：<code>.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; </code>，注意变量值的前面有一个<code>.</code>，点击确定；<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/a163a84fb2cc15f65630961291938a7b.png\" alt=\"在这里插入图片描述\" /><br />\n可以看到，变量值是Java环境的<code>JDK</code>和<code>JRE</code>的安装目录。</p>\n<p>点开双击点开path<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/cde8451913b240b4db9eae4e87f30255.png\" alt=\"在这里插入图片描述\" /><br />\n点击新建添加两个变量值：<code>%JAVA_HOME%\\bin</code>，<code>%JRE_HOME%\\bin</code><br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/785e88d11787700c16f345d456febef9.png\" alt=\"在这里插入图片描述\" /><br />\n点击所有的确定将开启的几个窗口关闭，这样Java环境变量即为配置完毕。</p>\n<h3><a id=\"4_874_90\"></a>{#4_87}4、验证安装结果</h3>\n<p>使用组合键<code>win+r</code>，即为同时按下键盘的田字格键和字母R，打开运行窗口：<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/cba59633b9c1c2b6ccd3d794f5fac8d9.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HXKoF5iu-1646565105544)(img/image-20220101172915630.png)]\" /><br />\n输入cmd，点击确定打开命令行窗口：<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/9744a947da4207ba49dee9657e7f6144.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gHAwojHv-1646565105545)(img/image-20220101172945582.png)]\" /><br />\n输入<code>java</code>，回车，查看结果：<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/93f86ac0407f5a441fd2086f0f648872.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-psbSYlbH-1646565105546)(img/image-20220101173020998.png)]\" /><br />\n输入<code>javac</code>，回车，查看结果：<br />\n<img src=\"https://i-blog.csdnimg.cn/blog_migrate/54e3ed9b11ad9da949c814b2b913af1d.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-A76KcEWc-1646565105546)(img/image-20220101173059227.png)]\" /><br />\n如果你的结果和我的一样，那么恭喜你，Java环境配置成功，可以开始Java的学习和代码编写。<br />\n如果没有成功，报错类似于<code>\'java\'不是内部或外部命令，也不是可运行的程序或批处理文件</code>，那么你需要重新看看Java是否安装成功，环境变量是否配置成功。</p>\n', '{#1Java_0}1、Java简介 {#content_views}\n-----------------------------------\n\nJava 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\n\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。\n\nJava分为三个体系：\n\n* JavaSE(J2SE)(Java2 Platform Standard Edition，java平台标准版)\n* JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)\n* JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。\n\n2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 \"2\"：J2EE 更名为 Java EE，J2SE 更名为Java SE，J2ME 更名为 Java ME。\n\n{#2Java_14}2、Java安装\n-------------------\n\nJava安装分为以下几步：\n\n* 下载JDK源文件\n* 安装exe软件\n* 配置环境变量\n* 验证安装结果\n\n### {#1JDK_21}1、下载JDK源文件\n\n下载链接：<https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html>  \n选择自己系统对应的版本下载，如：当前系统是windows 64位版本，则选择框选的版本，点击后面的蓝色字即可下载。  \n![1](https://i-blog.csdnimg.cn/blog_migrate/82eb2e0f57e3cfde2dbaf81c35cf1e05.png)\n\n### {#2exe_25}2、安装exe文件\n\n开发环境能放到自定义目录就放到自定义目录，这样才能更好的管理，所以在开始之前，在C盘目录下新建一个`web`目录，用于存放Java环境。\n\n新建的web目录（maven请自动忽略）\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bbaPoUTZ-1646565105528)(img/image-20220101164050399.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/19eadbf0a2315c7d48508ef74cda388a.png)\n\n双击打开文件`jdk-8u301-windows-x64.exe`，点击下一步：  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sPewdwGz-1646565105531)(img/image-20220101163817442.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/92812e158b787c1a94ad13f58e6dd165.png)  \n点击更改：  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-98iatvDR-1646565105534)(img/image-20220101163849687.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/0e441be4b30606a8b7e8e8b07e8c03c6.png)  \n将文件目录修改成：`C:\\web\\Java\\jdk1.8.0_301\\`  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jfUXhSvz-1646565105535)(img/image-20220101164230177.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/f3fe89774818cf3b47e05506569bc790.png)  \n点击确定并下一步，等待安装，此时在`C:\\web\\Java\\`下面创建文件夹`jre1.8.0_301`，与`C:\\web\\Java\\jdk1.8.0_301\\`平级：  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7iOsLwr2-1646565105535)(img/image-20220101164608143.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/1b0597c3c2d2aaf4b827a9858087bf58.png)  \n将此目录更改成创建的目录，点击更改选择即可：  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AvwDdscb-1646565105536)(img/image-20220101164536790.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/5eca77a40f9548a431e3ea8f1409a7ef.png)  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-olW7GF1s-1646565105537)(img/image-20220101164733318.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/e8f10ca19529c54eb66f3be68a37f823.png)  \n点击下一步，在最后弹出的窗口点击关闭即可。  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-slSq3uU7-1646565105538)(img/image-20220101164751772.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/65211a0d1eb51aaa9a87337f343184e1.png)\n\n#### {#psjdk__jre___49}ps：jdk 和 jre 是什么？ 有什么区别？\n\n* jre\n\nJre 是java runtime environment, 是java程序的运行环境。既然是运行，当然要包含jvm，也就是大家熟悉的虚拟机啦，还有所有java类库的class文件，都在lib目录下打包成了jar。大家可以自己验证。至于在windows上的虚拟机是哪个文件呢？学过MFC的都知道什么是dll文件吧，那么大家看看jre/bin/client里面是不是有一个jvm.dll呢？那就是虚拟机。\n\n* jdk\n\nJdk 是java development kit，是java的开发工具包， 主要是给ide 用的，里面包含了各种类库和工具。当然也包括了另外一个Jre.， 而且jdk/jre/bin 里面也有一个server文件夹， server文件夹下面也有一个jvm.dll 虚拟机。\n\n为什么要将jre和jdk分开？这个问题可以留到课程学习的时候进行解答。\n\n### {#3_61}3、配置环境变量\n\n配置原因：\n\n因为JDK装好后的两个重要执行文件**javac.exe** (代码编译文件)和**java.exe**(代码执行文件)存在于所装的JDK的bin目录下，而我们写的Java或者跑的别人的程序一般是放在一个新的目录，主要是方便管理，如果都放在这里，会很混乱，更何况编译还有class文件生成。但是，当我们要运行Java程序时，我们需要编译（需要使用javac.exe）和执行（需要使用java.exe）,而系统默认的是在当前程序所在的文件夹目录下去寻找这两个执行文件，而不会去其他地方找，此时我们就需要配置Path环境变量，使得每次程序运行就自动到安装JDK的bin目录下去搜索javac.exe和java.exe文件。\n\n打开此电脑，空白处右键属性：  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fhIDxnQ0-1646565105539)(img/image-20220101171438577.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/9e7d5223016636c0b2d8ad3969682f01.png)  \n依次点击高级系统设置-\\>环境变量-\\>新建 ，一共需要添加三个变量，依次为`JAVA_HOME`, `JRE_HOME`,`CLASSPATH`![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kcB1FxQ6-1646565105540)(img/image-20220101171531918.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/180a4fdd02c3ec1768c7ab48eaed678d.png)\n\n变量名：`JAVA_HOME`，变量值：`C:\\web\\Java\\jdk1.8.0_301`，点击确定；  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7kq5gWRV-1646565105540)(img/image-20220101171708895.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/491c11199eb6d56cf954a4f3c99c8203.png)\n\n变量名：`JRE_HOME`，变量值：`C:\\web\\Java\\jre1.8.0_301`，点击确定；  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/de2f8bb98cf1fa1c6e2740764b424135.png)  \n变量名：`CLASSPATH`，变量值：`.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; `，注意变量值的前面有一个`.`，点击确定；  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a163a84fb2cc15f65630961291938a7b.png)  \n可以看到，变量值是Java环境的`JDK`和`JRE`的安装目录。\n\n点开双击点开path  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cde8451913b240b4db9eae4e87f30255.png)  \n点击新建添加两个变量值：`%JAVA_HOME%\\bin`，`%JRE_HOME%\\bin`  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/785e88d11787700c16f345d456febef9.png)  \n点击所有的确定将开启的几个窗口关闭，这样Java环境变量即为配置完毕。\n\n### {#4_87}4、验证安装结果\n\n使用组合键`win+r`，即为同时按下键盘的田字格键和字母R，打开运行窗口：  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HXKoF5iu-1646565105544)(img/image-20220101172915630.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/cba59633b9c1c2b6ccd3d794f5fac8d9.png)  \n输入cmd，点击确定打开命令行窗口：  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gHAwojHv-1646565105545)(img/image-20220101172945582.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/9744a947da4207ba49dee9657e7f6144.png)  \n输入`java`，回车，查看结果：  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-psbSYlbH-1646565105546)(img/image-20220101173020998.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/93f86ac0407f5a441fd2086f0f648872.png)  \n输入`javac`，回车，查看结果：  \n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-A76KcEWc-1646565105546)(img/image-20220101173059227.png)\\]](https://i-blog.csdnimg.cn/blog_migrate/54e3ed9b11ad9da949c814b2b913af1d.png)  \n如果你的结果和我的一样，那么恭喜你，Java环境配置成功，可以开始Java的学习和代码编写。  \n如果没有成功，报错类似于`\'java\'不是内部或外部命令，也不是可运行的程序或批处理文件`，那么你需要重新看看Java是否安装成功，环境变量是否配置成功。\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/weixin_45710060/article/details/123315280', 0, NULL, NULL, '2025-06-05 17:24:28', '2025-06-05 17:29:47');
INSERT INTO `sys_article` VALUES (325, 1, 42, 'AIGC带来数据革命：R语言如何成为数据科学家的秘密武器？', 'img/AIGC带来数据革命：R语言如何成为数据科学家的秘密武器？.png', 'AIGC', '<br />\n<h4><a id=\"_2\"></a>文章目录</h4>\n<ul>\n<li><a href=\"#R_5\">一、R语言的基础特性</a></li>\n<li>\n<ul>\n<li><a href=\"#11_R_7\">1.1 R语言的起源与发展</a></li>\n<li><a href=\"#12_R_11\">1.2 R语言的核心优势</a></li>\n</ul>\n</li>\n<li><a href=\"#RAIGC_18\">二、R语言在AIGC中的应用场景</a></li>\n<li>\n<ul>\n<li><a href=\"#21__20\">2.1 数据预处理与清洗</a></li>\n<li><a href=\"#22__43\">2.2 文本分析与生成</a></li>\n<li><a href=\"#23__67\">2.3 机器学习与模型构建</a></li>\n<li><a href=\"#24__94\">2.4 数据可视化与报告生成</a></li>\n</ul>\n</li>\n<li><a href=\"#RAIGC_115\">三、R语言在AIGC中的具体案例</a></li>\n<li>\n<ul>\n<li><a href=\"#31__117\">3.1 金融数据分析与预测</a></li>\n<li><a href=\"#32__132\">3.2 医疗数据分析与建模</a></li>\n<li><a href=\"#33__151\">3.3 社交媒体数据分析与情感分析</a></li>\n</ul>\n</li>\n<li><a href=\"#RAIGC_175\">四、R语言在AIGC中的未来展望</a></li>\n<li>\n<ul>\n<li><a href=\"#41__177\">4.1 与深度学习框架的集成</a></li>\n<li><a href=\"#42__211\">4.2 与云计算平台的集成</a></li>\n<li><a href=\"#43__233\">4.3 与自动化工具的集成</a></li>\n</ul>\n</li>\n<li><a href=\"#R_254\">《R语言统计分析与可视化从入门到精通宣传文案》</a></li>\n<li>\n<ul>\n<li><a href=\"#_260\">亮点</a></li>\n<li><a href=\"#_267\">内容简介</a></li>\n<li><a href=\"#_270\">作者简介</a></li>\n<li><a href=\"#_273\">目录</a></li>\n</ul>\n</li>\n<li><a href=\"#WordExcelPPTAI_937\">《Word/Excel/PPT/AI办公应用从入门到精通宣传文案》</a></li>\n<li>\n<ul>\n<li><a href=\"#_943\">亮点</a></li>\n<li><a href=\"#_949\">内容简介</a></li>\n</ul>\n</li>\n</ul>\n<br />\n<hr />\n<p>在这个数据驱动和人工智能生成内容（AIGC）快速发展的时代，R语言作为一款强大的统计分析和数据可视化工具，正在各个领域中发挥着越来越重要的作用。</p>\n<h2><a id=\"R_5R_content_views_41\"></a>{#R_5}一、R语言的基础特性 {#content_views}</h2>\n<h3><a id=\"11_R_711_R_44\"></a>{#11_R_7}1.1 R语言的起源与发展</h3>\n<p>R语言诞生于1993年，由Ross Ihaka和Robert Gentleman在新西兰奥克兰大学开发。它是一种专门用于统计计算和图形展示的编程语言，广泛应用于数据分析、机器学习、数据挖掘等领域。R语言的开源特性使其在全球范围内得到了广泛的应用和发展。</p>\n<h3><a id=\"12_R_1112_R_48\"></a>{#12_R_11}1.2 R语言的核心优势</h3>\n<ul>\n<li>强大的统计分析能力：R语言内置了大量的统计函数和包，能够处理各种复杂的统计分析任务。</li>\n<li>丰富的数据可视化功能：R语言提供了多种数据可视化工具，如ggplot2、lattice等，能够生成高质量的图形。</li>\n<li>灵活的数据处理能力：R语言支持多种数据格式的导入和导出，能够方便地进行数据清洗和预处理。</li>\n<li>活跃的社区支持：R语言拥有庞大的用户社区，用户可以方便地获取各种资源和支持。</li>\n</ul>\n<h2><a id=\"RAIGC_18RAIGC_55\"></a>{#RAIGC_18}二、R语言在AIGC中的应用场景</h2>\n<h3><a id=\"21__2021__58\"></a>{#21__20}2.1 数据预处理与清洗</h3>\n<p>在AIGC中，数据预处理和清洗是至关重要的一步。R语言提供了多种工具和包，如dplyr、tidyr等，能够高效地进行数据清洗和预处理。</p>\n<pre><code class=\"lang-prism\">示例代码：使用dplyr进行数据清洗 \nlibrary(dplyr)\n \n创建一个示例数据框 \ndata &lt;- data.frame(\n  id = 1:5,\n  name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;, &quot;Eve&quot;),\n  age = c(25, 30, 35, 40, 45),\n  salary = c(50000, 60000, 70000, 80000, 90000)\n)\n \n过滤年龄大于30的记录 \nfiltered_data &lt;- data %&gt;% filter(age &gt; 30)\n \n打印过滤后的数据 \nprint(filtered_data)\n</code></pre>\n<h3><a id=\"22__4322__81\"></a>{#22__43}2.2 文本分析与生成</h3>\n<p>R语言在文本分析和生成方面也有广泛的应用。通过使用tm、text2vec等包，可以进行文本挖掘、情感分析、主题建模等任务。</p>\n<pre><code class=\"lang-prism\">示例代码：使用tm包进行文本分析 \nlibrary(tm)\n \n创建一个示例文本语料库 \ncorpus &lt;- Corpus(VectorSource(c(&quot;R语言在AIGC中的应用&quot;, &quot;文本分析是AIGC的重要组成部分&quot;)))\n \n进行文本预处理 \ncorpus &lt;- tm_map(corpus, content_transformer(tolower))\ncorpus &lt;- tm_map(corpus, removePunctuation)\ncorpus &lt;- tm_map(corpus, removeNumbers)\ncorpus &lt;- tm_map(corpus, removeWords, stopwords(&quot;english&quot;))\n \n创建文档-词项矩阵 \ndtm &lt;- DocumentTermMatrix(corpus)\n \n打印文档-词项矩阵 \nprint(dtm)\n</code></pre>\n<h3><a id=\"23__6723__105\"></a>{#23__67}2.3 机器学习与模型构建</h3>\n<p>R语言在机器学习和模型构建方面也有丰富的应用。通过使用caret、randomForest等包，可以进行分类、回归、聚类等机器学习任务。</p>\n<pre><code class=\"lang-prism\">示例代码：使用caret包进行机器学习 \nlibrary(caret)\n \n加载示例数据集 \ndata(iris)\n \n划分训练集和测试集 \nset.seed(123)\ntrainIndex &lt;- createDataPartition(iris$Species, p = 0.8, list = FALSE)\ntrainData &lt;- iris[trainIndex, ]\ntestData &lt;- iris[-trainIndex, ]\n \n训练随机森林模型 \nmodel &lt;- train(Species ~ ., data = trainData, method = &quot;rf&quot;)\n \n进行预测 \npredictions &lt;- predict(model, testData)\n \n打印预测结果 \nprint(predictions)\n</code></pre>\n<h3><a id=\"24__9424__132\"></a>{#24__94}2.4 数据可视化与报告生成</h3>\n<p>R语言在数据可视化和报告生成方面也有广泛的应用。通过使用ggplot2、shiny等包，可以生成高质量的数据可视化图形和交互式报告。</p>\n<pre><code class=\"lang-prism\">示例代码：使用ggplot2进行数据可视化 \nlibrary(ggplot2)\n \n创建一个示例数据框 \ndata &lt;- data.frame(\n  x = 1:10,\n  y = rnorm(10)\n)\n \n生成散点图 \nggplot(data, aes(x = x, y = y)) +\n  geom_point() +\n  ggtitle(&quot;示例散点图&quot;) +\n  theme_minimal()\n</code></pre>\n<h2><a id=\"RAIGC_115RAIGC_153\"></a>{#RAIGC_115}三、R语言在AIGC中的具体案例</h2>\n<h3><a id=\"31__11731__156\"></a>{#31__117}3.1 金融数据分析与预测</h3>\n<p>在金融领域，R语言被广泛用于数据分析和预测。通过使用quantmod、forecast等包，可以进行股票价格预测、风险评估等任务。</p>\n<pre><code class=\"lang-prism\">示例代码：使用quantmod进行股票价格预测 \nlibrary(quantmod)\n \n获取股票数据 \ngetSymbols(&quot;AAPL&quot;)\n \n绘制股票价格图 \nchartSeries(AAPL, type = &quot;candlesticks&quot;, theme = &quot;white&quot;)\n</code></pre>\n<h3><a id=\"32__13232__171\"></a>{#32__132}3.2 医疗数据分析与建模</h3>\n<p>在医疗领域，R语言被用于数据分析和建模。通过使用survival、glmnet等包，可以进行生存分析、疾病预测等任务。</p>\n<pre><code class=\"lang-prism\">示例代码：使用survival进行生存分析 \nlibrary(survival)\n \n加载示例数据集 \ndata(lung)\n \n进行生存分析 \nfit &lt;- survfit(Surv(time, status) ~ sex, data = lung)\n \n绘制生存曲线 \nplot(fit, col = c(&quot;red&quot;, &quot;blue&quot;), xlab = &quot;时间&quot;, ylab = &quot;生存概率&quot;)\nlegend(&quot;topright&quot;, legend = c(&quot;男性&quot;, &quot;女性&quot;), col = c(&quot;red&quot;, &quot;blue&quot;), lty = 1)\n</code></pre>\n<h3><a id=\"33__15133__190\"></a>{#33__151}3.3 社交媒体数据分析与情感分析</h3>\n<p>在社交媒体领域，R语言被用于数据分析和情感分析。通过使用twitteR、syuzhet等包，可以进行社交媒体数据挖掘、情感分析等任务。</p>\n<pre><code class=\"lang-prism\">示例代码：使用twitteR进行社交媒体数据分析 \nlibrary(twitteR)\n \n设置Twitter API密钥 \napi_key &lt;- &quot;your_api_key&quot;\napi_secret &lt;- &quot;your_api_secret&quot;\naccess_token &lt;- &quot;your_access_token&quot;\naccess_secret &lt;- &quot;your_access_secret&quot;\n \n进行身份验证 \nsetup_twitter_oauth(api_key, api_secret, access_token, access_secret)\n \n搜索推文 \ntweets &lt;- searchTwitter(&quot;#AIGC&quot;, n = 100, lang = &quot;en&quot;)\n \n打印推文内容 \nprint(tweets)\n</code></pre>\n<h2><a id=\"RAIGC_175RAIGC_214\"></a>{#RAIGC_175}四、R语言在AIGC中的未来展望</h2>\n<h3><a id=\"41__17741__217\"></a>{#41__177}4.1 与深度学习框架的集成</h3>\n<p>随着深度学习技术的快速发展，R语言与深度学习框架的集成将成为未来的一个重要方向。通过使用Keras、TensorFlow等包，R语言可以进行深度学习模型的构建和训练。</p>\n<pre><code class=\"lang-prism\">示例代码：使用Keras进行深度学习 \nlibrary(keras)\n \n加载示例数据集 \ndata &lt;- dataset_mnist()\n \n数据预处理 \nx_train &lt;- data$train$x \ny_train &lt;- data$train$y \nx_test &lt;- data$test$x \ny_test &lt;- data$test$y \n \n构建模型 \nmodel &lt;- keras_model_sequential() %&gt;%\n  layer_flatten(input_shape = c(28, 28)) %&gt;%\n  layer_dense(units = 128, activation = &quot;relu&quot;) %&gt;%\n  layer_dense(units = 10, activation = &quot;softmax&quot;)\n \n编译模型 \nmodel %&gt;% compile(\n  optimizer = &quot;adam&quot;,\n  loss = &quot;sparse_categorical_crossentropy&quot;,\n  metrics = c(&quot;accuracy&quot;)\n)\n \n训练模型 \nmodel %&gt;% fit(x_train, y_train, epochs = 5, validation_data = list(x_test, y_test))\n</code></pre>\n<h3><a id=\"42__21142__251\"></a>{#42__211}4.2 与云计算平台的集成</h3>\n<p>随着云计算技术的普及，R语言与云计算平台的集成将成为未来的一个重要趋势。通过使用googleCloudRunner、aws.s3等包，R语言可以在云端进行大规模数据分析和模型训练。</p>\n<pre><code class=\"lang-prism\">示例代码：使用googleCloudRunner进行云端分析 \nlibrary(googleCloudRunner)\n \n设置Google Cloud项目 \ncr_project_set(&quot;your_project_id&quot;)\n \n创建一个云端任务 \njob &lt;- cr_job_create(\n  name = &quot;my_job&quot;,\n  image = &quot;rocker/r-ver:4.0.3&quot;,\n  script = &quot;my_script.R&quot;\n)\n \n提交任务 \ncr_job_run(job)\n</code></pre>\n<h3><a id=\"43__23343__273\"></a>{#43__233}4.3 与自动化工具的集成</h3>\n<p>随着自动化技术的发展，R语言与自动化工具的集成将成为未来的一个重要方向。通过使用plumber、rvest等包，R语言可以进行自动化数据采集、处理和报告生成。</p>\n<pre><code class=\"lang-prism\">示例代码：使用plumber创建API \nlibrary(plumber)\n \n创建一个API \n#* @get /hello \nfunction() {\n  return(&quot;Hello, AIGC!&quot;)\n}\n \n运行API \npr() %&gt;% pr_run(port = 8000)\n</code></pre>\n<p>R语言在AIGC时代中展现出了强大的应用潜力。从数据预处理、文本分析、机器学习到数据可视化，R语言在各个领域都有广泛的应用。随着与深度学习框架、云计算平台和自动化工具的集成，R语言在未来的AIGC应用中将发挥更加重要的作用。通过不断学习和实践，我们可以更好地利用R语言，推动AIGC技术的发展和应用。</p>\n<hr />\n<h2><a id=\"R_254R_295\"></a>{#R_254}《R语言统计分析与可视化从入门到精通宣传文案》</h2>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/cbffc6cc58954a3385d970b74cae6848.png\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<ul>\n<li>当当：<a href=\"https://product.dangdang.com/29788167.html\" target=\"_blank\">https://product.dangdang.com/29788167.html</a></li>\n<li>京东：<a href=\"https://item.jd.com/14798900.html\" target=\"_blank\">https://item.jd.com/14798900.html</a></li>\n</ul>\n</blockquote>\n<p>学R语言、练语法、取数据、预处理、可视化、回归分析、方差分析、聚类分析、生存分析、因子分析、基于机器学习的预测分析系统…一书在手，精通R语言统计分析与可视化！</p>\n<h3><a id=\"_260_304\"></a>{#_260}亮点</h3>\n<ul>\n<li>全面系统学习路径：本书从R语言基础到高级统计分析技术全面覆盖，提供一站式学习体验，助力读者从入门到精通。</li>\n<li>实战案例丰富多样：通过金融、医疗、科技等领域的实战案例，将理论知识与实际应用紧密结合，提升读者实战能力。</li>\n<li>跨行业应用广泛：不仅适用于数据分析师，还适合金融从业者、教育工作者及企业数据团队等多行业读者，满足不同需求。</li>\n<li>深入浅出讲解方式：采用简洁清晰的语言，深入浅出介绍统计分析概念，同时提供高级技术细节，满足不同层次读者需求。</li>\n<li>实用工具技巧分享：除了R语言基础，还分享大量实用工具和技巧，如数据获取处理、可视化方法、模型评估等，提高读者工作效率。</li>\n</ul>\n<h3><a id=\"_267_312\"></a>{#_267}内容简介</h3>\n<p>本书循序渐进、深入讲解了R语言数据统计分析与应用的核心知识，并通过具体实例的实现过程演练了知识点的用法和流程。全书共16章，分别讲解了R语言基础、R语言数据统计语法基础、数据获取和处理、绘制可视化统计图、描述性统计分析、探索性数据分析、推论统计、回归分析、方差分析、非参数统计分析、主成分分析、聚类分析、生存分析、因子分析、基于机器学习的患者再入院预测分析系统和中概科技指数统计分析与投资系统。全书简洁而不失其技术深度，内容丰富全面，历史资料翔实齐全。同时，本书易于阅读，以极简的文字介绍了复杂的案例，同时涵盖了其他同类图书中很少涉及的历史参考资料，是学习R语言数据统计分析与应用的实用教程。</p>\n<h3><a id=\"_270_316\"></a>{#_270}作者简介</h3>\n<p><strong>张良康</strong>，浙江大学统计学博士，现就职于恒瑞医药，负责医药临床试验数据分析和统计工作，参与临床试验方案设计沟通和讨论，为临床试验方案中统计学相关内容提供技术支持，包括研究设计方法的选择、样本量计算、随机和盲法、统计方法的选择等。使用R语言、SAS、SPSS等统计分析技术高达8年以上，擅长数据挖掘、分析和统计工作。具有多年的数据统计分析经验，对商务数据、销售数据、科研数据、医学数据和金融数据的统计分析工作也颇有研究。</p>\n<h3><a id=\"_273_320\"></a>{#_273}目录</h3>\n<pre><code class=\"lang-prism\">目录\n\n第1章R语言基础\n\n1.1  R语言的发展历程2\n\n1.2  R  语言的特点2\n\n1.3  获取并安装R语言运行环境3\n\n1.3.1  在Windows操作安装R语言3\n\n1.3.2  在Linux操作和macOS操作安装R语言5\n\n1.4  R语言开发工具：R  GUI5\n\n1.4.1  命令行方式运行R语言程序6\n\n1.4.2  文件方式运行R语言程序6\n\n1.5  R语言开发工具：RStudio7\n\n1.5.1  安装RStudio7\n\n1.5.2  RStudio界面简介9\n\n1.5.3  使用RStudio开发R语言程序10\n\n1.6  认识个R语言程序：简易数据统计与格式化输出11\n\n1.6.1  新建R语言工程11\n\n1.6.2  编写程序文件12\n\n1.7  R语言和数据处理14\n\n1.7.1  R语言的优势14\n\n1.7.2  数据处理和数据分析的区别14\n\n第2章R语言数据统计语法基础\n\n2.1  基本的内置函数17\n\n2.1.1  数学和统计函数17\n\n2.1.2  字符和字符串处理函数19\n\n2.1.3  文件操作函数21\n\n2.1.4  概率分布函数25\n\n2.1.5  日期函数和时间函数27\n\n2.2  内置数据处理函数33\n\n2.2.1  查看、筛选和编辑数据33\n\n2.2.2  合并数据35\n\n2.2.3  分组和汇总38\n\n2.2.4  排序40\n\n2.2.5  转换42\n\n2.3  apply函数族43\n\n2.3.1  apply函数族中的函数43\n\n2.3.2  函数apply()44\n\n2.3.3  函数lapply()45\n\n2.3.4  函数sapply()46\n\n2.3.5  函数vapply()47\n\n2.3.6  函数mapply()49\n\n2.4  数据重塑与变形50\n\n2.5  数据查询与过滤51\n\n2.5.1  使用dplyr包进行数据查询和过滤52\n\n2.5.2  使用sqldf包进行SQL风格的查询53\n\n第3章数据获取和处理\n\n3.1  数据获取和处理简介56\n\n3.2  使用键盘输入数据57\n\n3.3  处理CSV数据58\n\n3.3.1  读取CSV文件59\n\n3.3.2  写入CSV文件60\n\n3.3.3  数据转换和处理61\n\n3.4  处理Excel数据64\n\n3.4.1  R语言和Excel文件64\n\n3.4.2  使用readxl包64\n\n3.4.3  使用openxlsx包66\n\n3.5  处理XML数据67\n\n3.5.1  使用XML包68\n\n3.5.2  使用xml2包  70\n\n3.6  处理JSON数据72\n\n3.6.1  JSON包72\n\n3.6.2  使用jsonlite包73\n\n3.6.3  使用RJSONIO包75\n\n3.6.4  使用tidyjson包76\n\n3.7  处理MySQL数据78\n\n3.7.1  和MySQL相关的包78\n\n3.7.2  使用RMySQL包78\n\n3.7.3  使用RMariaDB包80\n\n3.7.4  使用DBI包81\n\n3.7.5  dplyr包和dbplyr包82\n\n3.8  从网页抓取数据84\n\n3.8.1  使用rvest包抓取数据84\n\n3.8.2  使用httr包抓取数据85\n\n3.8.3  使用XML包抓取数据87\n\n3.8.4  使用jsonlite包抓取数据88\n\n3.9  数据准备与清洗88\n\n3.9.1  缺失数据处理89\n\n3.9.2  异常值检测和处理91\n\n3.9.3  异常值检测方法小结93\n\n第4章绘制可视化统计图\n\n4.1  R语言绘图简介97\n\n4.1.1  常用的绘图包97\n\n4.1.2  基本绘图函数plot()97\n\n4.2  单变量绘图99\n\n4.2.1  绘制直方图99\n\n4.2.2  绘制条形图102\n\n4.2.3  绘制饼形图106\n\n4.2.4  绘制箱线图107\n\n\n\n4.2.5  绘制密度图109\n\n4.3  双变量绘图112\n\n4.3.1  绘制双变量条形图112\n\n4.3.2  绘制散点图116\n\n4.3.3  绘制折线图118\n\n4.3.4  绘制箱线图（双变量）120\n\n4.4  绘制多变量图122\n\n4.4.1  绘制气泡图123\n\n4.4.2  绘制热力图125\n\n4.5  文件数据的可视化128\n\n4.5.1  CSV文件数据的可视化128\n\n4.5.2  Excel文件数据的可视化130\n\n4.5.3  XML文件数据的可视化131\n\n4.5.4  JSON文件数据的可视化132\n\n4.5.5  MySQL数据库数据的可视化134\n\n第5章描述性统计分析\n\n5.1  描述性统计分析简介137\n\n5.2  平均数、中位数和众数137\n\n5.2.1  计算平均数138\n\n5.2.2  计算中位数140\n\n5.2.3  计算众数142\n\n5.3  方差和标准差143\n\n5.3.1  计算方差144\n\n5.3.2  计算标准差145\n\n5.4  百分位数147\n\n5.4.1  常见的百分位数147\n\n5.4.2  计算百分位数148\n\n第6章探索性数据分析\n\n6.1  EDA简介151\n\n6.2  检测重复值151\n\n6.2.1  检测重复值简介151\n\n6.2.2  R语言检测重复值的方法152\n\n6.3  数据可视化方法155\n\n6.4  相关性分析162\n\n6.4.1  相关性分析的基本信息162\n\n6.4.2  皮尔逊相关系数163\n\n6.4.3  斯皮尔曼相关系数165\n\n6.4.4  肯德尔相关系数166\n\n第7章  推论统计\n\n7.1  抽样和抽样分布169\n\n7.2  置信区间169\n\n7.2.1  置信区间的概念169\n\n7.2.2  总体均值的置信区间170\n\n7.2.3  总体比例的置信区间173\n\n7.2.4  总体方差的置信区间176\n\n7.3  假设检验177\n\n7.3.1  假设检验的基本步骤178\n\n7.3.2  假设检验中的类型179\n\n7.4  抽样方法181\n\n7.4.1  随机抽样181\n\n7.4.2 抽样183\n\n7.4.3  分层抽样184\n\n7.4.4  多阶段抽样185\n\n7.5  推论统计的方向小结185\n\n7.5.1  参数推断185\n\n7.5.2  非参数推断186\n\n第8章    回归分析\n\n8.1  回归分析简介189\n\n8.2  线性回归和多元线性回归189\n\n8.2.1  线性回归189\n\n8.2.2  多元线性回归194\n\n8.3  逻辑回归197\n\n8.3.1  逻辑回归简介197\n\n8.3.2  逻辑回归的应用领域197\n\n8.3.3  使用逻辑回归模型198\n\n8.4  非线性回归201\n\n8.4.1  非线性回归简介201\n\n8.4.2  使用非线性回归模型202\n\n8.5  条件回归203\n\n8.5.1  条件回归简介203\n\n8.5.2  使用条件回归模型204\n\n第9章  方差分析\n\n9.1  方差分析简介207\n\n9.2  单因素方差分析208\n\n9.2.1  单因素方差分析的步骤208\n\n9.2.2  单因素方差分析的应用209\n\n9.3  多因素方差分析212\n\n9.3.1  多因素方差分析简介212\n\n9.3.2  两因素方差分析213\n\n9.3.3  多因素方差分析216\n\n9.4  协方差分析218\n\n9.4.1  协方差分析方法简介218\n\n9.4.2  协方差分析的应用218\n\n第10章    非参数统计分析\n\n10.1  非参数统计的方法233\n\n10.2  秩和检验233\n\n10.2.1  秩和检验简介233\n\n10.2.2  使用秩和检验234\n\n10.3  Wilcoxon符号秩检验236\n\n10.3.1  Wilcoxon符号秩检验简介236\n\n10.3.2  使用Wilcoxon符号秩检验236\n\n10.4  Kruskal-Wallis检验239\n\n10.4.1  Kruskal-Wallis检验简介240\n\n10.4.2  使用Kruskal-Wallis检验240\n\n10.5  Friedman检验247\n\n10.5.1  Friedman检验简介248\n\n10.5.2  使用Friedman检验248\n\n10.6  卡方检验250\n\n10.6.1  卡方检验简介250\n\n10.6.2  卡方拟合度检验251\n\n10.6.3  卡方独立性检验252\n\n10.7  符号检验254\n\n10.7.1  符号检验简介254\n\n10.7.2  使用符号检验254\n\n第11章    主成分分析\n\n11.1  PCA简介257\n\n11.1.1  PCA的概念257\n\n11.1.2  PCA的应用领域257\n\n11.2  PCA的数学原理258\n\n11.2.1  主成分的提取258\n\n11.2.2  PCA的可解释性259\n\n11.3  PCA的应用：信用卡欺诈检测260\n\n11.3.1  准备R语言包260\n\n11.3.2  导入数据集261\n\n11.3.3  计算ROC和AUC262\n\n11.3.4  可视化处理263\n\n11.3.5  显示混淆矩阵265\n\n11.3.6  探索数据265\n\n11.3.7  相关性分析267\n\n11.3.8  使用随机森林模型268\n\n11.3.9  欺诈预测270\n\n11.3.10  结论272\n\n第12章    聚类分析\n\n12.1  聚类分析简介274\n\n12.1.1  聚类分析的基本概念274\n\n12.1.2  聚类分析的方法274\n\n12.1.3  聚类分析的应用领域275\n\n12.2  K均值聚类276\n\n12.2.1  K均值聚类简介276\n\n12.2.2  K均值聚类的应用277\n\n12.3  层次聚类280\n\n\n\n12.3.1  层次聚类简介280\n\n12.3.2  层次聚类的应用281\n\n12.4  DBSCAN聚类285\n\n12.4.1  DBSCAN简介285\n\n12.4.2  DBSCAN的应用领域286\n\n12.4.3  使用DBSCAN聚类算法286\n\n12.5  高斯混合模型聚类289\n\n12.5.1  高斯混合模型聚类简介289\n\n12.5.2  高斯混合模型聚类的应用289\n\n12.6  谱聚类295\n\n12.6.1  谱聚类简介295\n\n12.6.2  谱聚类的应用295\n\n第13章    生存分析\n\n13.1  生存分析简介299\n\n13.1.1  生存分析的基本概念299\n\n13.1.2  生存分析的应用领域300\n\n13.1.3  用R语言实现生存分析300\n\n13.2  Kaplan-Meier生存曲线302\n\n13.2.1  Kaplan-Meier生存曲线的解释303\n\n13.2.2  Kaplan-Meier生存曲线的构建303\n\n13.3  Cox比例模型307\n\n13.3.1  Cox比例模型简介307\n\n13.3.2  Cox比例模型的应用307\n\n13.4  心血管疾病的生存分析实战309\n\n13.4.1  数据集简介309\n\n13.4.2  数据预处理310\n\n13.4.3  二元变量分布315\n\n13.4.4  连续变量分布317\n\n13.4.5  死亡事件计数与生存时间324\n\n13.4.6  相关性分析328\n\n13.4.7  变量选择的机器学习模型331\n\n13.4.8  生存分析337\n\n13.4.9  总结343\n\n第14章    因子分析\n\n14.1  因子分析简介345\n\n14.1.1  因子分析的基本概念345\n\n14.1.2  因子分析的应用领域346\n\n14.2  因子分析方法346\n\n14.2.1  常用的因子分析方法346\n\n14.2.2 大似然估计法347\n\n14.2.3 小二乘法349\n\n14.2.4  广义小二乘法351\n\n14.2.5  主轴因子分析353\n\n14.2.6  因子旋转355\n\n14.2.7  因子得分估计357\n\n14.3  因子分析的应用：心血管疾病因素分析358\n\n14.3.1  设置环境358\n\n14.3.2  数据准备和探索359\n\n14.3.3  相关性分析362\n\n14.3.4  总结371\n\n第15章    基于机器学习的患者再入院预测分析\n\n15.1  背景简介373\n\n15.2  需求分析373\n\n15.3 分析374\n\n15.4 简介375\n\n15.4.1 功能简介375\n\n15.4.2 模块结构375\n\n15.5  技术分析376\n\n15.5.1  dplyr：数据预处理376\n\n15.5.2  psych：心理学和社会科学研究376\n\n15.5.3  ROSE：不平衡处理377\n\n15.5.4  caret模型训练和评估377\n\n15.6  数据处理378\n\n15.6.1  导入数据集378\n\n15.6.2  数据预处理380\n\n15.7 方案389\n\n15.7.1  划分训练集和集390\n\n15.7.2  数据集平衡390\n\n15.7.3  交叉验证391\n\n15.7.4  模型比较394\n\n15.8  第二方案396\n\n15.8.1  数据集拆分和数据平衡396\n\n15.8.2  逻辑回归模型拟合和预测397\n\n15.8.3  计算处理397\n\n15.8.4  逻辑回归模型的拟合、预测和评估398\n\n15.8.5  使用交叉验证方法训练决策树模型399\n\n15.8.6  使用交叉验证方法训练随机森林模型400\n\n15.8.7  实现朴素贝叶斯模型401\n\n15.9  模型训练和评估402\n\n15.9.1  数据预处理402\n\n15.9.2  逻辑回归模型的训练和评估403\n\n15.9.3  决策树模型的训练和评估404\n\n15.9.4  随机森林模型的训练和评估404\n\n15.9.5  朴素贝叶斯模型的训练和评估405\n\n15.10  结论406\n\n第16章    中概科技指数统计分析与投资\n\n16.1  背景简介409\n\n16.2  需求分析409\n\n16.3 分析410\n\n16.3.1 目标410\n\n16.3.2 模块410\n\n16.3.3  数据处理流程411\n\n16.4  技术栈411\n\n16.4.1  Tidyquant：财务数据分析411\n\n16.4.2  Tidyverse：数据处理工具412\n\n16.4.3  Loess平滑算法：非参数统计方法412\n\n16.5  数据处理412\n\n16.6  中概股技术分析413\n\n16.6.1  股票价格和收益分析413\n\n16.6.2  配对分析统计图420\n\n16.6.3  MACD技术分析统计图422\n\n16.6.4  OBV技术分析统计图424\n\n16.6.5  CCI技术分析统计图430\n\n16.6.6  Chaikin  AD  Line技术分析统计图436\n\n16.6.7  相对表现比率统计图437\n\n16.6.8  RSI技术分析统计图439\n\n16.6.9  交易差价技术分析统计图444\n\n16.6.10  CCI密度图446\n\n16.6.11  自定义指数技术分析统计图448\n</code></pre>\n<h2><a id=\"WordExcelPPTAI_937WordExcelPPTAI_982\"></a>{#WordExcelPPTAI_937}《Word/Excel/PPT/AI办公应用从入门到精通宣传文案》</h2>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/e3c0b44eb7864ad2b74a108804ba2aeb.png\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<ul>\n<li>当当：<a href=\"https://product.dangdang.com/29801293.html\" target=\"_blank\">https://product.dangdang.com/29801293.html</a></li>\n<li>京东：<a href=\"https://item.jd.com/14833140.html\" target=\"_blank\">https://item.jd.com/14833140.html</a></li>\n</ul>\n</blockquote>\n<p>全面讲解Word/Excel/PPT/AI办公所有知识点和操作技能，10小时全程同步视频+Windows 11操作教学视频+1000个办公常用模板+新功能+重点知识+海量学习资源，指引Office办公从入门到精通全过程，大幅提升Office操作技能！</p>\n<h3><a id=\"_943_991\"></a>{#_943}亮点</h3>\n<ul>\n<li>原创：以原创实战技巧和AI高效秘技为核心+全方位同步指导，全面呈现Word、Excel、PPT及AI办公应用的精髓！</li>\n<li>智能：涵盖AI在Word中的文档生成、Excel中的数据分析建议、PPT中的设计优化及AI检查语法、模拟面试等多元化AI功能，帮你显著提升办公效率与专业性！</li>\n<li>高效：集基础操作、高级技巧、举一反三案例、海量实用模板及辅助资料于一体，助力你快速掌握并应用所学！</li>\n<li>全能：与时俱进地将Microsoft 365中的Word、Excel、PowerPoint及AI助手Copilot全面融合，从文字处理、数据分析到演示文稿制作，再到AI智能辅助，一本书满足你所有办公需求！</li>\n</ul>\n<h3><a id=\"_949_998\"></a>{#_949}内容简介</h3>\n<p>本书通过精选案例引导读者深入学习，系统地介绍使用Word/Excel/PPT办公应用的相关知识以及AI的辅助与应用。<br />\n本书分为4篇，第1篇&quot;Word办公应用篇&quot;主要介绍Word的基本操作，使用图和表格美化Word文档，以及长文档的排版等；第2篇&quot;Excel办公应用篇&quot;主要介绍Excel的基本操作，初级数据处理与分析，图表、数据透视表和数据透视图，以及公式和函数的应用等；第3篇&quot;PPT办公应用篇&quot;主要介绍PowerPoint的基本操作，动画和多媒体的应用，以及放映幻灯片等；第4篇&quot;Office AI助手------Copilot篇&quot;主要介绍Copilot助力文本处理与改写、数据处理与分析、演示文稿的制作与美化等。<br />\n本书不仅适合计算机初级、中级用户学习，也可以作为各类院校相关专业学生和计算机培训班学员的教材或辅导用书。</p>\n', '<br />\n\n#### 文章目录\n\n* [一、R语言的基础特性](#R_5)\n*\n  * [1.1 R语言的起源与发展](#11_R_7)\n  * [1.2 R语言的核心优势](#12_R_11)\n* [二、R语言在AIGC中的应用场景](#RAIGC_18)\n*\n  * [2.1 数据预处理与清洗](#21__20)\n  * [2.2 文本分析与生成](#22__43)\n  * [2.3 机器学习与模型构建](#23__67)\n  * [2.4 数据可视化与报告生成](#24__94)\n* [三、R语言在AIGC中的具体案例](#RAIGC_115)\n*\n  * [3.1 金融数据分析与预测](#31__117)\n  * [3.2 医疗数据分析与建模](#32__132)\n  * [3.3 社交媒体数据分析与情感分析](#33__151)\n* [四、R语言在AIGC中的未来展望](#RAIGC_175)\n*\n  * [4.1 与深度学习框架的集成](#41__177)\n  * [4.2 与云计算平台的集成](#42__211)\n  * [4.3 与自动化工具的集成](#43__233)\n* [《R语言统计分析与可视化从入门到精通宣传文案》](#R_254)\n*\n  * [亮点](#_260)\n  * [内容简介](#_267)\n  * [作者简介](#_270)\n  * [目录](#_273)\n* [《Word/Excel/PPT/AI办公应用从入门到精通宣传文案》](#WordExcelPPTAI_937)\n*\n  * [亮点](#_943)\n  * [内容简介](#_949)\n\n<br />\n\n*** ** * ** ***\n\n在这个数据驱动和人工智能生成内容（AIGC）快速发展的时代，R语言作为一款强大的统计分析和数据可视化工具，正在各个领域中发挥着越来越重要的作用。\n\n{#R_5}一、R语言的基础特性 {#content_views}\n---------------------------------\n\n### {#11_R_7}1.1 R语言的起源与发展\n\nR语言诞生于1993年，由Ross Ihaka和Robert Gentleman在新西兰奥克兰大学开发。它是一种专门用于统计计算和图形展示的编程语言，广泛应用于数据分析、机器学习、数据挖掘等领域。R语言的开源特性使其在全球范围内得到了广泛的应用和发展。\n\n### {#12_R_11}1.2 R语言的核心优势\n\n* 强大的统计分析能力：R语言内置了大量的统计函数和包，能够处理各种复杂的统计分析任务。\n* 丰富的数据可视化功能：R语言提供了多种数据可视化工具，如ggplot2、lattice等，能够生成高质量的图形。\n* 灵活的数据处理能力：R语言支持多种数据格式的导入和导出，能够方便地进行数据清洗和预处理。\n* 活跃的社区支持：R语言拥有庞大的用户社区，用户可以方便地获取各种资源和支持。\n\n{#RAIGC_18}二、R语言在AIGC中的应用场景\n---------------------------\n\n### {#21__20}2.1 数据预处理与清洗\n\n在AIGC中，数据预处理和清洗是至关重要的一步。R语言提供了多种工具和包，如dplyr、tidyr等，能够高效地进行数据清洗和预处理。\n\n```prism language-r\n示例代码：使用dplyr进行数据清洗 \nlibrary(dplyr)\n \n创建一个示例数据框 \ndata <- data.frame(\n  id = 1:5,\n  name = c(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"),\n  age = c(25, 30, 35, 40, 45),\n  salary = c(50000, 60000, 70000, 80000, 90000)\n)\n \n过滤年龄大于30的记录 \nfiltered_data <- data %>% filter(age > 30)\n \n打印过滤后的数据 \nprint(filtered_data)\n```\n\n### {#22__43}2.2 文本分析与生成\n\nR语言在文本分析和生成方面也有广泛的应用。通过使用tm、text2vec等包，可以进行文本挖掘、情感分析、主题建模等任务。\n\n```prism language-r\n示例代码：使用tm包进行文本分析 \nlibrary(tm)\n \n创建一个示例文本语料库 \ncorpus <- Corpus(VectorSource(c(\"R语言在AIGC中的应用\", \"文本分析是AIGC的重要组成部分\")))\n \n进行文本预处理 \ncorpus <- tm_map(corpus, content_transformer(tolower))\ncorpus <- tm_map(corpus, removePunctuation)\ncorpus <- tm_map(corpus, removeNumbers)\ncorpus <- tm_map(corpus, removeWords, stopwords(\"english\"))\n \n创建文档-词项矩阵 \ndtm <- DocumentTermMatrix(corpus)\n \n打印文档-词项矩阵 \nprint(dtm)\n```\n\n### {#23__67}2.3 机器学习与模型构建\n\nR语言在机器学习和模型构建方面也有丰富的应用。通过使用caret、randomForest等包，可以进行分类、回归、聚类等机器学习任务。\n\n```prism language-r\n示例代码：使用caret包进行机器学习 \nlibrary(caret)\n \n加载示例数据集 \ndata(iris)\n \n划分训练集和测试集 \nset.seed(123)\ntrainIndex <- createDataPartition(iris$Species, p = 0.8, list = FALSE)\ntrainData <- iris[trainIndex, ]\ntestData <- iris[-trainIndex, ]\n \n训练随机森林模型 \nmodel <- train(Species ~ ., data = trainData, method = \"rf\")\n \n进行预测 \npredictions <- predict(model, testData)\n \n打印预测结果 \nprint(predictions)\n```\n\n### {#24__94}2.4 数据可视化与报告生成\n\nR语言在数据可视化和报告生成方面也有广泛的应用。通过使用ggplot2、shiny等包，可以生成高质量的数据可视化图形和交互式报告。\n\n```prism language-r\n示例代码：使用ggplot2进行数据可视化 \nlibrary(ggplot2)\n \n创建一个示例数据框 \ndata <- data.frame(\n  x = 1:10,\n  y = rnorm(10)\n)\n \n生成散点图 \nggplot(data, aes(x = x, y = y)) +\n  geom_point() +\n  ggtitle(\"示例散点图\") +\n  theme_minimal()\n```\n\n{#RAIGC_115}三、R语言在AIGC中的具体案例\n----------------------------\n\n### {#31__117}3.1 金融数据分析与预测\n\n在金融领域，R语言被广泛用于数据分析和预测。通过使用quantmod、forecast等包，可以进行股票价格预测、风险评估等任务。\n\n```prism language-r\n示例代码：使用quantmod进行股票价格预测 \nlibrary(quantmod)\n \n获取股票数据 \ngetSymbols(\"AAPL\")\n \n绘制股票价格图 \nchartSeries(AAPL, type = \"candlesticks\", theme = \"white\")\n```\n\n### {#32__132}3.2 医疗数据分析与建模\n\n在医疗领域，R语言被用于数据分析和建模。通过使用survival、glmnet等包，可以进行生存分析、疾病预测等任务。\n\n```prism language-r\n示例代码：使用survival进行生存分析 \nlibrary(survival)\n \n加载示例数据集 \ndata(lung)\n \n进行生存分析 \nfit <- survfit(Surv(time, status) ~ sex, data = lung)\n \n绘制生存曲线 \nplot(fit, col = c(\"red\", \"blue\"), xlab = \"时间\", ylab = \"生存概率\")\nlegend(\"topright\", legend = c(\"男性\", \"女性\"), col = c(\"red\", \"blue\"), lty = 1)\n```\n\n### {#33__151}3.3 社交媒体数据分析与情感分析\n\n在社交媒体领域，R语言被用于数据分析和情感分析。通过使用twitteR、syuzhet等包，可以进行社交媒体数据挖掘、情感分析等任务。\n\n```prism language-r\n示例代码：使用twitteR进行社交媒体数据分析 \nlibrary(twitteR)\n \n设置Twitter API密钥 \napi_key <- \"your_api_key\"\napi_secret <- \"your_api_secret\"\naccess_token <- \"your_access_token\"\naccess_secret <- \"your_access_secret\"\n \n进行身份验证 \nsetup_twitter_oauth(api_key, api_secret, access_token, access_secret)\n \n搜索推文 \ntweets <- searchTwitter(\"#AIGC\", n = 100, lang = \"en\")\n \n打印推文内容 \nprint(tweets)\n```\n\n{#RAIGC_175}四、R语言在AIGC中的未来展望\n----------------------------\n\n### {#41__177}4.1 与深度学习框架的集成\n\n随着深度学习技术的快速发展，R语言与深度学习框架的集成将成为未来的一个重要方向。通过使用Keras、TensorFlow等包，R语言可以进行深度学习模型的构建和训练。\n\n```prism language-r\n示例代码：使用Keras进行深度学习 \nlibrary(keras)\n \n加载示例数据集 \ndata <- dataset_mnist()\n \n数据预处理 \nx_train <- data$train$x \ny_train <- data$train$y \nx_test <- data$test$x \ny_test <- data$test$y \n \n构建模型 \nmodel <- keras_model_sequential() %>%\n  layer_flatten(input_shape = c(28, 28)) %>%\n  layer_dense(units = 128, activation = \"relu\") %>%\n  layer_dense(units = 10, activation = \"softmax\")\n \n编译模型 \nmodel %>% compile(\n  optimizer = \"adam\",\n  loss = \"sparse_categorical_crossentropy\",\n  metrics = c(\"accuracy\")\n)\n \n训练模型 \nmodel %>% fit(x_train, y_train, epochs = 5, validation_data = list(x_test, y_test))\n```\n\n### {#42__211}4.2 与云计算平台的集成\n\n随着云计算技术的普及，R语言与云计算平台的集成将成为未来的一个重要趋势。通过使用googleCloudRunner、aws.s3等包，R语言可以在云端进行大规模数据分析和模型训练。\n\n```prism language-r\n示例代码：使用googleCloudRunner进行云端分析 \nlibrary(googleCloudRunner)\n \n设置Google Cloud项目 \ncr_project_set(\"your_project_id\")\n \n创建一个云端任务 \njob <- cr_job_create(\n  name = \"my_job\",\n  image = \"rocker/r-ver:4.0.3\",\n  script = \"my_script.R\"\n)\n \n提交任务 \ncr_job_run(job)\n```\n\n### {#43__233}4.3 与自动化工具的集成\n\n随着自动化技术的发展，R语言与自动化工具的集成将成为未来的一个重要方向。通过使用plumber、rvest等包，R语言可以进行自动化数据采集、处理和报告生成。\n\n```prism language-r\n示例代码：使用plumber创建API \nlibrary(plumber)\n \n创建一个API \n#* @get /hello \nfunction() {\n  return(\"Hello, AIGC!\")\n}\n \n运行API \npr() %>% pr_run(port = 8000)\n```\n\nR语言在AIGC时代中展现出了强大的应用潜力。从数据预处理、文本分析、机器学习到数据可视化，R语言在各个领域都有广泛的应用。随着与深度学习框架、云计算平台和自动化工具的集成，R语言在未来的AIGC应用中将发挥更加重要的作用。通过不断学习和实践，我们可以更好地利用R语言，推动AIGC技术的发展和应用。\n\n*** ** * ** ***\n\n{#R_254}《R语言统计分析与可视化从入门到精通宣传文案》\n-------------------------------\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/cbffc6cc58954a3385d970b74cae6848.png)\n> * 当当：<https://product.dangdang.com/29788167.html>\n> * 京东：<https://item.jd.com/14798900.html>\n\n学R语言、练语法、取数据、预处理、可视化、回归分析、方差分析、聚类分析、生存分析、因子分析、基于机器学习的预测分析系统......一书在手，精通R语言统计分析与可视化！\n\n### {#_260}亮点\n\n* 全面系统学习路径：本书从R语言基础到高级统计分析技术全面覆盖，提供一站式学习体验，助力读者从入门到精通。\n* 实战案例丰富多样：通过金融、医疗、科技等领域的实战案例，将理论知识与实际应用紧密结合，提升读者实战能力。\n* 跨行业应用广泛：不仅适用于数据分析师，还适合金融从业者、教育工作者及企业数据团队等多行业读者，满足不同需求。\n* 深入浅出讲解方式：采用简洁清晰的语言，深入浅出介绍统计分析概念，同时提供高级技术细节，满足不同层次读者需求。\n* 实用工具技巧分享：除了R语言基础，还分享大量实用工具和技巧，如数据获取处理、可视化方法、模型评估等，提高读者工作效率。\n\n### {#_267}内容简介\n\n本书循序渐进、深入讲解了R语言数据统计分析与应用的核心知识，并通过具体实例的实现过程演练了知识点的用法和流程。全书共16章，分别讲解了R语言基础、R语言数据统计语法基础、数据获取和处理、绘制可视化统计图、描述性统计分析、探索性数据分析、推论统计、回归分析、方差分析、非参数统计分析、主成分分析、聚类分析、生存分析、因子分析、基于机器学习的患者再入院预测分析系统和中概科技指数统计分析与投资系统。全书简洁而不失其技术深度，内容丰富全面，历史资料翔实齐全。同时，本书易于阅读，以极简的文字介绍了复杂的案例，同时涵盖了其他同类图书中很少涉及的历史参考资料，是学习R语言数据统计分析与应用的实用教程。\n\n### {#_270}作者简介\n\n**张良康**，浙江大学统计学博士，现就职于恒瑞医药，负责医药临床试验数据分析和统计工作，参与临床试验方案设计沟通和讨论，为临床试验方案中统计学相关内容提供技术支持，包括研究设计方法的选择、样本量计算、随机和盲法、统计方法的选择等。使用R语言、SAS、SPSS等统计分析技术高达8年以上，擅长数据挖掘、分析和统计工作。具有多年的数据统计分析经验，对商务数据、销售数据、科研数据、医学数据和金融数据的统计分析工作也颇有研究。\n\n### {#_273}目录\n\n```prism language-bash\n目录\n\n第1章R语言基础\n\n1.1  R语言的发展历程2\n\n1.2  R  语言的特点2\n\n1.3  获取并安装R语言运行环境3\n\n1.3.1  在Windows操作安装R语言3\n\n1.3.2  在Linux操作和macOS操作安装R语言5\n\n1.4  R语言开发工具：R  GUI5\n\n1.4.1  命令行方式运行R语言程序6\n\n1.4.2  文件方式运行R语言程序6\n\n1.5  R语言开发工具：RStudio7\n\n1.5.1  安装RStudio7\n\n1.5.2  RStudio界面简介9\n\n1.5.3  使用RStudio开发R语言程序10\n\n1.6  认识个R语言程序：简易数据统计与格式化输出11\n\n1.6.1  新建R语言工程11\n\n1.6.2  编写程序文件12\n\n1.7  R语言和数据处理14\n\n1.7.1  R语言的优势14\n\n1.7.2  数据处理和数据分析的区别14\n\n第2章R语言数据统计语法基础\n\n2.1  基本的内置函数17\n\n2.1.1  数学和统计函数17\n\n2.1.2  字符和字符串处理函数19\n\n2.1.3  文件操作函数21\n\n2.1.4  概率分布函数25\n\n2.1.5  日期函数和时间函数27\n\n2.2  内置数据处理函数33\n\n2.2.1  查看、筛选和编辑数据33\n\n2.2.2  合并数据35\n\n2.2.3  分组和汇总38\n\n2.2.4  排序40\n\n2.2.5  转换42\n\n2.3  apply函数族43\n\n2.3.1  apply函数族中的函数43\n\n2.3.2  函数apply()44\n\n2.3.3  函数lapply()45\n\n2.3.4  函数sapply()46\n\n2.3.5  函数vapply()47\n\n2.3.6  函数mapply()49\n\n2.4  数据重塑与变形50\n\n2.5  数据查询与过滤51\n\n2.5.1  使用dplyr包进行数据查询和过滤52\n\n2.5.2  使用sqldf包进行SQL风格的查询53\n\n第3章数据获取和处理\n\n3.1  数据获取和处理简介56\n\n3.2  使用键盘输入数据57\n\n3.3  处理CSV数据58\n\n3.3.1  读取CSV文件59\n\n3.3.2  写入CSV文件60\n\n3.3.3  数据转换和处理61\n\n3.4  处理Excel数据64\n\n3.4.1  R语言和Excel文件64\n\n3.4.2  使用readxl包64\n\n3.4.3  使用openxlsx包66\n\n3.5  处理XML数据67\n\n3.5.1  使用XML包68\n\n3.5.2  使用xml2包  70\n\n3.6  处理JSON数据72\n\n3.6.1  JSON包72\n\n3.6.2  使用jsonlite包73\n\n3.6.3  使用RJSONIO包75\n\n3.6.4  使用tidyjson包76\n\n3.7  处理MySQL数据78\n\n3.7.1  和MySQL相关的包78\n\n3.7.2  使用RMySQL包78\n\n3.7.3  使用RMariaDB包80\n\n3.7.4  使用DBI包81\n\n3.7.5  dplyr包和dbplyr包82\n\n3.8  从网页抓取数据84\n\n3.8.1  使用rvest包抓取数据84\n\n3.8.2  使用httr包抓取数据85\n\n3.8.3  使用XML包抓取数据87\n\n3.8.4  使用jsonlite包抓取数据88\n\n3.9  数据准备与清洗88\n\n3.9.1  缺失数据处理89\n\n3.9.2  异常值检测和处理91\n\n3.9.3  异常值检测方法小结93\n\n第4章绘制可视化统计图\n\n4.1  R语言绘图简介97\n\n4.1.1  常用的绘图包97\n\n4.1.2  基本绘图函数plot()97\n\n4.2  单变量绘图99\n\n4.2.1  绘制直方图99\n\n4.2.2  绘制条形图102\n\n4.2.3  绘制饼形图106\n\n4.2.4  绘制箱线图107\n\n\n\n4.2.5  绘制密度图109\n\n4.3  双变量绘图112\n\n4.3.1  绘制双变量条形图112\n\n4.3.2  绘制散点图116\n\n4.3.3  绘制折线图118\n\n4.3.4  绘制箱线图（双变量）120\n\n4.4  绘制多变量图122\n\n4.4.1  绘制气泡图123\n\n4.4.2  绘制热力图125\n\n4.5  文件数据的可视化128\n\n4.5.1  CSV文件数据的可视化128\n\n4.5.2  Excel文件数据的可视化130\n\n4.5.3  XML文件数据的可视化131\n\n4.5.4  JSON文件数据的可视化132\n\n4.5.5  MySQL数据库数据的可视化134\n\n第5章描述性统计分析\n\n5.1  描述性统计分析简介137\n\n5.2  平均数、中位数和众数137\n\n5.2.1  计算平均数138\n\n5.2.2  计算中位数140\n\n5.2.3  计算众数142\n\n5.3  方差和标准差143\n\n5.3.1  计算方差144\n\n5.3.2  计算标准差145\n\n5.4  百分位数147\n\n5.4.1  常见的百分位数147\n\n5.4.2  计算百分位数148\n\n第6章探索性数据分析\n\n6.1  EDA简介151\n\n6.2  检测重复值151\n\n6.2.1  检测重复值简介151\n\n6.2.2  R语言检测重复值的方法152\n\n6.3  数据可视化方法155\n\n6.4  相关性分析162\n\n6.4.1  相关性分析的基本信息162\n\n6.4.2  皮尔逊相关系数163\n\n6.4.3  斯皮尔曼相关系数165\n\n6.4.4  肯德尔相关系数166\n\n第7章  推论统计\n\n7.1  抽样和抽样分布169\n\n7.2  置信区间169\n\n7.2.1  置信区间的概念169\n\n7.2.2  总体均值的置信区间170\n\n7.2.3  总体比例的置信区间173\n\n7.2.4  总体方差的置信区间176\n\n7.3  假设检验177\n\n7.3.1  假设检验的基本步骤178\n\n7.3.2  假设检验中的类型179\n\n7.4  抽样方法181\n\n7.4.1  随机抽样181\n\n7.4.2 抽样183\n\n7.4.3  分层抽样184\n\n7.4.4  多阶段抽样185\n\n7.5  推论统计的方向小结185\n\n7.5.1  参数推断185\n\n7.5.2  非参数推断186\n\n第8章    回归分析\n\n8.1  回归分析简介189\n\n8.2  线性回归和多元线性回归189\n\n8.2.1  线性回归189\n\n8.2.2  多元线性回归194\n\n8.3  逻辑回归197\n\n8.3.1  逻辑回归简介197\n\n8.3.2  逻辑回归的应用领域197\n\n8.3.3  使用逻辑回归模型198\n\n8.4  非线性回归201\n\n8.4.1  非线性回归简介201\n\n8.4.2  使用非线性回归模型202\n\n8.5  条件回归203\n\n8.5.1  条件回归简介203\n\n8.5.2  使用条件回归模型204\n\n第9章  方差分析\n\n9.1  方差分析简介207\n\n9.2  单因素方差分析208\n\n9.2.1  单因素方差分析的步骤208\n\n9.2.2  单因素方差分析的应用209\n\n9.3  多因素方差分析212\n\n9.3.1  多因素方差分析简介212\n\n9.3.2  两因素方差分析213\n\n9.3.3  多因素方差分析216\n\n9.4  协方差分析218\n\n9.4.1  协方差分析方法简介218\n\n9.4.2  协方差分析的应用218\n\n第10章    非参数统计分析\n\n10.1  非参数统计的方法233\n\n10.2  秩和检验233\n\n10.2.1  秩和检验简介233\n\n10.2.2  使用秩和检验234\n\n10.3  Wilcoxon符号秩检验236\n\n10.3.1  Wilcoxon符号秩检验简介236\n\n10.3.2  使用Wilcoxon符号秩检验236\n\n10.4  Kruskal-Wallis检验239\n\n10.4.1  Kruskal-Wallis检验简介240\n\n10.4.2  使用Kruskal-Wallis检验240\n\n10.5  Friedman检验247\n\n10.5.1  Friedman检验简介248\n\n10.5.2  使用Friedman检验248\n\n10.6  卡方检验250\n\n10.6.1  卡方检验简介250\n\n10.6.2  卡方拟合度检验251\n\n10.6.3  卡方独立性检验252\n\n10.7  符号检验254\n\n10.7.1  符号检验简介254\n\n10.7.2  使用符号检验254\n\n第11章    主成分分析\n\n11.1  PCA简介257\n\n11.1.1  PCA的概念257\n\n11.1.2  PCA的应用领域257\n\n11.2  PCA的数学原理258\n\n11.2.1  主成分的提取258\n\n11.2.2  PCA的可解释性259\n\n11.3  PCA的应用：信用卡欺诈检测260\n\n11.3.1  准备R语言包260\n\n11.3.2  导入数据集261\n\n11.3.3  计算ROC和AUC262\n\n11.3.4  可视化处理263\n\n11.3.5  显示混淆矩阵265\n\n11.3.6  探索数据265\n\n11.3.7  相关性分析267\n\n11.3.8  使用随机森林模型268\n\n11.3.9  欺诈预测270\n\n11.3.10  结论272\n\n第12章    聚类分析\n\n12.1  聚类分析简介274\n\n12.1.1  聚类分析的基本概念274\n\n12.1.2  聚类分析的方法274\n\n12.1.3  聚类分析的应用领域275\n\n12.2  K均值聚类276\n\n12.2.1  K均值聚类简介276\n\n12.2.2  K均值聚类的应用277\n\n12.3  层次聚类280\n\n\n\n12.3.1  层次聚类简介280\n\n12.3.2  层次聚类的应用281\n\n12.4  DBSCAN聚类285\n\n12.4.1  DBSCAN简介285\n\n12.4.2  DBSCAN的应用领域286\n\n12.4.3  使用DBSCAN聚类算法286\n\n12.5  高斯混合模型聚类289\n\n12.5.1  高斯混合模型聚类简介289\n\n12.5.2  高斯混合模型聚类的应用289\n\n12.6  谱聚类295\n\n12.6.1  谱聚类简介295\n\n12.6.2  谱聚类的应用295\n\n第13章    生存分析\n\n13.1  生存分析简介299\n\n13.1.1  生存分析的基本概念299\n\n13.1.2  生存分析的应用领域300\n\n13.1.3  用R语言实现生存分析300\n\n13.2  Kaplan-Meier生存曲线302\n\n13.2.1  Kaplan-Meier生存曲线的解释303\n\n13.2.2  Kaplan-Meier生存曲线的构建303\n\n13.3  Cox比例模型307\n\n13.3.1  Cox比例模型简介307\n\n13.3.2  Cox比例模型的应用307\n\n13.4  心血管疾病的生存分析实战309\n\n13.4.1  数据集简介309\n\n13.4.2  数据预处理310\n\n13.4.3  二元变量分布315\n\n13.4.4  连续变量分布317\n\n13.4.5  死亡事件计数与生存时间324\n\n13.4.6  相关性分析328\n\n13.4.7  变量选择的机器学习模型331\n\n13.4.8  生存分析337\n\n13.4.9  总结343\n\n第14章    因子分析\n\n14.1  因子分析简介345\n\n14.1.1  因子分析的基本概念345\n\n14.1.2  因子分析的应用领域346\n\n14.2  因子分析方法346\n\n14.2.1  常用的因子分析方法346\n\n14.2.2 大似然估计法347\n\n14.2.3 小二乘法349\n\n14.2.4  广义小二乘法351\n\n14.2.5  主轴因子分析353\n\n14.2.6  因子旋转355\n\n14.2.7  因子得分估计357\n\n14.3  因子分析的应用：心血管疾病因素分析358\n\n14.3.1  设置环境358\n\n14.3.2  数据准备和探索359\n\n14.3.3  相关性分析362\n\n14.3.4  总结371\n\n第15章    基于机器学习的患者再入院预测分析\n\n15.1  背景简介373\n\n15.2  需求分析373\n\n15.3 分析374\n\n15.4 简介375\n\n15.4.1 功能简介375\n\n15.4.2 模块结构375\n\n15.5  技术分析376\n\n15.5.1  dplyr：数据预处理376\n\n15.5.2  psych：心理学和社会科学研究376\n\n15.5.3  ROSE：不平衡处理377\n\n15.5.4  caret模型训练和评估377\n\n15.6  数据处理378\n\n15.6.1  导入数据集378\n\n15.6.2  数据预处理380\n\n15.7 方案389\n\n15.7.1  划分训练集和集390\n\n15.7.2  数据集平衡390\n\n15.7.3  交叉验证391\n\n15.7.4  模型比较394\n\n15.8  第二方案396\n\n15.8.1  数据集拆分和数据平衡396\n\n15.8.2  逻辑回归模型拟合和预测397\n\n15.8.3  计算处理397\n\n15.8.4  逻辑回归模型的拟合、预测和评估398\n\n15.8.5  使用交叉验证方法训练决策树模型399\n\n15.8.6  使用交叉验证方法训练随机森林模型400\n\n15.8.7  实现朴素贝叶斯模型401\n\n15.9  模型训练和评估402\n\n15.9.1  数据预处理402\n\n15.9.2  逻辑回归模型的训练和评估403\n\n15.9.3  决策树模型的训练和评估404\n\n15.9.4  随机森林模型的训练和评估404\n\n15.9.5  朴素贝叶斯模型的训练和评估405\n\n15.10  结论406\n\n第16章    中概科技指数统计分析与投资\n\n16.1  背景简介409\n\n16.2  需求分析409\n\n16.3 分析410\n\n16.3.1 目标410\n\n16.3.2 模块410\n\n16.3.3  数据处理流程411\n\n16.4  技术栈411\n\n16.4.1  Tidyquant：财务数据分析411\n\n16.4.2  Tidyverse：数据处理工具412\n\n16.4.3  Loess平滑算法：非参数统计方法412\n\n16.5  数据处理412\n\n16.6  中概股技术分析413\n\n16.6.1  股票价格和收益分析413\n\n16.6.2  配对分析统计图420\n\n16.6.3  MACD技术分析统计图422\n\n16.6.4  OBV技术分析统计图424\n\n16.6.5  CCI技术分析统计图430\n\n16.6.6  Chaikin  AD  Line技术分析统计图436\n\n16.6.7  相对表现比率统计图437\n\n16.6.8  RSI技术分析统计图439\n\n16.6.9  交易差价技术分析统计图444\n\n16.6.10  CCI密度图446\n\n16.6.11  自定义指数技术分析统计图448\n```\n\n{#WordExcelPPTAI_937}《Word/Excel/PPT/AI办公应用从入门到精通宣传文案》\n------------------------------------------------------\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e3c0b44eb7864ad2b74a108804ba2aeb.png)\n> * 当当：<https://product.dangdang.com/29801293.html>\n> * 京东：<https://item.jd.com/14833140.html>\n\n全面讲解Word/Excel/PPT/AI办公所有知识点和操作技能，10小时全程同步视频+Windows 11操作教学视频+1000个办公常用模板+新功能+重点知识+海量学习资源，指引Office办公从入门到精通全过程，大幅提升Office操作技能！\n\n### {#_943}亮点\n\n* 原创：以原创实战技巧和AI高效秘技为核心+全方位同步指导，全面呈现Word、Excel、PPT及AI办公应用的精髓！\n* 智能：涵盖AI在Word中的文档生成、Excel中的数据分析建议、PPT中的设计优化及AI检查语法、模拟面试等多元化AI功能，帮你显著提升办公效率与专业性！\n* 高效：集基础操作、高级技巧、举一反三案例、海量实用模板及辅助资料于一体，助力你快速掌握并应用所学！\n* 全能：与时俱进地将Microsoft 365中的Word、Excel、PowerPoint及AI助手Copilot全面融合，从文字处理、数据分析到演示文稿制作，再到AI智能辅助，一本书满足你所有办公需求！\n\n### {#_949}内容简介\n\n本书通过精选案例引导读者深入学习，系统地介绍使用Word/Excel/PPT办公应用的相关知识以及AI的辅助与应用。  \n本书分为4篇，第1篇\"Word办公应用篇\"主要介绍Word的基本操作，使用图和表格美化Word文档，以及长文档的排版等；第2篇\"Excel办公应用篇\"主要介绍Excel的基本操作，初级数据处理与分析，图表、数据透视表和数据透视图，以及公式和函数的应用等；第3篇\"PPT办公应用篇\"主要介绍PowerPoint的基本操作，动画和多媒体的应用，以及放映幻灯片等；第4篇\"Office AI助手------Copilot篇\"主要介绍Copilot助力文本处理与改写、数据处理与分析、演示文稿的制作与美化等。  \n本书不仅适合计算机初级、中级用户学习，也可以作为各类院校相关专业学生和计算机培训班学员的教材或辅导用书。\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/qq_32682301/article/details/146296671?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-06-05 17:29:18', '2025-06-05 17:29:41');
INSERT INTO `sys_article` VALUES (326, 1, 43, 'VSCode C/C++ 开发环境完整配置及一些扩展用途（自用）update:2025/3/31', 'img/VSCode CC++ 开发环境完整配置及一些扩展用途（自用）update2025331.png', 'VSCode C/C++ ', '<p>这里主要记录了一些与配置相关的内容。由于网上教程众多，部分解决方法并不能完全契合我遇到的问题，因此我选择以自己偏好的方式，对 VSCode 进行完整的配置，并记录在使用过程中遇到的问题及解决方案。后续内容也会持续更新和完善。</p>\n<pre><code class=\"lang-prism\">update 2023/4/23 心血来潮想写一下基本配置教程\nupdate 2024/1/17 更新刷题相关插件使用\nupdate 2025/1/6 添加主题扩展\nupdate 2025/2/3 添加reStructuredText文本文档教程\nupdate 2025/3/31 添加Vscode与服务器连接以及代码同步\n</code></pre>\n<p>本文档参考：</p>\n<p><a href=\"https://blog.csdn.net/u011262253/article/details/113879997\" target=\"_blank\">最新最全 VSCODE 插件推荐（2025版）</a></p>\n<p><a href=\"https://blog.csdn.net/fengshi_fengshi/article/details/142722476\" target=\"_blank\">让你工作效率翻倍的 20 个 VSCode 插件！</a></p>\n<hr />\n<br />\n<h4><a id=\"_20\"></a>文章目录</h4>\n<ul>\n<li><a href=\"#1__20\">1. 基本配置</a></li>\n<li>\n<ul>\n<li><a href=\"#11__MinGW_22\">1.1 安装 MinGW</a></li>\n<li><a href=\"#12__VSCode__29\">1.2 安装 VSCode 扩展</a></li>\n</ul>\n</li>\n<li><a href=\"#2__exe__36\">2. 设置 exe 文件路径</a></li>\n<li>\n<ul>\n<li><a href=\"#21__CodeRunner__exe__40\">2.1 使用 CodeRunner 自动清理 exe 文件</a></li>\n<li><a href=\"#22__tasksjson__launchjson__55\">2.2 使用 tasks.json 和 launch.json 配置输出目录</a></li>\n</ul>\n</li>\n<li><a href=\"#3__131\">3. 配置相关的常见问题</a></li>\n<li><a href=\"#4__147\">4. 代码格式化</a></li>\n<li>\n<ul>\n<li><a href=\"#41__148\">4.1 自动格式化</a></li>\n<li><a href=\"#42__159\">4.2 设置格式化风格</a></li>\n<li><a href=\"#43__178\">4.3 括号颜色</a></li>\n</ul>\n</li>\n<li><a href=\"#5__197\">5 刷题相关扩展</a></li>\n<li>\n<ul>\n<li><a href=\"#51_cph_198\">5.1 cph样例测试</a></li>\n<li><a href=\"#52_EL_203\">5.2 EL错误显示</a></li>\n<li><a href=\"#53_wakatime_207\">5.3 wakatime代码时间记录</a></li>\n</ul>\n</li>\n<li><a href=\"#6__217\">6 主题图标扩展</a></li>\n<li>\n<ul>\n<li><a href=\"#61__219\">6.1 文件图标</a></li>\n<li><a href=\"#62__223\">6.2 官方图标</a></li>\n</ul>\n</li>\n<li><a href=\"#7__230\">7 文档语言相关</a></li>\n<li>\n<ul>\n<li><a href=\"#71_Markdown_231\">7.1 Markdown预览与编辑</a></li>\n<li><a href=\"#72_reStructuredText_244\">7.2 reStructuredText编写</a></li>\n</ul>\n</li>\n<li><a href=\"#8_Vscode_248\">8 Vscode与服务器（教程以算力云为例）</a></li>\n<li>\n<ul>\n<li><a href=\"#81__249\">8.1 连接服务器</a></li>\n<li><a href=\"#82__312\">8.2 本地与服务器同步代码</a></li>\n<li><a href=\"#83__352\">8.3 连接服务器的问题</a></li>\n</ul>\n</li>\n</ul>\n<br />\n<hr />\n<h2><a id=\"1__201__content_views_59\"></a>{#1__20}1. 基本配置 {#content_views}</h2>\n<h3><a id=\"11__MinGW_2211__MinGW_62\"></a>{#11__MinGW_22}1.1 安装 MinGW</h3>\n<p>MinGW 是一个用于 Windows 平台的 GCC 编译器套件，支持 C/C++ 编译。以下是安装步骤：</p>\n<ol>\n<li>访问 <a href=\"https://sourceforge.net/projects/mingw-w64/files/\" target=\"_blank\">MinGW 官网</a> 下载最新版本。</li>\n<li>解压下载文件后，将 <code>bin</code> 文件夹路径添加到系统的环境变量中。例如：<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/137e92cf580a472586817806a35f166a.png\" alt=\"在这里插入图片描述\" /></li>\n<li>验证安装是否成功：打开命令行，输入 <code>g++ --version</code>，若显示版本信息，则安装成功。</li>\n</ol>\n<h3><a id=\"12__VSCode__2912__VSCode__71\"></a>{#12__VSCode__29}1.2 安装 VSCode 扩展</h3>\n<p>在 VSCode 中安装以下扩展：</p>\n<ul>\n<li><strong>C/C++</strong>：由 Microsoft 提供，支持代码高亮、调试等功能。</li>\n<li><strong>Code Runner</strong>：用于快速运行代码。</li>\n</ul>\n<hr />\n<h2><a id=\"2__exe__362__exe__80\"></a>{#2__exe__36}2. 设置 exe 文件路径</h2>\n<p>默认情况下，编译生成的 <code>.exe</code> 文件会与源代码位于同一目录下，这可能会导致文件杂乱。我们可以通过配置将其归并到指定目录中。</p>\n<h3><a id=\"21__CodeRunner__exe__4021__CodeRunner__exe__85\"></a>{#21__CodeRunner__exe__40}2.1 使用 CodeRunner 自动清理 exe 文件</h3>\n<p>CodeRunner 是一个便捷的代码运行工具，可以通过修改其配置实现自动清理功能：</p>\n<ol>\n<li>\n<p>打开 CodeRunner 扩展设置，点击齿轮图标，选择&quot;扩展设置&quot;。</p>\n</li>\n<li>\n<p>找到 <code>Code-runner: Executor Map</code>，点击&quot;在 settings.json 中编辑&quot;，并在 C 和 C++ 的命令后添加以下内容：</p>\n<pre><code class=\"lang-prism\">&amp;&amp; rm $dir$fileNameWithoutExt.exe\n</code></pre>\n<p>修改后的配置示例：<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/d2fa96e9bcd947ea84de475fcc99422b.png\" alt=\"在这里插入图片描述\" /></p>\n</li>\n<li>\n<p>在 CodeRunner 设置中勾选以下选项：</p>\n<ul>\n<li><strong>Run in Terminal</strong>：确保代码在终端中运行。</li>\n<li><strong>Save File Before Run</strong>：运行前自动保存文件。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3><a id=\"22__tasksjson__launchjson__5522__tasksjson__launchjson__104\"></a>{#22__tasksjson__launchjson__55}2.2 使用 tasks.json 和 launch.json 配置输出目录</h3>\n<p><strong>配置 tasks.json</strong><br />\n<code>tasks.json</code> 用于定义编译任务，我们将生成的 <code>.exe</code> 文件输出到 <code>output</code> 文件夹中。我的配置如下：</p>\n<pre><code class=\"lang-prism\">{\n    &quot;tasks&quot;: [\n        {\n            &quot;type&quot;: &quot;cppbuild&quot;,\n            &quot;label&quot;: &quot;C/C++: g++.exe build active file&quot;,\n            &quot;command&quot;: &quot;C:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe&quot;,\n            &quot;args&quot;: [\n                &quot;-fdiagnostics-color=always&quot;,\n                &quot;-g&quot;,\n                &quot;${file}&quot;,\n                &quot;-o&quot;,\n                &quot;${fileDirname}\\\\output\\\\${fileBasenameNoExtension}.exe&quot;\n            ],\n            &quot;options&quot;: {\n                &quot;cwd&quot;: &quot;${fileDirname}&quot;\n            },\n            &quot;problemMatcher&quot;: [&quot;$gcc&quot;],\n            &quot;group&quot;: {\n                &quot;kind&quot;: &quot;build&quot;,\n                &quot;isDefault&quot;: true\n            },\n            &quot;detail&quot;: &quot;Task generated by Debugger.&quot;\n        }\n    ],\n    &quot;version&quot;: &quot;2.0.0&quot;\n}\n</code></pre>\n<p><strong>配置 launch.json</strong><br />\n<code>launch.json</code> 用于调试配置，需与 <code>tasks.json</code> 协同工作。以下是我的配置：</p>\n<pre><code class=\"lang-prism\">{\n    &quot;configurations&quot;: [\n        {\n            &quot;name&quot;: &quot;C/C++: g++.exe build and debug active file&quot;,\n            &quot;type&quot;: &quot;cppdbg&quot;,\n            &quot;request&quot;: &quot;launch&quot;,\n            &quot;program&quot;: &quot;${fileDirname}\\\\output\\\\${fileBasenameNoExtension}.exe&quot;,\n            &quot;args&quot;: [],\n            &quot;stopAtEntry&quot;: false,\n            &quot;cwd&quot;: &quot;${fileDirname}\\\\output&quot;,\n            &quot;environment&quot;: [],\n            &quot;externalConsole&quot;: false,\n            &quot;MIMode&quot;: &quot;gdb&quot;,\n            &quot;miDebuggerPath&quot;: &quot;C:\\\\Program Files\\\\mingw64\\\\bin\\\\gdb.exe&quot;,\n            &quot;setupCommands&quot;: [\n                {\n                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,\n                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,\n                    &quot;ignoreFailures&quot;: true\n                },\n                {\n                    &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;,\n                    &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;,\n                    &quot;ignoreFailures&quot;: true\n                }\n            ],\n            &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe build active file&quot;\n        }\n    ],\n    &quot;version&quot;: &quot;2.0.0&quot;\n}\n</code></pre>\n<p><strong>效果如下：</strong></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/e56f18e725324291b3358083bd476181.png\" alt=\"在这里插入图片描述\" /></p>\n<hr />\n<h2><a id=\"3__1313__181\"></a>{#3__131}3. 配置相关的常见问题</h2>\n<p><strong>Q：编译失败，提示找不到编译器</strong><br />\n<strong>why</strong> ：未正确配置 MinGW 的环境变量。<br />\n<strong>Answer</strong> ：检查系统环境变量中是否包含 MinGW 的 <code>bin</code> 路径。</p>\n<p><strong>Q：调试时无法找到 <code>.exe</code> 文件</strong><br />\n<strong>why</strong> ：<code>tasks.json</code> 和 <code>launch.json</code> 中的路径不一致。<br />\n<strong>Answer</strong> ：确保两者中的 <code>output</code> 目录路径一致。</p>\n<p><strong>Q：运行结果无输出</strong><br />\n<strong>why</strong> ：可能未启用终端运行或代码逻辑问题。<br />\n<strong>Answer</strong>：检查 CodeRunner 设置中的&quot;Run in Terminal&quot;选项是否已勾选。</p>\n<hr />\n<h2><a id=\"4__1474__198\"></a>{#4__147}4. 代码格式化</h2>\n<h3><a id=\"41__14841__201\"></a>{#41__148}4.1 自动格式化</h3>\n<p>使用<code>alt-shift-p</code>格式化太麻烦了，设置保存时自动格式化。<br />\n勾选即可。<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/d4ebd7cd06af4c0ab060960d94e73e95.png\" alt=\"在这里插入图片描述\" /><br />\n在<code>setting.json</code>中加上这两行：</p>\n<pre><code class=\"lang-prism\">&quot;editor.formatOnType&quot;: true,\n&quot;editor.formatOnSave&quot;: true\n</code></pre>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/b4f8a7addda94d838142387d97ea025d.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"42__15942__215\"></a>{#42__159}4.2 设置格式化风格</h3>\n<p>我们知道代码的风格最典型的有两种，花括号的行位和独占一行的风格。vscode默认用的是<code>Visual Studio</code>风格，独占一行的风格，如下：</p>\n<pre><code class=\"lang-prism\">for()\n{\n//code\n}\n</code></pre>\n<p>但是我个人比较喜欢行尾风格</p>\n<pre><code class=\"lang-prism\">for(){\n}\n</code></pre>\n<p>vscode可以自定义自己的代码格式化风格。<br />\n首先<code>Ctrl Shift P</code>，输入<code>user settings</code>，搜索<code>clang</code>，如下图所示。这里面可以选择自己喜欢的风格，具体的代码风格自行查阅即可：<a href=\"https://clang.llvm.org/docs/ClangFormatStyleOptions.html\" target=\"_blank\">https://clang.llvm.org/docs/ClangFormatStyleOptions.html</a><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/d9d495a08c01429baafd3d4ed64136ff.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"43__17843__237\"></a>{#43__178}4.3 括号颜色</h3>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/35e29ed60cbf4ab48b8e42efdde66cc3.png\" alt=\"在这里插入图片描述\" /></p>\n<p>这个扩展已经弃用了，现在已经内置于vscode中。在 <code>setting.json</code> 中加入以下代码：</p>\n<pre><code class=\"lang-prism\">{\n    &quot;editor.bracketPairColorization.enabled&quot;: true,\n    &quot;editor.guides.bracketPairs&quot;:&quot;active&quot;\n}\n</code></pre>\n<p>或者直接在setting里面搜 editor.bracketPairColorization</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/3aff2724f94a46f68cde3df449ebc4b7.png\" alt=\"在这里插入图片描述\" /></p>\n<hr />\n<h2><a id=\"5__1975__256\"></a>{#5__197}5 刷题相关扩展</h2>\n<h3><a id=\"51_cph_19851_cph_259\"></a>{#51_cph_198}5.1 cph样例测试</h3>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/ea8ff26f84fe46adb0f6d11036a5ec7a.png\" alt=\"在这里插入图片描述\" /><br />\n可以进行样例测试，用法如下：<br />\n<img src=\"https://i-blog.csdnimg.cn/direct/57a75e4d0e904231808c66bbe3d54829.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"52_EL_20352_EL_265\"></a>{#52_EL_203}5.2 EL错误显示</h3>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/0b6d38207d55495e8be4d292b94c9e2b.png\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/171f401b79994ac69da4600b919eb076.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"53_wakatime_20753_wakatime_270\"></a>{#53_wakatime_207}5.3 wakatime代码时间记录</h3>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/994d047922c845ae8cbd3e53b6fabfd2.png\" alt=\"在这里插入图片描述\" /></p>\n<p>https://wakatime.com/api-key<br />\n获取key，然后安装扩展之后输入，重启即可。</p>\n<hr />\n<h2><a id=\"6__2176__279\"></a>{#6__217}6 主题图标扩展</h2>\n<h3><a id=\"61__21961__282\"></a>{#61__219}6.1 文件图标</h3>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/292a066dc7834741b24c11fdf036ed4d.png\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/1665d2327cc841ada9c580a2524376da.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"62__22362__287\"></a>{#62__223}6.2 官方图标</h3>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/0789613f2331491b991d28c2218a65fb.png\" alt=\"在这里插入图片描述\" /><br />\n个人觉得蛮好看的。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/3392c68d2e174b01b873b912ccab2ff3.png\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"7__2307__294\"></a>{#7__230}7 文档语言相关</h2>\n<h3><a id=\"71_Markdown_23171_Markdown_297\"></a>{#71_Markdown_231}7.1 Markdown预览与编辑</h3>\n<p>Markdown Preview Enhanced</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/9de5a246752940aba0f2a7b6f4ecf3b9.png\" alt=\"在这里插入图片描述\" /></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/9d5046fabf5040468b2040395f9fea1f.png\" alt=\"在这里插入图片描述\" /></p>\n<p>方便markdown进行编辑</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/887de57f803d4471adb9344f8c01584c.png\" alt=\"在这里插入图片描述\" /></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/140b29c9fac447a69c46b3b688b00b4c.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"72_reStructuredText_24472_reStructuredText_311\"></a>{#72_reStructuredText_244}7.2 reStructuredText编写</h3>\n<p>参考教程：<a href=\"https://www.osgeo.cn/sphinx-note/sphinx-rest.html\" target=\"_blank\">https://www.osgeo.cn/sphinx-note/sphinx-rest.html</a></p>\n<hr />\n<h2><a id=\"8_Vscode_2488_Vscode_317\"></a>{#8_Vscode_248}8 Vscode与服务器（教程以算力云为例）</h2>\n<h3><a id=\"81__24981__320\"></a>{#81__249}8.1 连接服务器</h3>\n<p><strong>1. 下载插件</strong></p>\n<p>搜索remote，然后下面三个都要下载</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/c5c2f33e8081489cba3abfad69222fef.png\" alt=\"在这里插入图片描述\" /></p>\n<p>ctrl + shift +p，然后打开 <code>SSH:Settings</code></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/ad2fb7ff5c83437e986fecf8fcb0432b.png\" alt=\"在这里插入图片描述\" /></p>\n<p>在setting.json中编辑</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/6994d6c1086f487ca83bcf9608a86a01.png\" alt=\"在这里插入图片描述\" /></p>\n<p>加入这行代码：</p>\n<pre><code class=\"lang-prism\">&quot;remote.SSH.useLocalServer&quot;: true\n</code></pre>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/f8deaec1cfea413ea930c6f9a7544352.png\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2. 进入远程管理器</strong></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/9bca93da006a46d184f7c478371f7cd6.png\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>3. 选择第一个…ssh\\config</strong></p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/1b3af18ffacd4a6183b27128cb4bfb8a.png\" alt=\"在这里插入图片描述\" /></p>\n<p>根据自己的服务器信息进行配置，我的如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">ssh -p <span class=\"hljs-number\">57293</span> root<span class=\"hljs-meta\">@connect</span>.xxx.com\n</code></div></pre>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/c5c02bd7bf5d4f88b3bdc920f57f2400.png\" alt=\"在这里插入图片描述\" /></p>\n<br />\n<p>之后，SSH TARGETS中会出现服务器，右键连接 <strong>（建议新窗口连接，之后会有两个窗口，一个是服务器窗口，一个是本地窗口）</strong>。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/8336fe44337246efb7d01868a5e31f01.png\" alt=\"在这里插入图片描述\" /></p>\n<p>连接过程中要输入密码</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/5e3e5612c001427fbcc888eda38a4259.png\" alt=\"在这里插入图片描述\" /></p>\n<p>连接成功之后会显示如下，在服务器窗口中可以看到，已连接。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/c97b40ef5d174b7ea9a13bdedf0f6b64.png\" alt=\"在这里插入图片描述\" /></p>\n<p>然后在服务器窗口中，打开服务器中的文件夹作为工作目录即可，我这里是 <code>TestSS</code>，右边的那一串 <code>[SSH:CONNECT...]</code> 就是你的远程服务器了</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/9ad43ba222e449bf8edb5f2744b99b01.png\" alt=\"在这里插入图片描述\" /><br />\n至此，服务器连接已经OK了。</p>\n<h3><a id=\"82__31282__379\"></a>{#82__312}8.2 本地与服务器同步代码</h3>\n<ol>\n<li>在服务器窗口中，扩展里面搜 <code>sftp</code>，如下图</li>\n</ol>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/4762ee0b9e2e4f968b98f6af5f72d8eb.png\" alt=\"在这里插入图片描述\" /></p>\n<ol start=\"2\">\n<li>快捷键ctrl+shift+P，搜 <code>SFTP.config</code></li>\n</ol>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/ffdc96a0498240f090af2f6f30fc591c.png\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"lang-prism\">{\n    &quot;name&quot;: &quot;My Server&quot;,\n    &quot;host&quot;: &quot;connect.yza1.seetacloud.com&quot;,\n    &quot;protocol&quot;: &quot;sftp&quot;,\n    &quot;port&quot;: 57293,\n    &quot;username&quot;: &quot;root&quot;,\n    &quot;password&quot;: &quot;sAxKMhezg1Ku&quot;,\n    &quot;remotePath&quot;: &quot;/&quot;,\n    &quot;uploadOnSave&quot;: true,\n    &quot;useTempFile&quot;: false,\n    &quot;openSsh&quot;: false\n}\n</code></pre>\n<p>host：改为你的远程服务器地址 connect.yza1.seetacloud.com。<br />\nport：改为你的远程服务器 SSH 端口 57293。<br />\nusername：改为你的用户名 root。<br />\npassword：请替换为你的实际密码（注意安全，不要泄露）。<br />\nremotePath：默认为 /，你可以根据需要修改为其他路径，比如 /mnt/data/yjy/quant_decryt。<br />\nuploadOnSave：默认为 false，表示保存文件时不会自动上传。如果你希望保存文件时自动上传，可以改为 true。</p>\n<p>最后一步就是上传文件了，这里直接从本地窗口拖拽过去就行了。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/0a6f9b8991cb4ce793f3af8b52152912.png\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://i-blog.csdnimg.cn/direct/55e8cca48aed45da848b63443bbfc136.png\" alt=\"在这里插入图片描述\" /></p>\n<p>不放心的话去服务器上看一眼，如下图，OK了。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/66da1fd78aed4135972e109e1ac7a646.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"83__35283__420\"></a>{#83__352}8.3 连接服务器的问题</h3>\n<p>在 <code>Remot-SSH:setting</code> 中，有一个很神奇的地方，我需要设置为true</p>\n<pre><code class=\"lang-prism\">&quot;remote.SSH.useLocalServer&quot;: true\n</code></pre>\n<p>但是在同学电脑上设置为false才能用，<code>remote.SSH.useLocalServer</code> 是 VS Code 的一个设置，用于控制是否使用本地服务器来加速远程连接。这个设置的值取决于你的系统配置和网络环境。所以可能是网络问题，将 <code>remote.SSH.useLocalServer</code> 设置为 <code>false</code> 可能更有用。（大家如果遇到的话，建议true和false都试一试，可能会有效）</p>\n<p>还有一个解决办法就是：把 <code>Remote - SSH</code> 扩展降级到 0.49.0 。</p>\n<p>参考链接：<a href=\"https://github.com/microsoft/vscode-remote-release/issues/2525\" target=\"_blank\">https://github.com/microsoft/vscode-remote-release/issues/2525</a></p>\n', '这里主要记录了一些与配置相关的内容。由于网上教程众多，部分解决方法并不能完全契合我遇到的问题，因此我选择以自己偏好的方式，对 VSCode 进行完整的配置，并记录在使用过程中遇到的问题及解决方案。后续内容也会持续更新和完善。\n\n```prism language-bash\nupdate 2023/4/23 心血来潮想写一下基本配置教程\nupdate 2024/1/17 更新刷题相关插件使用\nupdate 2025/1/6 添加主题扩展\nupdate 2025/2/3 添加reStructuredText文本文档教程\nupdate 2025/3/31 添加Vscode与服务器连接以及代码同步\n```\n\n本文档参考：\n\n[最新最全 VSCODE 插件推荐（2025版）](https://blog.csdn.net/u011262253/article/details/113879997)\n\n[让你工作效率翻倍的 20 个 VSCode 插件！](https://blog.csdn.net/fengshi_fengshi/article/details/142722476)\n\n*** ** * ** ***\n\n<br />\n\n#### 文章目录\n\n* [1. 基本配置](#1__20)\n*\n  * [1.1 安装 MinGW](#11__MinGW_22)\n  * [1.2 安装 VSCode 扩展](#12__VSCode__29)\n* [2. 设置 exe 文件路径](#2__exe__36)\n*\n  * [2.1 使用 CodeRunner 自动清理 exe 文件](#21__CodeRunner__exe__40)\n  * [2.2 使用 tasks.json 和 launch.json 配置输出目录](#22__tasksjson__launchjson__55)\n* [3. 配置相关的常见问题](#3__131)\n* [4. 代码格式化](#4__147)\n*\n  * [4.1 自动格式化](#41__148)\n  * [4.2 设置格式化风格](#42__159)\n  * [4.3 括号颜色](#43__178)\n* [5 刷题相关扩展](#5__197)\n*\n  * [5.1 cph样例测试](#51_cph_198)\n  * [5.2 EL错误显示](#52_EL_203)\n  * [5.3 wakatime代码时间记录](#53_wakatime_207)\n* [6 主题图标扩展](#6__217)\n*\n  * [6.1 文件图标](#61__219)\n  * [6.2 官方图标](#62__223)\n* [7 文档语言相关](#7__230)\n*\n  * [7.1 Markdown预览与编辑](#71_Markdown_231)\n  * [7.2 reStructuredText编写](#72_reStructuredText_244)\n* [8 Vscode与服务器（教程以算力云为例）](#8_Vscode_248)\n*\n  * [8.1 连接服务器](#81__249)\n  * [8.2 本地与服务器同步代码](#82__312)\n  * [8.3 连接服务器的问题](#83__352)\n\n<br />\n\n*** ** * ** ***\n\n{#1__20}1. 基本配置 {#content_views}\n--------------------------------\n\n### {#11__MinGW_22}1.1 安装 MinGW\n\nMinGW 是一个用于 Windows 平台的 GCC 编译器套件，支持 C/C++ 编译。以下是安装步骤：\n\n1. 访问 [MinGW 官网](https://sourceforge.net/projects/mingw-w64/files/) 下载最新版本。\n2. 解压下载文件后，将 `bin` 文件夹路径添加到系统的环境变量中。例如：  \n   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/137e92cf580a472586817806a35f166a.png)\n3. 验证安装是否成功：打开命令行，输入 `g++ --version`，若显示版本信息，则安装成功。\n\n### {#12__VSCode__29}1.2 安装 VSCode 扩展\n\n在 VSCode 中安装以下扩展：\n\n* **C/C++**：由 Microsoft 提供，支持代码高亮、调试等功能。\n* **Code Runner**：用于快速运行代码。\n\n*** ** * ** ***\n\n{#2__exe__36}2. 设置 exe 文件路径\n---------------------------\n\n默认情况下，编译生成的 `.exe` 文件会与源代码位于同一目录下，这可能会导致文件杂乱。我们可以通过配置将其归并到指定目录中。\n\n### {#21__CodeRunner__exe__40}2.1 使用 CodeRunner 自动清理 exe 文件\n\nCodeRunner 是一个便捷的代码运行工具，可以通过修改其配置实现自动清理功能：\n\n1. 打开 CodeRunner 扩展设置，点击齿轮图标，选择\"扩展设置\"。\n2. 找到 `Code-runner: Executor Map`，点击\"在 settings.json 中编辑\"，并在 C 和 C++ 的命令后添加以下内容：\n\n   ```prism language-json\n   && rm $dir$fileNameWithoutExt.exe\n   ```\n\n   修改后的配置示例：  \n   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d2fa96e9bcd947ea84de475fcc99422b.png)\n3. 在 CodeRunner 设置中勾选以下选项：\n   * **Run in Terminal**：确保代码在终端中运行。\n   * **Save File Before Run**：运行前自动保存文件。\n\n*** ** * ** ***\n\n### {#22__tasksjson__launchjson__55}2.2 使用 tasks.json 和 launch.json 配置输出目录\n\n**配置 tasks.json**   \n`tasks.json` 用于定义编译任务，我们将生成的 `.exe` 文件输出到 `output` 文件夹中。我的配置如下：\n\n```prism language-json\n{\n    \"tasks\": [\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"C/C++: g++.exe build active file\",\n            \"command\": \"C:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe\",\n            \"args\": [\n                \"-fdiagnostics-color=always\",\n                \"-g\",\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}\\\\output\\\\${fileBasenameNoExtension}.exe\"\n            ],\n            \"options\": {\n                \"cwd\": \"${fileDirname}\"\n            },\n            \"problemMatcher\": [\"$gcc\"],\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            },\n            \"detail\": \"Task generated by Debugger.\"\n        }\n    ],\n    \"version\": \"2.0.0\"\n}\n```\n\n**配置 launch.json**   \n`launch.json` 用于调试配置，需与 `tasks.json` 协同工作。以下是我的配置：\n\n```prism language-json\n{\n    \"configurations\": [\n        {\n            \"name\": \"C/C++: g++.exe build and debug active file\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${fileDirname}\\\\output\\\\${fileBasenameNoExtension}.exe\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${fileDirname}\\\\output\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"gdb\",\n            \"miDebuggerPath\": \"C:\\\\Program Files\\\\mingw64\\\\bin\\\\gdb.exe\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                },\n                {\n                    \"description\": \"Set Disassembly Flavor to Intel\",\n                    \"text\": \"-gdb-set disassembly-flavor intel\",\n                    \"ignoreFailures\": true\n                }\n            ],\n            \"preLaunchTask\": \"C/C++: g++.exe build active file\"\n        }\n    ],\n    \"version\": \"2.0.0\"\n}\n```\n\n**效果如下：**\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e56f18e725324291b3358083bd476181.png)\n\n*** ** * ** ***\n\n{#3__131}3. 配置相关的常见问题\n---------------------\n\n**Q：编译失败，提示找不到编译器**   \n**why** ：未正确配置 MinGW 的环境变量。  \n**Answer** ：检查系统环境变量中是否包含 MinGW 的 `bin` 路径。\n\n**Q：调试时无法找到 `.exe` 文件**   \n**why** ：`tasks.json` 和 `launch.json` 中的路径不一致。  \n**Answer** ：确保两者中的 `output` 目录路径一致。\n\n**Q：运行结果无输出**   \n**why** ：可能未启用终端运行或代码逻辑问题。  \n**Answer**：检查 CodeRunner 设置中的\"Run in Terminal\"选项是否已勾选。\n\n*** ** * ** ***\n\n{#4__147}4. 代码格式化\n-----------------\n\n### {#41__148}4.1 自动格式化\n\n使用`alt-shift-p`格式化太麻烦了，设置保存时自动格式化。  \n勾选即可。  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d4ebd7cd06af4c0ab060960d94e73e95.png)  \n在`setting.json`中加上这两行：\n\n```prism language-json\n\"editor.formatOnType\": true,\n\"editor.formatOnSave\": true\n```\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b4f8a7addda94d838142387d97ea025d.png)\n\n### {#42__159}4.2 设置格式化风格\n\n我们知道代码的风格最典型的有两种，花括号的行位和独占一行的风格。vscode默认用的是`Visual Studio`风格，独占一行的风格，如下：\n\n```prism language-cpp\nfor()\n{\n//code\n}\n```\n\n但是我个人比较喜欢行尾风格\n\n```prism language-cpp\nfor(){\n}\n```\n\nvscode可以自定义自己的代码格式化风格。  \n首先`Ctrl Shift P`，输入`user settings`，搜索`clang`，如下图所示。这里面可以选择自己喜欢的风格，具体的代码风格自行查阅即可：<https://clang.llvm.org/docs/ClangFormatStyleOptions.html>  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d9d495a08c01429baafd3d4ed64136ff.png)\n\n### {#43__178}4.3 括号颜色\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/35e29ed60cbf4ab48b8e42efdde66cc3.png)\n\n这个扩展已经弃用了，现在已经内置于vscode中。在 `setting.json` 中加入以下代码：\n\n```prism language-bash\n{\n    \"editor.bracketPairColorization.enabled\": true,\n    \"editor.guides.bracketPairs\":\"active\"\n}\n```\n\n或者直接在setting里面搜 editor.bracketPairColorization\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3aff2724f94a46f68cde3df449ebc4b7.png)\n\n*** ** * ** ***\n\n{#5__197}5 刷题相关扩展\n-----------------\n\n### {#51_cph_198}5.1 cph样例测试\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ea8ff26f84fe46adb0f6d11036a5ec7a.png)  \n可以进行样例测试，用法如下：  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/57a75e4d0e904231808c66bbe3d54829.png)\n\n### {#52_EL_203}5.2 EL错误显示\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0b6d38207d55495e8be4d292b94c9e2b.png)  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/171f401b79994ac69da4600b919eb076.png)\n\n### {#53_wakatime_207}5.3 wakatime代码时间记录\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/994d047922c845ae8cbd3e53b6fabfd2.png)\n\nhttps://wakatime.com/api-key  \n获取key，然后安装扩展之后输入，重启即可。\n\n*** ** * ** ***\n\n{#6__217}6 主题图标扩展\n-----------------\n\n### {#61__219}6.1 文件图标\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/292a066dc7834741b24c11fdf036ed4d.png)  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1665d2327cc841ada9c580a2524376da.png)\n\n### {#62__223}6.2 官方图标\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0789613f2331491b991d28c2218a65fb.png)  \n个人觉得蛮好看的。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3392c68d2e174b01b873b912ccab2ff3.png)\n\n{#7__230}7 文档语言相关\n-----------------\n\n### {#71_Markdown_231}7.1 Markdown预览与编辑\n\nMarkdown Preview Enhanced\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9de5a246752940aba0f2a7b6f4ecf3b9.png)\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9d5046fabf5040468b2040395f9fea1f.png)\n\n方便markdown进行编辑\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/887de57f803d4471adb9344f8c01584c.png)\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/140b29c9fac447a69c46b3b688b00b4c.png)\n\n### {#72_reStructuredText_244}7.2 reStructuredText编写\n\n参考教程：<https://www.osgeo.cn/sphinx-note/sphinx-rest.html>\n\n*** ** * ** ***\n\n{#8_Vscode_248}8 Vscode与服务器（教程以算力云为例）\n-------------------------------------\n\n### {#81__249}8.1 连接服务器\n\n**1. 下载插件**\n\n搜索remote，然后下面三个都要下载\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c5c2f33e8081489cba3abfad69222fef.png)\n\nctrl + shift +p，然后打开 `SSH:Settings`\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ad2fb7ff5c83437e986fecf8fcb0432b.png)\n\n在setting.json中编辑\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6994d6c1086f487ca83bcf9608a86a01.png)\n\n加入这行代码：\n\n```prism language-bash\n\"remote.SSH.useLocalServer\": true\n```\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f8deaec1cfea413ea930c6f9a7544352.png)\n\n**2. 进入远程管理器**\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9bca93da006a46d184f7c478371f7cd6.png)  \n\n**3. 选择第一个..ssh\\\\config**\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1b3af18ffacd4a6183b27128cb4bfb8a.png)\n\n根据自己的服务器信息进行配置，我的如下：\n\n```java\nssh -p 57293 root@connect.xxx.com\n```\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c5c02bd7bf5d4f88b3bdc920f57f2400.png)  \n\n<br />\n\n之后，SSH TARGETS中会出现服务器，右键连接 **（建议新窗口连接，之后会有两个窗口，一个是服务器窗口，一个是本地窗口）**。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8336fe44337246efb7d01868a5e31f01.png)\n\n连接过程中要输入密码\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5e3e5612c001427fbcc888eda38a4259.png)\n\n连接成功之后会显示如下，在服务器窗口中可以看到，已连接。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c97b40ef5d174b7ea9a13bdedf0f6b64.png)\n\n然后在服务器窗口中，打开服务器中的文件夹作为工作目录即可，我这里是 `TestSS`，右边的那一串 `[SSH:CONNECT...]` 就是你的远程服务器了\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9ad43ba222e449bf8edb5f2744b99b01.png)  \n至此，服务器连接已经OK了。\n\n### {#82__312}8.2 本地与服务器同步代码\n\n1. 在服务器窗口中，扩展里面搜 `sftp`，如下图\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4762ee0b9e2e4f968b98f6af5f72d8eb.png)\n\n2. 快捷键ctrl+shift+P，搜 `SFTP.config`\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ffdc96a0498240f090af2f6f30fc591c.png)\n\n```prism language-bash\n{\n    \"name\": \"My Server\",\n    \"host\": \"connect.yza1.seetacloud.com\",\n    \"protocol\": \"sftp\",\n    \"port\": 57293,\n    \"username\": \"root\",\n    \"password\": \"sAxKMhezg1Ku\",\n    \"remotePath\": \"/\",\n    \"uploadOnSave\": true,\n    \"useTempFile\": false,\n    \"openSsh\": false\n}\n```\n\nhost：改为你的远程服务器地址 connect.yza1.seetacloud.com。  \nport：改为你的远程服务器 SSH 端口 57293。  \nusername：改为你的用户名 root。  \npassword：请替换为你的实际密码（注意安全，不要泄露）。  \nremotePath：默认为 /，你可以根据需要修改为其他路径，比如 /mnt/data/yjy/quant_decryt。  \nuploadOnSave：默认为 false，表示保存文件时不会自动上传。如果你希望保存文件时自动上传，可以改为 true。\n\n最后一步就是上传文件了，这里直接从本地窗口拖拽过去就行了。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0a6f9b8991cb4ce793f3af8b52152912.png)  \n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/55e8cca48aed45da848b63443bbfc136.png)\n\n不放心的话去服务器上看一眼，如下图，OK了。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/66da1fd78aed4135972e109e1ac7a646.png)\n\n### {#83__352}8.3 连接服务器的问题\n\n在 `Remot-SSH:setting` 中，有一个很神奇的地方，我需要设置为true\n\n```prism language-bash\n\"remote.SSH.useLocalServer\": true\n```\n\n但是在同学电脑上设置为false才能用，`remote.SSH.useLocalServer` 是 VS Code 的一个设置，用于控制是否使用本地服务器来加速远程连接。这个设置的值取决于你的系统配置和网络环境。所以可能是网络问题，将 `remote.SSH.useLocalServer` 设置为 `false` 可能更有用。（大家如果遇到的话，建议true和false都试一试，可能会有效）\n\n还有一个解决办法就是：把 `Remote - SSH` 扩展降级到 0.49.0 。\n\n参考链接：<https://github.com/microsoft/vscode-remote-release/issues/2525>\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/nyxdsb/article/details/145599526?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-06-12 17:30:20', '2025-06-12 16:21:29');
INSERT INTO `sys_article` VALUES (327, 1, 31, '前端高级CSS用法', 'img/前端高级CSS用法.png', 'CSS', '<h4><a id=\"CSS_0\"></a>前端高级CSS用法</h4>\n<p>在前端开发中，CSS（层叠样式表）不仅是用来控制网页的外观和布局，更是实现复杂交互和动态效果的关键技术之一。随着前端技术的不断发展，CSS的用法也日益丰富和高级。本文将深入探讨前端高级CSS的用法，并通过表格和流程图来直观展示。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/08386bd4dd1f4fcd9235a0d2755badc9.png\" alt=\"在这里插入图片描述\" /></p>\n<h5><a id=\"CSS_10CSS_6\"></a>{#CSS_10}一、CSS高级选择器</h5>\n<p>CSS选择器是选择HTML元素并应用样式的基础。高级选择器使得我们能够更加精确地选择元素，从而实现更复杂的样式效果。</p>\n<ol>\n<li>\n<p><strong>属性选择器</strong> ：根据元素的属性来选择元素。例如，选择所有带有<code>title</code>属性的元素：</p>\n<pre><code class=\"lang-prism\">[title] {\n    color: blue;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>伪类选择器</strong>：用于选择元素的特定状态。例如，选择所有悬停状态的链接：</p>\n<pre><code class=\"lang-prism\">a:hover {\n    text-decoration: underline;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>伪元素选择器</strong>：用于选择元素的一部分。例如，选择所有段落的首行：</p>\n<pre><code class=\"lang-prism\">p::first-line {\n    font-weight: bold;\n}\n</code></pre>\n</li>\n</ol>\n<h5><a id=\"CSS_38CSS_34\"></a>{#CSS_38}二、CSS布局与定位</h5>\n<ol>\n<li>\n<p><strong>Flexbox布局</strong>：一种一维布局模型，用于在容器中沿主轴或交叉轴排列子元素。它提供了灵活的布局方式，能够轻松实现响应式设计。</p>\n<pre><code class=\"lang-prism\">.container {\n    display: flex;\n    justify-content: center; /* 水平居中 */\n    align-items: center;     /* 垂直居中 */\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Grid布局</strong>：一种二维布局模型，提供了更强大的布局能力。它允许我们创建复杂的网格布局，并支持响应式设计。</p>\n<pre><code class=\"lang-prism\">.grid-container {\n    display: grid;\n    grid-template-columns: repeat(3, 1fr); /* 三列等宽布局 */\n    grid-gap: 10px;                       /* 网格间距 */\n}\n</code></pre>\n</li>\n<li>\n<p><strong>定位（Positioning）</strong>：用于改变元素在文档流中的位置。常见的定位方式有相对定位（relative）、绝对定位（absolute）、固定定位（fixed）和粘性定位（sticky）。</p>\n<pre><code class=\"lang-prism\">.relative {\n    position: relative;\n    top: 10px;\n    left: 20px;\n}\n\n.absolute {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n</code></pre>\n</li>\n</ol>\n<h5><a id=\"CSS_77CSS_73\"></a>{#CSS_77}三、CSS动画与过渡</h5>\n<ol>\n<li>\n<p><strong>过渡（Transition）</strong>：用于在元素状态改变时添加平滑的过渡效果。例如，改变元素的颜色时添加过渡效果：</p>\n<pre><code class=\"lang-prism\">.box {\n    width: 100px;\n    height: 100px;\n    background-color: red;\n    transition: background-color 0.5s ease;\n}\n\n.box:hover {\n    background-color: blue;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>动画（Animation）</strong> ：用于创建复杂的动画效果。通过<code>@keyframes</code>规则定义动画的关键帧，然后通过<code>animation</code>属性应用动画。</p>\n<pre><code class=\"lang-prism\">@keyframes example {\n    from {background-color: red;}\n    to {background-color: yellow;}\n}\n\n.box {\n    width: 100px;\n    height: 100px;\n    background-color: red;\n    animation: example 2s infinite;\n}\n</code></pre>\n</li>\n</ol>\n<h5><a id=\"CSS_110CSS_106\"></a>{#CSS_110}四、CSS高级技巧</h5>\n<ol>\n<li>\n<p><strong>CSS变量</strong>：允许在CSS中定义变量，以便在多个地方重用相同的值。这有助于提高代码的可维护性和可读性。</p>\n<pre><code class=\"lang-prism\">:root {\n    --main-color: #3498db;\n}\n\n.box {\n    background-color: var(--main-color);\n}\n</code></pre>\n</li>\n<li>\n<p><strong>媒体查询（Media Queries）</strong>：用于根据不同的设备特性（如屏幕宽度、高度、分辨率等）应用不同的样式。这是实现响应式设计的关键技术之一。</p>\n<pre><code class=\"lang-prism\">@media (max-width: 600px) {\n    .container {\n        flex-direction: column;\n    }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>CSS Sprites（精灵图）</strong> ：一种将多个小图像合并到一个大图像中的技术。通过CSS的<code>background-position</code>属性来显示大图像中的不同部分，从而减少HTTP请求数，提高页面加载速度。</p>\n</li>\n</ol>\n<h5><a id=\"_136_132\"></a>{#_136}五、表格与流程图示例</h5>\n<p><strong>表格示例</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>选择器类型</th>\n<th>示例</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>属性选择器</td>\n<td><code>[type=&quot;text&quot;]</code></td>\n<td>选择所有类型为<code>text</code>的输入元素</td>\n</tr>\n<tr>\n<td>伪类选择器</td>\n<td><code>a:visited</code></td>\n<td>选择所有已访问的链接</td>\n</tr>\n<tr>\n<td>伪元素选择器</td>\n<td><code>p::first-letter</code></td>\n<td>选择所有段落的首字母</td>\n</tr>\n<tr>\n<td>Flexbox布局</td>\n<td><code>.container { display: flex; }</code></td>\n<td>创建一个Flex容器</td>\n</tr>\n<tr>\n<td>Grid布局</td>\n<td><code>.grid-container { display: grid; }</code></td>\n<td>创建一个Grid容器</td>\n</tr>\n<tr>\n<td>定位</td>\n<td><code>.relative { position: relative; }</code></td>\n<td>相对定位元素</td>\n</tr>\n<tr>\n<td>过渡</td>\n<td><code>.box { transition: background-color 0.5s; }</code></td>\n<td>添加背景颜色过渡效果</td>\n</tr>\n<tr>\n<td>动画</td>\n<td><code>@keyframes example { from { opacity: 0; } to { opacity: 1; } }</code></td>\n<td>定义动画关键帧</td>\n</tr>\n<tr>\n<td>CSS变量</td>\n<td><code>:root { --main-color: #3498db; }</code></td>\n<td>定义全局CSS变量</td>\n</tr>\n<tr>\n<td>媒体查询</td>\n<td><code>@media (max-width: 600px) { .container { flex-direction: column; } }</code></td>\n<td>根据屏幕宽度应用不同样式</td>\n</tr>\n</tbody>\n</table>\n<p><strong>流程图示例</strong>（用纯CSS实现）：</p>\n<pre><code class=\"lang-prism\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;CSS流程图示例&lt;/title&gt;\n    &lt;style&gt;\n        .flowchart {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n\n        .step {\n            background-color: #f9f9f9;\n            border: 1px solid #ddd;\n            padding: 20px;\n            margin: 10px;\n            border-radius: 5px;\n            text-align: center;\n        }\n\n        .arrow {\n            width: 0;\n            height: 0;\n            border-left: 10px solid transparent;\n            border-right: 10px solid transparent;\n            border-top: 10px solid #ddd;\n            margin: 0 auto;\n        }\n\n        .start {\n            background-color: #ffeb3b;\n        }\n\n        .end {\n            background-color: #4caf50;\n            color: white;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;flowchart&quot;&gt;\n        &lt;div class=&quot;step start&quot;&gt;开始&lt;/div&gt;\n        &lt;div class=&quot;arrow&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;step&quot;&gt;步骤1&lt;/div&gt;\n        &lt;div class=&quot;arrow&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;step&quot;&gt;步骤2&lt;/div&gt;\n        &lt;div class=&quot;arrow&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;step&quot;&gt;步骤3&lt;/div&gt;\n        &lt;div class=&quot;arrow&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;step end&quot;&gt;结束&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>在这个流程图示例中，我们使用了Flexbox布局来垂直排列流程图的各个步骤，并通过CSS样式来美化步骤和箭头。通过调整样式，我们可以轻松实现不同风格的流程图。</p>\n<h5><a id=\"_215_211\"></a>{#_215}六、总结</h5>\n<p>前端高级CSS用法涵盖了选择器、布局与定位、动画与过渡、高级技巧等多个方面。通过掌握这些用法，我们可以创建出更加美观、交互性更强的网页。同时，结合表格和流程图等示例，我们可以更直观地理解和应用这些高级CSS用法。</p>\n<br />\n<br />\n<br />\n', '#### 前端高级CSS用法 \n\n在前端开发中，CSS（层叠样式表）不仅是用来控制网页的外观和布局，更是实现复杂交互和动态效果的关键技术之一。随着前端技术的不断发展，CSS的用法也日益丰富和高级。本文将深入探讨前端高级CSS的用法，并通过表格和流程图来直观展示。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/08386bd4dd1f4fcd9235a0d2755badc9.png)\n\n##### {#CSS_10}一、CSS高级选择器\n\nCSS选择器是选择HTML元素并应用样式的基础。高级选择器使得我们能够更加精确地选择元素，从而实现更复杂的样式效果。\n\n1. **属性选择器** ：根据元素的属性来选择元素。例如，选择所有带有`title`属性的元素：\n\n   ```prism language-css\n   [title] {\n       color: blue;\n   }\n   ```\n\n2. **伪类选择器**：用于选择元素的特定状态。例如，选择所有悬停状态的链接：\n\n   ```prism language-css\n   a:hover {\n       text-decoration: underline;\n   }\n   ```\n\n3. **伪元素选择器**：用于选择元素的一部分。例如，选择所有段落的首行：\n\n   ```prism language-css\n   p::first-line {\n       font-weight: bold;\n   }\n   ```\n\n##### {#CSS_38}二、CSS布局与定位\n\n1. **Flexbox布局**：一种一维布局模型，用于在容器中沿主轴或交叉轴排列子元素。它提供了灵活的布局方式，能够轻松实现响应式设计。\n\n   ```prism language-css\n   .container {\n       display: flex;\n       justify-content: center; /* 水平居中 */\n       align-items: center;     /* 垂直居中 */\n   }\n   ```\n\n2. **Grid布局**：一种二维布局模型，提供了更强大的布局能力。它允许我们创建复杂的网格布局，并支持响应式设计。\n\n   ```prism language-css\n   .grid-container {\n       display: grid;\n       grid-template-columns: repeat(3, 1fr); /* 三列等宽布局 */\n       grid-gap: 10px;                       /* 网格间距 */\n   }\n   ```\n\n3. **定位（Positioning）**：用于改变元素在文档流中的位置。常见的定位方式有相对定位（relative）、绝对定位（absolute）、固定定位（fixed）和粘性定位（sticky）。\n\n   ```prism language-css\n   .relative {\n       position: relative;\n       top: 10px;\n       left: 20px;\n   }\n\n   .absolute {\n       position: absolute;\n       top: 50%;\n       left: 50%;\n       transform: translate(-50%, -50%);\n   }\n   ```\n\n##### {#CSS_77}三、CSS动画与过渡\n\n1. **过渡（Transition）**：用于在元素状态改变时添加平滑的过渡效果。例如，改变元素的颜色时添加过渡效果：\n\n   ```prism language-css\n   .box {\n       width: 100px;\n       height: 100px;\n       background-color: red;\n       transition: background-color 0.5s ease;\n   }\n\n   .box:hover {\n       background-color: blue;\n   }\n   ```\n\n2. **动画（Animation）** ：用于创建复杂的动画效果。通过`@keyframes`规则定义动画的关键帧，然后通过`animation`属性应用动画。\n\n   ```prism language-css\n   @keyframes example {\n       from {background-color: red;}\n       to {background-color: yellow;}\n   }\n\n   .box {\n       width: 100px;\n       height: 100px;\n       background-color: red;\n       animation: example 2s infinite;\n   }\n   ```\n\n##### {#CSS_110}四、CSS高级技巧\n\n1. **CSS变量**：允许在CSS中定义变量，以便在多个地方重用相同的值。这有助于提高代码的可维护性和可读性。\n\n   ```prism language-css\n   :root {\n       --main-color: #3498db;\n   }\n\n   .box {\n       background-color: var(--main-color);\n   }\n   ```\n\n2. **媒体查询（Media Queries）**：用于根据不同的设备特性（如屏幕宽度、高度、分辨率等）应用不同的样式。这是实现响应式设计的关键技术之一。\n\n   ```prism language-css\n   @media (max-width: 600px) {\n       .container {\n           flex-direction: column;\n       }\n   }\n   ```\n\n3. **CSS Sprites（精灵图）** ：一种将多个小图像合并到一个大图像中的技术。通过CSS的`background-position`属性来显示大图像中的不同部分，从而减少HTTP请求数，提高页面加载速度。\n\n##### {#_136}五、表格与流程图示例\n\n**表格示例**：\n\n|   选择器类型   |                                   示例                                   |         描述         |\n|-----------|------------------------------------------------------------------------|--------------------|\n| 属性选择器     | `[type=\"text\"]`                                                        | 选择所有类型为`text`的输入元素 |\n| 伪类选择器     | `a:visited`                                                            | 选择所有已访问的链接         |\n| 伪元素选择器    | `p::first-letter`                                                      | 选择所有段落的首字母         |\n| Flexbox布局 | `.container { display: flex; }`                                        | 创建一个Flex容器         |\n| Grid布局    | `.grid-container { display: grid; }`                                   | 创建一个Grid容器         |\n| 定位        | `.relative { position: relative; }`                                    | 相对定位元素             |\n| 过渡        | `.box { transition: background-color 0.5s; }`                          | 添加背景颜色过渡效果         |\n| 动画        | `@keyframes example { from { opacity: 0; } to { opacity: 1; } }`       | 定义动画关键帧            |\n| CSS变量     | `:root { --main-color: #3498db; }`                                     | 定义全局CSS变量          |\n| 媒体查询      | `@media (max-width: 600px) { .container { flex-direction: column; } }` | 根据屏幕宽度应用不同样式       |\n\n**流程图示例**（用纯CSS实现）：\n\n```prism language-html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CSS流程图示例</title>\n    <style>\n        .flowchart {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n\n        .step {\n            background-color: #f9f9f9;\n            border: 1px solid #ddd;\n            padding: 20px;\n            margin: 10px;\n            border-radius: 5px;\n            text-align: center;\n        }\n\n        .arrow {\n            width: 0;\n            height: 0;\n            border-left: 10px solid transparent;\n            border-right: 10px solid transparent;\n            border-top: 10px solid #ddd;\n            margin: 0 auto;\n        }\n\n        .start {\n            background-color: #ffeb3b;\n        }\n\n        .end {\n            background-color: #4caf50;\n            color: white;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"flowchart\">\n        <div class=\"step start\">开始</div>\n        <div class=\"arrow\"></div>\n        <div class=\"step\">步骤1</div>\n        <div class=\"arrow\"></div>\n        <div class=\"step\">步骤2</div>\n        <div class=\"arrow\"></div>\n        <div class=\"step\">步骤3</div>\n        <div class=\"arrow\"></div>\n        <div class=\"step end\">结束</div>\n    </div>\n</body>\n</html>\n```\n\n在这个流程图示例中，我们使用了Flexbox布局来垂直排列流程图的各个步骤，并通过CSS样式来美化步骤和箭头。通过调整样式，我们可以轻松实现不同风格的流程图。\n\n##### {#_215}六、总结\n\n前端高级CSS用法涵盖了选择器、布局与定位、动画与过渡、高级技巧等多个方面。通过掌握这些用法，我们可以创建出更加美观、交互性更强的网页。同时，结合表格和流程图等示例，我们可以更直观地理解和应用这些高级CSS用法。\n\n<br />\n\n<br />\n\n<br />\n\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/qq_34419312/article/details/146287976?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-06-20 17:33:17', '2025-06-20 12:29:36');
INSERT INTO `sys_article` VALUES (329, 1, 39, '最新版Manus 实操手册', 'img/最新版Manus 实操手册.png', 'Manus ', '<h2><a id=\"Manus__0\"></a>Manus 实操手册</h2>\n<h3><a id=\"Manus__3\"></a>一、Manus 概述</h3>\n<h4><a id=\"11__511__5\"></a>{#11__5}1.1 官网入口</h4>\n<p>Manus 的官方网站为 https://manus.im，用户可通过浏览器直接访问。该网站是产品的主要信息发布渠道，提供功能演示、案例库、内测申请入口等核心服务。官网设计简洁，首页展示产品定位、核心功能模块及用户评价，适合零基础用户快速了解产品价值。</p>\n<h4><a id=\"12__912__9\"></a>{#12__9}1.2 产品定位</h4>\n<h5><a id=\"121__11121__11\"></a>{#121__11}1.2.1 定义与目标</h5>\n<p>Manus 是全球首款通用型 AI 智能体（Agent），由中国 Monica 团队研发。其核心目标是&quot;将用户的想法转化为具体成果&quot;，通过自主规划、调用工具和交付完整任务成果，帮助用户高效完成复杂任务。与普通聊天机器人不同，Manus 能够独立执行端到端任务，例如从数据收集、分析到生成可视化报告的全流程操作。</p>\n<h5><a id=\"122__15122__15\"></a>{#122__15}1.2.2 核心特点</h5>\n<ul>\n<li><strong>通用性</strong>：支持跨领域任务，涵盖金融分析、旅行规划、教育课件制作等 51 个场景。</li>\n<li><strong>自主性</strong>：无需用户分步指导，可自动分解任务、调用工具（如代码编辑器、浏览器）并优化执行路径。</li>\n<li><strong>交付能力</strong>：直接生成可视化成果（如 PDF、Excel、网页），而非仅提供文字建议。</li>\n</ul>\n<h5><a id=\"123__21123__21\"></a>{#123__21}1.2.3 技术架构</h5>\n<p>Manus 采用多智能体系统（Multiple Agent System）与云端虚拟机技术：</p>\n<ul>\n<li><strong>规划层</strong>：分析用户需求，拆解任务步骤（如&quot;分析股票&quot;拆解为数据抓取、趋势建模、报告生成）。</li>\n<li><strong>执行层</strong>：调用虚拟环境中的工具（代码执行、网页浏览、文件处理）。</li>\n<li><strong>验证层</strong>：检查结果准确性，动态修正错误。</li>\n</ul>\n<h4><a id=\"13__2913__29\"></a>{#13__29}1.3 团队背景</h4>\n<h5><a id=\"131_Red_31131_Red_31\"></a>{#131_Red_31}1.3.1 创始人：肖弘（Red）</h5>\n<ul>\n<li><strong>履历</strong>：连续创业者，华中科技大学软件工程专业毕业。曾开发微信公众号增强工具&quot;莺件&quot;和企业微信应用&quot;微伴助手&quot;，获腾讯投资。</li>\n<li><strong>理念</strong>：主张&quot;AI 应成为生产力伙伴&quot;，推动 Manus 从工具型助手进化为自主代理。</li>\n</ul>\n<h5><a id=\"132_Peak_36132_Peak_36\"></a>{#132_Peak_36}1.3.2 首席科学家：季逸超（Peak）</h5>\n<ul>\n<li><strong>成就</strong>：主导开发中文互联网最大通用知识图谱系统 Magi，曾推出 iOS 浏览器&quot;猛犸&quot;并获 MacWorld 特等奖。</li>\n<li><strong>技术贡献</strong>：为 Manus 设计基于 LLM 的操作系统架构，实现多模态数据处理与跨平台工具调用。</li>\n</ul>\n<h5><a id=\"133__41133__41\"></a>{#133__41}1.3.3 技术团队</h5>\n<ul>\n<li><strong>规模</strong>：Monica 团队成立于 2023 年，现有成员 51-200 人，专注 AI 推理与工程化落地。</li>\n<li><strong>里程碑</strong>：2022 年立项 Monica 项目（早于 ChatGPT 发布），2025 年推出 Manus，在 GAIA 基准测试中超越 OpenAI 同类产品。</li>\n</ul>\n<h4><a id=\"14__4614__46\"></a>{#14__46}1.4 产品发展历程</h4>\n<h5><a id=\"141__48141__48\"></a>{#141__48}1.4.1 早期探索</h5>\n<ul>\n<li><strong>2022 年</strong>：Monica 项目立项，以浏览器插件形式提供 AI 助手服务，集成多模型 API 并主打海外市场。</li>\n<li><strong>2024 年</strong>：用户突破百万，成为海外 AI 插件领域头部产品，验证工具调用与任务自动化能力。</li>\n</ul>\n<h5><a id=\"142__53142__53\"></a>{#142__53}1.4.2 技术突破</h5>\n<ul>\n<li><strong>2025 年</strong>：发布 Manus，整合动态任务调度引擎、神经记忆网络等创新技术，实现从&quot;辅助工具&quot;到&quot;自主代理&quot;的跨越。</li>\n</ul>\n<h5><a id=\"143__57143__57\"></a>{#143__57}1.4.3 市场反响</h5>\n<ul>\n<li><strong>内测阶段</strong>：吸引超 1000 万用户申请，社交媒体讨论量单日破 10 万条，被评价为&quot;Agent 爆发元年的标志性产品&quot;。</li>\n</ul>\n<h3><a id=\"_61_61\"></a>{#_61}二、获取方式</h3>\n<h4><a id=\"1__631__63\"></a>{#1__63}1. 内测资格申请流程</h4>\n<h5><a id=\"11__6511__65\"></a>{#11__65}1.1 官网申请入口</h5>\n<p>访问 Manus 官方网站（https://manus.im），点击首页的 “Get Early Access”（获取早期访问权限）按钮进入申请页面。</p>\n<h5><a id=\"12__6912__69\"></a>{#12__69}1.2 填写基础信息</h5>\n<p>注册账户时需使用常用邮箱（支持谷歌、GitHub 等第三方账号快捷登录）。在申请表单中填写以下内容：</p>\n<ul>\n<li><strong>职业背景</strong>：如学生、开发者、企业职员等（影响内测权限分配）。</li>\n<li><strong>使用场景</strong>：描述计划使用 Manus 的具体任务类型（例如&quot;股票分析&quot;“旅行规划”），需尽量具体以提高审核通过率。</li>\n</ul>\n<h5><a id=\"13__7613__76\"></a>{#13__76}1.3 等待审核与通知</h5>\n<p>提交申请后，系统将通过邮件告知审核结果，通常等待时间为数小时至一周。若未收到通知，可检查垃圾邮件箱或重新提交申请。</p>\n<h4><a id=\"2__802__80\"></a>{#2__80}2. 邀请码获取渠道</h4>\n<h5><a id=\"21__8221__82\"></a>{#21__82}2.1 官方社群与活动</h5>\n<ul>\n<li><strong>Discord 群组</strong>：加入 Manus 官方 Discord 频道（链接见官网），定期参与互动可获取随机发放的邀请码。</li>\n<li><strong>推特活动</strong>：关注官方推特账号（@manusai_hq），参与转发抽奖、案例分享等活动赢取邀请码。</li>\n</ul>\n<h5><a id=\"22__8722__87\"></a>{#22__87}2.2 二手平台风险提示</h5>\n<p>部分用户通过二手平台（如闲鱼）转卖邀请码，但需警惕高价欺诈（价格高达数万元）或无效码风险。建议优先通过官方渠道申请。</p>\n<h4><a id=\"3__913__91\"></a>{#3__91}3. 登录与权限激活</h4>\n<h5><a id=\"31__9331__93\"></a>{#31__93}3.1 账户激活</h5>\n<p>收到内测资格确认邮件后，点击邮件中的激活链接设置密码，完成账户注册。</p>\n<h5><a id=\"32__9732__97\"></a>{#32__97}3.2 权限分级说明</h5>\n<ul>\n<li><strong>基础权限</strong>：支持执行简单任务（如数据分析、文件整理），每日限 3 次任务提交。</li>\n<li><strong>高级权限</strong>：需提交企业认证或开发者资质，可解锁 API 接入、批量任务处理等功能。</li>\n</ul>\n<h4><a id=\"4__1024__102\"></a>{#4__102}4. 常见问题与优化建议</h4>\n<h5><a id=\"41__10441__104\"></a>{#41__104}4.1 加速审核的技巧</h5>\n<ul>\n<li><strong>完善申请信息</strong>：详细描述需求场景（如&quot;需分析 100 份简历并生成排名报告&quot;），关联职业背景提升优先级。</li>\n<li><strong>多平台申请</strong>：同时通过官网和 Discord 提交申请，增加获取概率。</li>\n</ul>\n<h5><a id=\"42__10942__109\"></a>{#42__109}4.2 登录异常处理</h5>\n<ul>\n<li><strong>网络问题</strong>：若页面加载缓慢，可切换浏览器（推荐 Chrome 或 Edge）或使用网络加速工具。</li>\n<li><strong>账户锁定</strong>：连续输错密码需通过邮件重置，或联系客服邮箱 contact@manus.im 解锁。</li>\n</ul>\n<h4><a id=\"5__1145__114\"></a>{#5__114}5. 后续权限升级</h4>\n<h5><a id=\"51__11651__116\"></a>{#51__116}5.1 开发者计划</h5>\n<p>2025 年下半年将开放模型开源组件，开发者可申请技术文档与 API 权限，定制私有化 Agent。</p>\n<h5><a id=\"52__12052__120\"></a>{#52__120}5.2 企业级服务</h5>\n<p>企业用户可通过官网提交合作需求，获取定制化解决方案（如多账户管理、私有数据训练支持）。</p>\n<h3><a id=\"_124_124\"></a>{#_124}三、核心功能与场景</h3>\n<h4><a id=\"1__1261__126\"></a>{#1__126}1. 任务自动化执行</h4>\n<h5><a id=\"11__12811__128\"></a>{#11__128}1.1 功能实现原理</h5>\n<p>Manus 的核心能力在于将复杂任务拆解为可执行的子步骤，并自主调用工具完成全流程。其工作流程分为三个阶段：</p>\n<h6><a id=\"111__132111__132\"></a>{#111__132}1.1.1 任务分解</h6>\n<p>当用户下达指令后，Manus 会像人类专家一样分析需求，自动划分任务步骤。例如，在&quot;筛选简历&quot;任务中，它会将流程分解为&quot;解压文件→提取关键信息→生成候选人排名表→导出 Excel&quot;等环节。</p>\n<h6><a id=\"112__136112__136\"></a>{#112__136}1.1.2 工具调用</h6>\n<p>Manus 内置浏览器、代码编辑器等虚拟工具，可执行网页搜索、API 调用、数据分析等操作。例如分析股票时，它能自动连接雅虎金融 API 抓取实时数据，并调用 Python 脚本生成可视化图表。</p>\n<h6><a id=\"113__140113__140\"></a>{#113__140}1.1.3 成果交付</h6>\n<p>区别于传统 AI 仅提供建议，Manus 直接输出完整成果。例如用户上传合同文件后，它会生成包含风险条款标注、法律依据说明的审查报告，支持 Word/PDF 格式导出。</p>\n<h5><a id=\"12__14412__144\"></a>{#12__144}1.2 典型应用场景</h5>\n<h6><a id=\"121__146121__146\"></a>{#121__146}1.2.1 简历筛选</h6>\n<p>用户上传压缩包后，Manus 自动静压文件，识别简历中的工作经验、技能匹配度等关键信息，生成带候选人排名的 Excel 表格，准确率达 92%。</p>\n<h6><a id=\"122__150122__150\"></a>{#122__150}1.2.2 合同审查</h6>\n<p>可分析数十页合同文本，提取关键条款（如违约责任、付款周期），并对比法律数据库中的合规要求，标注潜在风险点。</p>\n<h6><a id=\"123__154123__154\"></a>{#123__154}1.2.3 数据分析</h6>\n<p>处理复杂数据时，Manus 能清洗原始数据、运行统计模型（如回归分析），最终生成包含趋势图、相关性矩阵的交互式仪表盘。</p>\n<h4><a id=\"2__1582__158\"></a>{#2__158}2. 多模态处理能力</h4>\n<h5><a id=\"21__16021__160\"></a>{#21__160}2.1 技术特性</h5>\n<h6><a id=\"211__162211__162\"></a>{#211__162}2.1.1 多格式解析</h6>\n<p>支持文本、音频、图像等混合输入。例如用户上传课堂录音和 PPT 截图，Manus 可自动转写为文字笔记，并提取图片中的公式生成图文版讲义。</p>\n<h6><a id=\"212__166212__166\"></a>{#212__166}2.1.2 跨模态生成</h6>\n<p>能将数据转换为多种形式输出。例如输入 Excel 销售数据，可生成带动态图表的 PPT，或创建交互式网页看板。</p>\n<h5><a id=\"22__17022__170\"></a>{#22__170}2.2 实践案例</h5>\n<h6><a id=\"221__172221__172\"></a>{#221__172}2.2.1 设计辅助</h6>\n<p>设计师输入&quot;为咖啡品牌设计极简风格名片&quot;，Manus 会搜索行业案例、调用 Canva 模板库生成设计方案，并提供 CMYK 色彩规范说明。</p>\n<h6><a id=\"222__176222__176\"></a>{#222__176}2.2.2 教育材料制作</h6>\n<p>教师上传课堂录音后，Manus 自动识别知识点片段，将其转换为带动画演示的 HTML 课件（如动量定理的受力分析动画）。</p>\n<h4><a id=\"3__1803__180\"></a>{#3__180}3. 个性化服务</h4>\n<h5><a id=\"31__18231__182\"></a>{#31__182}3.1 自适应学习机制</h5>\n<h6><a id=\"311__184311__184\"></a>{#311__184}3.1.1 偏好记忆</h6>\n<p>Manus 会记录用户的使用习惯。例如若用户常要求将报告保存为 PDF，后续任务会自动采用该格式；若偏好图表配色方案，输出时会同步调整。</p>\n<h6><a id=\"312__188312__188\"></a>{#312__188}3.1.2 动态路径优化</h6>\n<p>当任务中途收到新指令（如旅行规划中增加预算），Manus 能即时调整方案。例如原计划的经济型酒店会自动替换为高端选项，并重新计算交通成本。</p>\n<h5><a id=\"32__19232__192\"></a>{#32__192}3.2 场景化服务</h5>\n<h6><a id=\"321__194321__194\"></a>{#321__194}3.2.1 旅行规划</h6>\n<p>输入&quot;规划日本 7 日游，包含历史景点和求婚地点&quot;，Manus 会搜索樱花花期、神社开放时间，推荐适合求婚的温泉旅馆，并生成带地图导航的 HTML 手册。</p>\n<h6><a id=\"322__198322__198\"></a>{#322__198}3.2.2 房产投资</h6>\n<p>根据预算和需求（如&quot;学区房+低犯罪率&quot;），Manus 爬取房产平台数据，调用 Python 计算性价比，最终生成包含房源对比、贷款方案建议的 30 页报告。</p>\n<h4><a id=\"4__2024__202\"></a>{#4__202}4. 教育与创意支持</h4>\n<h5><a id=\"41__20441__204\"></a>{#41__204}4.1 教育赋能</h5>\n<h6><a id=\"411__206411__206\"></a>{#411__206}4.1.1 课件开发</h6>\n<p>教师输入&quot;制作牛顿定律互动课件&quot;，Manus 会编写 HTML5 动画代码，插入可拖拽的受力分析模块，并生成配套的教师指导手册。</p>\n<h6><a id=\"412__210412__210\"></a>{#412__210}4.1.2 学习助手</h6>\n<p>学生上传课程大纲后，Manus 自动整理强化学习领域的经典论文、开源代码库，并按难度分级生成学习路径图。</p>\n<h5><a id=\"42__21442__214\"></a>{#42__214}4.2 创意生产</h5>\n<h6><a id=\"421__216421__216\"></a>{#421__216}4.2.1 游戏开发</h6>\n<p>输入&quot;创建网页版《Doom》射击游戏&quot;，Manus 会编写 JavaScript 代码实现 3D 渲染、碰撞检测功能，并部署到可在线试玩的网页。</p>\n<h6><a id=\"422__220422__220\"></a>{#422__220}4.2.2 音效设计</h6>\n<p>视频创作者输入&quot;科幻飞船降落音效&quot;，Manus 会分析影视作品中的类似场景，混合合成引擎轰鸣、金属摩擦声，输出 WAV/MP3 格式文件。</p>\n<h3><a id=\"AI__224AI__224\"></a>{#AI__224}四、AI 提示词指南</h3>\n<h4><a id=\"1__Manus__2261__Manus__226\"></a>{#1__Manus__226}1. 基本原则：让 Manus 听懂你的需求</h4>\n<h5><a id=\"11__22811__228\"></a>{#11__228}1.1 明确需求：说清目标与交付形式</h5>\n<p>Manus 作为通用型 AI 智能体，核心是理解需求→拆解任务→执行交付。要让 AI 准确响应，需在提示词中明确以下要素：</p>\n<ul>\n<li><strong>目标</strong>：用一句话概括核心诉求（如&quot;分析特斯拉股票&quot;“制作物理课件”）</li>\n<li><strong>交付形式</strong>：指定输出格式（HTML、PDF、Excel 等）及内容结构（图表类型、章节划分）</li>\n<li><strong>约束条件</strong>：预算、时间、数据源等限制（示例：“预算 5000 美元”“使用 2024 年 Q1 财报数据”）</li>\n</ul>\n<p><strong>正确示例</strong>：</p>\n<p>“我需要一个 4 月 15-23 日从西雅图出发的 7 天日本行程，预算为两人 2500-5000 美元。要求包含历史遗迹、剑道体验、求婚地点建议，并生成带地图的 HTML 手册。”</p>\n<h5><a id=\"12__24012__240\"></a>{#12__240}1.2 动态调整：任务中的灵活修正</h5>\n<p>Manus 支持在任务执行过程中修改需求。例如：</p>\n<ul>\n<li>增减预算或时间范围</li>\n<li>调整输出格式（如从 PPT 改为 Markdown）</li>\n<li>补充数据源或约束条件</li>\n</ul>\n<p><strong>操作步骤</strong>：</p>\n<ol>\n<li>在 Manus 任务面板点击&quot;修改参数&quot;</li>\n<li>输入新指令（如&quot;将柱状图改为折线图&quot;）</li>\n<li>系统自动回溯相关步骤并重新执行</li>\n</ol>\n<h5><a id=\"13__25413__254\"></a>{#13__254}1.3 结果导向：以终为始设计提示词</h5>\n<p>从最终成果倒推提示词结构：</p>\n<ol>\n<li>定义输出格式：HTML/PDF/代码文件？是否需要交互功能？</li>\n<li>拆解内容模块：如股票分析需包含财务数据、技术指标、SWOT 分析</li>\n<li>预设验证标准：例如&quot;图表需标注数据来源&quot;“代码需通过 PEP8 检查”</li>\n</ol>\n<h4><a id=\"2__2622__262\"></a>{#2__262}2. 经典模板：覆盖高频场景的提示词公式</h4>\n<h5><a id=\"21__26421__264\"></a>{#21__264}2.1 数据分析类模板</h5>\n<p><strong>适用场景</strong>：股票分析、市场调研、财报解读</p>\n<p><strong>结构公式</strong>：</p>\n<blockquote>\n<p>“分析[对象]，要求包含：[模块 1]、[模块 2]、[模块 3]，数据源为[来源]，生成[格式]报告，重点展示[关键指标]。”</p>\n</blockquote>\n<p><strong>示例</strong>：</p>\n<p>“深度分析英伟达股票，包含：市场情绪、技术指标、竞品对比，调用雅虎金融 API 生成交互式网页报告，用热力图展示股价相关性。”</p>\n<h5><a id=\"22__27622__275\"></a>{#22__276}2.2 内容生成类模板</h5>\n<p><strong>适用场景</strong>：课件制作、旅行规划、营销文案</p>\n<p><strong>结构公式</strong>：</p>\n<blockquote>\n<p>“创建[主题]的[格式]内容，需包含：[要素 1]、[要素 2]、[要素 3]，风格参考[范例]，部署到[平台]。”</p>\n</blockquote>\n<p><strong>示例</strong>：</p>\n<p>“制作动量守恒定律的 HTML 演示文稿，包含弹性碰撞、非弹性碰撞、爆炸案例的交互动画，按中学教学大纲分章节，部署到公开可访问的 URL。”</p>\n<h5><a id=\"23__28823__286\"></a>{#23__288}2.3 代码开发类模板</h5>\n<p><strong>适用场景</strong>：脚本编写、网页开发、自动化工具</p>\n<p><strong>结构公式</strong>：</p>\n<blockquote>\n<p>“编写[语言]脚本实现[功能]，要求：[技术规范]，测试通过后交付[格式]，附[文档类型]说明。”</p>\n</blockquote>\n<p><strong>示例</strong>：</p>\n<p>“开发 Python 自动化脚本，每日 8 点抓取微博热搜榜存入 Google Sheets，代码需符合 PEP8 规范，交付可执行文件及 API 调用文档。”</p>\n<h4><a id=\"3__3003__297\"></a>{#3__300}3. 分步教学：从零开始构建提示词</h4>\n<h5><a id=\"31__30231__299\"></a>{#31__302}3.1 第一步：需求拆解</h5>\n<p>将复杂任务分解为 Manus 可执行的子任务：</p>\n<ol>\n<li>信息收集：指定数据来源（如&quot;爬取小红书露营装备帖子&quot;）</li>\n<li>数据处理：定义清洗规则（如&quot;剔除点赞量低于 100 的帖子&quot;）</li>\n<li>分析建模：选择算法工具（如&quot;用 PySpark 计算品牌提及率&quot;）</li>\n<li>成果交付：确定输出形式（如&quot;生成词云图+Excel 明细表&quot;）</li>\n</ol>\n<p><strong>案例</strong>：</p>\n<p>&quot;监控竞品新品动态&quot;可拆解为：</p>\n<ul>\n<li>爬取电商平台商品页</li>\n<li>提取价格/功能参数</li>\n<li>对比历史数据生成波动图表</li>\n</ul>\n<h5><a id=\"32__31932__316\"></a>{#32__319}3.2 第二步：格式规范</h5>\n<p>通过结构化描述降低歧义：</p>\n<ol>\n<li>章节划分：用数字序号或分级标题（如&quot;1.概述 2.财务分析&quot;）</li>\n<li>图表规范：指定类型/尺寸/配色（如&quot;用 2A5CAA 色系绘制面积图&quot;）</li>\n<li>交互需求：定义操作功能（如&quot;支持点击章节跳转&quot;“鼠标悬停显示数据”）</li>\n</ol>\n<p><strong>错误修正对比</strong>：</p>\n<ul>\n<li>模糊指令：&quot;做个财报分析&quot;→ 失败率高</li>\n<li>明确指令：&quot;分析特斯拉 2024 年 Q4 财报，对比小鹏/理想的毛利率趋势，生成带注释的 PDF 报告&quot;→ 成功率高</li>\n</ul>\n<h5><a id=\"33__33233__329\"></a>{#33__332}3.3 第三步：参数设置</h5>\n<p>通过预设条件控制任务走向：</p>\n<ol>\n<li>质量参数：分辨率（如&quot;图表导出为 300dpi PNG&quot;）</li>\n<li>效率参数：超时限制（如&quot;若单步骤超 30 分钟则跳过&quot;）</li>\n<li>安全参数：数据权限（如&quot;仅使用公开数据&quot;“不访问本地文件夹”）</li>\n</ol>\n<p><strong>操作界面</strong>：</p>\n<p>在 Manus 任务面板的&quot;高级设置&quot;中，可勾选：</p>\n<ul>\n<li>是否保留中间文件</li>\n<li>错误处理策略（终止/跳过/重试）</li>\n<li>资源分配优先级</li>\n</ul>\n<h4><a id=\"4__3484__345\"></a>{#4__348}4. 常见错误与修正方案</h4>\n<h5><a id=\"41__1_35041__1_347\"></a>{#41__1_350}4.1 错误类型 1：指令模糊</h5>\n<p><strong>表现</strong>：Manus 反复请求确认细节</p>\n<p><strong>修正方案</strong>：</p>\n<ul>\n<li>补充场景信息（如&quot;中学物理教学&quot;而非&quot;教学&quot;）</li>\n<li>添加参照物（如&quot;按小米发布会风格设计 PPT&quot;）</li>\n</ul>\n<h5><a id=\"42__2_35942__2_356\"></a>{#42__2_359}4.2 错误类型 2：忽略格式规范</h5>\n<p><strong>表现</strong>：输出文件排版混乱</p>\n<p><strong>修正方案</strong>：</p>\n<ul>\n<li>提前定义模板（上传参考文件或指定官方模板库编号）</li>\n<li>要求分步确认（如&quot;先提交大纲审核再生成内容&quot;）</li>\n</ul>\n<h5><a id=\"43__3_36843__3_365\"></a>{#43__3_368}4.3 错误类型 3：缺乏反馈机制</h5>\n<p><strong>表现</strong>：多次生成仍不符合预期</p>\n<p><strong>修正方案</strong>：</p>\n<ul>\n<li>使用迭代指令（如&quot;基于 v1.0 报告，将第三章改为雷达图&quot;）</li>\n<li>启用人工干预模式（手动修改中间文件后继续任务）</li>\n</ul>\n<h4><a id=\"5__Manus__3775__Manus__374\"></a>{#5__Manus__377}5. 进阶技巧：释放 Manus 全部潜力</h4>\n<h5><a id=\"51__37951__376\"></a>{#51__379}5.1 创建可复用的工作流模板</h5>\n<p>将常用任务保存为模板：</p>\n<ol>\n<li>在历史任务列表右键选择&quot;保存为模板&quot;</li>\n<li>定义变量占位符（如{{公司名称}}、{{时间范围}}）</li>\n<li>下次使用时直接替换变量一键执行</li>\n</ol>\n<h5><a id=\"52__38752__384\"></a>{#52__387}5.2 多任务协同作战</h5>\n<p>在&quot;任务看板&quot;中并行处理：</p>\n<ul>\n<li>数据依赖型任务：A 任务输出作为 B 任务输入（如爬虫→分析）</li>\n<li>资源隔离型任务：敏感数据在本地沙盒运行，公开数据调用云端算力</li>\n</ul>\n<h5><a id=\"53__39453__391\"></a>{#53__394}5.3 通过反馈训练专属助手</h5>\n<p>在用户偏好设置中：</p>\n<ol>\n<li>定义术语库（如公司内部缩写对照表）</li>\n<li>设置默认工具链（数据分析用 PySpark 而非 Pandas）</li>\n<li>保存格式偏好（PPT 字体、图表配色方案）</li>\n</ol>\n<h5><a id=\"54__40254__399\"></a>{#54__402}5.4 混合执行策略</h5>\n<p>根据任务特性选择执行方式：</p>\n<ul>\n<li>本地执行：处理敏感数据（如合同扫描）</li>\n<li>云端执行：需要 GPU 加速的任务（如 3D 渲染）</li>\n<li>混合执行：先本地清洗数据，再云端建模分析</li>\n</ul>\n<h3><a id=\"_410_407\"></a>{#_410}五、实操案例解析</h3>\n<h4><a id=\"_412_409\"></a>{#_412}案例一：简历筛选</h4>\n<h5><a id=\"11__41411__411\"></a>{#11__414}1.1 任务输入与目标</h5>\n<p>用户需要为&quot;强化学习算法工程师&quot;岗位筛选 15 份简历，并按候选人的专业知识水平进行排序。具体要求包括：</p>\n<ul>\n<li>上传包含 10 份简历的 ZIP 压缩包，随后补充上传 5 份简历</li>\n<li>提取候选人项目经验、技能匹配度等关键信息</li>\n<li>输出 Excel 格式的候选人排名表</li>\n</ul>\n<h5><a id=\"12_Manus__42212_Manus__419\"></a>{#12_Manus__422}1.2 Manus 处理过程</h5>\n<h6><a id=\"121__424121__421\"></a>{#121__424}1.2.1 文件自动化处理</h6>\n<p>Manus 首先自动解压 ZIP 文件，逐份浏览 PDF 或 Word 格式的简历。对于用户后续补充上传的 5 份简历，系统异步接收并整合至任务队列，无需用户重复操作。</p>\n<h6><a id=\"122__428122__425\"></a>{#122__428}1.2.2 智能分析与评估</h6>\n<p>系统采用以下评估维度：</p>\n<ol>\n<li>专业匹配度：识别简历中与强化学习相关的关键词（如 Q-learning、PPO 算法）</li>\n<li>项目经验权重：根据项目复杂度、成果量化指标（如算法准确率提升百分比）打分</li>\n<li>技能完整性：检测是否具备关联技术栈（Python、PyTorch、ROS 机器人平台）</li>\n</ol>\n<h6><a id=\"123__436123__433\"></a>{#123__436}1.2.3 动态调整输出格式</h6>\n<p>当用户临时要求将结果转为 Excel 表格时，Manus 自动执行以下操作：</p>\n<ol>\n<li>调用 Python 的 pandas 库创建数据框架</li>\n<li>按&quot;高级候选人&quot;“基础经验者”&quot;不匹配&quot;三级分类生成工作表</li>\n<li>添加超链接直达候选人联系方式与作品集</li>\n</ol>\n<h5><a id=\"13__44413__441\"></a>{#13__444}1.3 成果交付示例</h5>\n<p>最终生成的 Excel 文件包含：</p>\n<ul>\n<li>主表：按综合评分排序的候选人列表</li>\n<li>附录：各评估维度的权重说明</li>\n<li>可视化图表：候选人技能雷达图（自动嵌入 SVG 格式）</li>\n</ul>\n<h4><a id=\"_452_449\"></a>{#_452}案例二：股票相关性分析</h4>\n<h5><a id=\"21__45421__451\"></a>{#21__454}2.1 任务输入与目标</h5>\n<p>用户要求分析英伟达（NVDA）、迈威尔科技（MRVL）、台积电（TSM）三家公司过去三年的股票价格相关性，并生成交互式可视化报告。具体需求包括：</p>\n<ul>\n<li>获取 2019 年 1 月-2022 年 1 月历史数据</li>\n<li>计算皮尔逊相关系数与滚动相关性</li>\n<li>部署可在线访问的数据仪表盘</li>\n</ul>\n<h5><a id=\"22_Manus__46222_Manus__459\"></a>{#22_Manus__462}2.2 Manus 处理流程</h5>\n<h6><a id=\"221__464221__461\"></a>{#221__464}2.2.1 多源数据获取</h6>\n<p>系统通过以下途径收集数据：</p>\n<ol>\n<li>官方 API 调用：接入 Yahoo Finance 获取日线级收盘价</li>\n<li>数据清洗：自动修复缺失值（如节假日休市数据）</li>\n<li>交叉验证：对比 SEC 公开财报中的流通股数量</li>\n</ol>\n<h6><a id=\"222__472222__469\"></a>{#222__472}2.2.2 统计分析实施</h6>\n<p>Manus 分阶段执行代码：</p>\n<ol>\n<li>基础计算</li>\n</ol>\n<pre><code class=\"lang-prism\"># 计算皮尔逊相关系数\ncorrelation_matrix = df[[\'NVDA\',\'MRVL\',\'TSM\']].corr(method=\'pearson\')\n</code></pre>\n<ol start=\"2\">\n<li>进阶分析</li>\n</ol>\n<ul>\n<li>生成 30 日滚动相关性曲线</li>\n<li>绘制波动率对比热力图</li>\n</ul>\n<h6><a id=\"223__485223__485\"></a>{#223__485}2.2.3 交互式可视化开发</h6>\n<p>系统使用以下技术栈构建仪表盘：</p>\n<ul>\n<li>前端框架：Vue.js + ECharts 实现动态图表</li>\n<li>后端服务：FastAPI 提供数据接口</li>\n<li>部署方案：自动生成二级域名（如<code>https://stock.manus.space</code>）</li>\n</ul>\n<h5><a id=\"23__49323__493\"></a>{#23__493}2.3 成果展示特点</h5>\n<p>最终报告包含：</p>\n<ul>\n<li>时间序列图：叠加显示三只股票价格走势</li>\n<li>相关性矩阵：点击单元格可查看历史相关性变化动画</li>\n<li>投资建议模块：基于波动率提出对冲策略</li>\n</ul>\n<h4><a id=\"_501_501\"></a>{#_501}案例三：物理教学课件制作</h4>\n<h5><a id=\"31__50331__503\"></a>{#31__503}3.1 任务输入与目标</h5>\n<p>中学物理教师需要制作《动量守恒定律》的交互式教学课件，具体要求：</p>\n<ul>\n<li>包含弹性碰撞、非弹性碰撞等场景的动画演示</li>\n<li>支持课堂实时参数调整（如小球质量、初速度）</li>\n<li>输出 HTML 文件便于投影仪直接播放</li>\n</ul>\n<h5><a id=\"32_Manus__51132_Manus__511\"></a>{#32_Manus__511}3.2 Manus 开发过程</h5>\n<h6><a id=\"321__513321__513\"></a>{#321__513}3.2.1 教学内容规划</h6>\n<p>系统自动生成教学大纲：</p>\n<ol>\n<li>基础概念：动量公式<code>p=mv</code>的矢量特性演示</li>\n<li>实验模拟：\n<ul>\n<li>完全弹性碰撞（能量守恒）</li>\n<li>完全非弹性碰撞（最大动能损失）</li>\n</ul>\n</li>\n<li>现实应用：汽车碰撞测试的动量变化分析</li>\n</ol>\n<h6><a id=\"322__523322__523\"></a>{#322__523}3.2.2 交互动画开发</h6>\n<p>Manus 采用以下技术实现：</p>\n<ul>\n<li>动画引擎：基于 Canvas 的物理引擎模拟碰撞效果</li>\n<li>参数控制面板：</li>\n</ul>\n<pre><code class=\"lang-prism\">&lt;input type=&quot;range&quot; id=&quot;mass1&quot; min=&quot;1&quot; max=&quot;10&quot; value=&quot;4&quot;&gt;\n&lt;label for=&quot;mass1&quot;&gt;小球质量(kg)&lt;/label&gt;\n</code></pre>\n<ul>\n<li>即时计算反馈：</li>\n</ul>\n<pre><code class=\"lang-prism\">// 实时显示动量总和\ndocument.getElementById(\'momentum\').innerHTML = m1v1 + m2v2;\n</code></pre>\n<h6><a id=\"323__539323__542\"></a>{#323__539}3.2.3 教学资源整合</h6>\n<p>系统自动补充：</p>\n<ul>\n<li>扩展阅读：链接至维基百科相关词条</li>\n<li>课堂习题：随机生成数值不同的练习题</li>\n<li>教师手册：Markdown 格式的教学建议文档</li>\n</ul>\n<h5><a id=\"33__54733__550\"></a>{#33__547}3.3 教学应用效果</h5>\n<p>最终课件支持：</p>\n<ul>\n<li>动态重置：一键恢复初始参数</li>\n<li>分步演示：分解碰撞过程的帧动画</li>\n<li>数据导出：将模拟结果保存为 CSV 供课后分析</li>\n</ul>\n<h4><a id=\"_555_558\"></a>{#_555}案例共性特征总结</h4>\n<ol>\n<li><strong>端到端自动化</strong>：从原始数据到交付成果全程无需人工干预</li>\n<li><strong>多工具协同</strong>：融合 API 调用、代码编写、可视化开发等能力</li>\n<li><strong>可扩展性</strong>：所有输出文件保留完整源码，支持二次修改</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\">\n</code></div></pre>\n', ' Manus 实操手册  \n--------------------------------------\n\n###  一、Manus 概述\n\n#### {#11__5}1.1 官网入口\n\nManus 的官方网站为 https://manus.im，用户可通过浏览器直接访问。该网站是产品的主要信息发布渠道，提供功能演示、案例库、内测申请入口等核心服务。官网设计简洁，首页展示产品定位、核心功能模块及用户评价，适合零基础用户快速了解产品价值。\n\n#### {#12__9}1.2 产品定位\n\n##### {#121__11}1.2.1 定义与目标\n\nManus 是全球首款通用型 AI 智能体（Agent），由中国 Monica 团队研发。其核心目标是\"将用户的想法转化为具体成果\"，通过自主规划、调用工具和交付完整任务成果，帮助用户高效完成复杂任务。与普通聊天机器人不同，Manus 能够独立执行端到端任务，例如从数据收集、分析到生成可视化报告的全流程操作。\n\n##### {#122__15}1.2.2 核心特点\n\n* **通用性**：支持跨领域任务，涵盖金融分析、旅行规划、教育课件制作等 51 个场景。\n* **自主性**：无需用户分步指导，可自动分解任务、调用工具（如代码编辑器、浏览器）并优化执行路径。\n* **交付能力**：直接生成可视化成果（如 PDF、Excel、网页），而非仅提供文字建议。\n\n##### {#123__21}1.2.3 技术架构\n\nManus 采用多智能体系统（Multiple Agent System）与云端虚拟机技术：\n\n* **规划层**：分析用户需求，拆解任务步骤（如\"分析股票\"拆解为数据抓取、趋势建模、报告生成）。\n* **执行层**：调用虚拟环境中的工具（代码执行、网页浏览、文件处理）。\n* **验证层**：检查结果准确性，动态修正错误。\n\n#### {#13__29}1.3 团队背景\n\n##### {#131_Red_31}1.3.1 创始人：肖弘（Red）\n\n* **履历**：连续创业者，华中科技大学软件工程专业毕业。曾开发微信公众号增强工具\"莺件\"和企业微信应用\"微伴助手\"，获腾讯投资。\n* **理念**：主张\"AI 应成为生产力伙伴\"，推动 Manus 从工具型助手进化为自主代理。\n\n##### {#132_Peak_36}1.3.2 首席科学家：季逸超（Peak）\n\n* **成就**：主导开发中文互联网最大通用知识图谱系统 Magi，曾推出 iOS 浏览器\"猛犸\"并获 MacWorld 特等奖。\n* **技术贡献**：为 Manus 设计基于 LLM 的操作系统架构，实现多模态数据处理与跨平台工具调用。\n\n##### {#133__41}1.3.3 技术团队\n\n* **规模**：Monica 团队成立于 2023 年，现有成员 51-200 人，专注 AI 推理与工程化落地。\n* **里程碑**：2022 年立项 Monica 项目（早于 ChatGPT 发布），2025 年推出 Manus，在 GAIA 基准测试中超越 OpenAI 同类产品。\n\n#### {#14__46}1.4 产品发展历程\n\n##### {#141__48}1.4.1 早期探索\n\n* **2022 年**：Monica 项目立项，以浏览器插件形式提供 AI 助手服务，集成多模型 API 并主打海外市场。\n* **2024 年**：用户突破百万，成为海外 AI 插件领域头部产品，验证工具调用与任务自动化能力。\n\n##### {#142__53}1.4.2 技术突破\n\n* **2025 年**：发布 Manus，整合动态任务调度引擎、神经记忆网络等创新技术，实现从\"辅助工具\"到\"自主代理\"的跨越。\n\n##### {#143__57}1.4.3 市场反响\n\n* **内测阶段**：吸引超 1000 万用户申请，社交媒体讨论量单日破 10 万条，被评价为\"Agent 爆发元年的标志性产品\"。\n\n### {#_61}二、获取方式\n\n#### {#1__63}1. 内测资格申请流程\n\n##### {#11__65}1.1 官网申请入口\n\n访问 Manus 官方网站（https://manus.im），点击首页的 \"Get Early Access\"（获取早期访问权限）按钮进入申请页面。\n\n##### {#12__69}1.2 填写基础信息\n\n注册账户时需使用常用邮箱（支持谷歌、GitHub 等第三方账号快捷登录）。在申请表单中填写以下内容：\n\n* **职业背景**：如学生、开发者、企业职员等（影响内测权限分配）。\n* **使用场景**：描述计划使用 Manus 的具体任务类型（例如\"股票分析\"\"旅行规划\"），需尽量具体以提高审核通过率。\n\n##### {#13__76}1.3 等待审核与通知\n\n提交申请后，系统将通过邮件告知审核结果，通常等待时间为数小时至一周。若未收到通知，可检查垃圾邮件箱或重新提交申请。\n\n#### {#2__80}2. 邀请码获取渠道\n\n##### {#21__82}2.1 官方社群与活动\n\n* **Discord 群组**：加入 Manus 官方 Discord 频道（链接见官网），定期参与互动可获取随机发放的邀请码。\n* **推特活动**：关注官方推特账号（@manusai_hq），参与转发抽奖、案例分享等活动赢取邀请码。\n\n##### {#22__87}2.2 二手平台风险提示\n\n部分用户通过二手平台（如闲鱼）转卖邀请码，但需警惕高价欺诈（价格高达数万元）或无效码风险。建议优先通过官方渠道申请。\n\n#### {#3__91}3. 登录与权限激活\n\n##### {#31__93}3.1 账户激活\n\n收到内测资格确认邮件后，点击邮件中的激活链接设置密码，完成账户注册。\n\n##### {#32__97}3.2 权限分级说明\n\n* **基础权限**：支持执行简单任务（如数据分析、文件整理），每日限 3 次任务提交。\n* **高级权限**：需提交企业认证或开发者资质，可解锁 API 接入、批量任务处理等功能。\n\n#### {#4__102}4. 常见问题与优化建议\n\n##### {#41__104}4.1 加速审核的技巧\n\n* **完善申请信息**：详细描述需求场景（如\"需分析 100 份简历并生成排名报告\"），关联职业背景提升优先级。\n* **多平台申请**：同时通过官网和 Discord 提交申请，增加获取概率。\n\n##### {#42__109}4.2 登录异常处理\n\n* **网络问题**：若页面加载缓慢，可切换浏览器（推荐 Chrome 或 Edge）或使用网络加速工具。\n* **账户锁定**：连续输错密码需通过邮件重置，或联系客服邮箱 contact@manus.im 解锁。\n\n#### {#5__114}5. 后续权限升级\n\n##### {#51__116}5.1 开发者计划\n\n2025 年下半年将开放模型开源组件，开发者可申请技术文档与 API 权限，定制私有化 Agent。\n\n##### {#52__120}5.2 企业级服务\n\n企业用户可通过官网提交合作需求，获取定制化解决方案（如多账户管理、私有数据训练支持）。\n\n### {#_124}三、核心功能与场景\n\n#### {#1__126}1. 任务自动化执行\n\n##### {#11__128}1.1 功能实现原理\n\nManus 的核心能力在于将复杂任务拆解为可执行的子步骤，并自主调用工具完成全流程。其工作流程分为三个阶段：\n\n###### {#111__132}1.1.1 任务分解\n\n当用户下达指令后，Manus 会像人类专家一样分析需求，自动划分任务步骤。例如，在\"筛选简历\"任务中，它会将流程分解为\"解压文件→提取关键信息→生成候选人排名表→导出 Excel\"等环节。\n\n###### {#112__136}1.1.2 工具调用\n\nManus 内置浏览器、代码编辑器等虚拟工具，可执行网页搜索、API 调用、数据分析等操作。例如分析股票时，它能自动连接雅虎金融 API 抓取实时数据，并调用 Python 脚本生成可视化图表。\n\n###### {#113__140}1.1.3 成果交付\n\n区别于传统 AI 仅提供建议，Manus 直接输出完整成果。例如用户上传合同文件后，它会生成包含风险条款标注、法律依据说明的审查报告，支持 Word/PDF 格式导出。\n\n##### {#12__144}1.2 典型应用场景\n\n###### {#121__146}1.2.1 简历筛选\n\n用户上传压缩包后，Manus 自动静压文件，识别简历中的工作经验、技能匹配度等关键信息，生成带候选人排名的 Excel 表格，准确率达 92%。\n\n###### {#122__150}1.2.2 合同审查\n\n可分析数十页合同文本，提取关键条款（如违约责任、付款周期），并对比法律数据库中的合规要求，标注潜在风险点。\n\n###### {#123__154}1.2.3 数据分析\n\n处理复杂数据时，Manus 能清洗原始数据、运行统计模型（如回归分析），最终生成包含趋势图、相关性矩阵的交互式仪表盘。\n\n#### {#2__158}2. 多模态处理能力\n\n##### {#21__160}2.1 技术特性\n\n###### {#211__162}2.1.1 多格式解析\n\n支持文本、音频、图像等混合输入。例如用户上传课堂录音和 PPT 截图，Manus 可自动转写为文字笔记，并提取图片中的公式生成图文版讲义。\n\n###### {#212__166}2.1.2 跨模态生成\n\n能将数据转换为多种形式输出。例如输入 Excel 销售数据，可生成带动态图表的 PPT，或创建交互式网页看板。\n\n##### {#22__170}2.2 实践案例\n\n###### {#221__172}2.2.1 设计辅助\n\n设计师输入\"为咖啡品牌设计极简风格名片\"，Manus 会搜索行业案例、调用 Canva 模板库生成设计方案，并提供 CMYK 色彩规范说明。\n\n###### {#222__176}2.2.2 教育材料制作\n\n教师上传课堂录音后，Manus 自动识别知识点片段，将其转换为带动画演示的 HTML 课件（如动量定理的受力分析动画）。\n\n#### {#3__180}3. 个性化服务\n\n##### {#31__182}3.1 自适应学习机制\n\n###### {#311__184}3.1.1 偏好记忆\n\nManus 会记录用户的使用习惯。例如若用户常要求将报告保存为 PDF，后续任务会自动采用该格式；若偏好图表配色方案，输出时会同步调整。\n\n###### {#312__188}3.1.2 动态路径优化\n\n当任务中途收到新指令（如旅行规划中增加预算），Manus 能即时调整方案。例如原计划的经济型酒店会自动替换为高端选项，并重新计算交通成本。\n\n##### {#32__192}3.2 场景化服务\n\n###### {#321__194}3.2.1 旅行规划\n\n输入\"规划日本 7 日游，包含历史景点和求婚地点\"，Manus 会搜索樱花花期、神社开放时间，推荐适合求婚的温泉旅馆，并生成带地图导航的 HTML 手册。\n\n###### {#322__198}3.2.2 房产投资\n\n根据预算和需求（如\"学区房+低犯罪率\"），Manus 爬取房产平台数据，调用 Python 计算性价比，最终生成包含房源对比、贷款方案建议的 30 页报告。\n\n#### {#4__202}4. 教育与创意支持\n\n##### {#41__204}4.1 教育赋能\n\n###### {#411__206}4.1.1 课件开发\n\n教师输入\"制作牛顿定律互动课件\"，Manus 会编写 HTML5 动画代码，插入可拖拽的受力分析模块，并生成配套的教师指导手册。\n\n###### {#412__210}4.1.2 学习助手\n\n学生上传课程大纲后，Manus 自动整理强化学习领域的经典论文、开源代码库，并按难度分级生成学习路径图。\n\n##### {#42__214}4.2 创意生产\n\n###### {#421__216}4.2.1 游戏开发\n\n输入\"创建网页版《Doom》射击游戏\"，Manus 会编写 JavaScript 代码实现 3D 渲染、碰撞检测功能，并部署到可在线试玩的网页。\n\n###### {#422__220}4.2.2 音效设计\n\n视频创作者输入\"科幻飞船降落音效\"，Manus 会分析影视作品中的类似场景，混合合成引擎轰鸣、金属摩擦声，输出 WAV/MP3 格式文件。\n\n### {#AI__224}四、AI 提示词指南\n\n#### {#1__Manus__226}1. 基本原则：让 Manus 听懂你的需求\n\n##### {#11__228}1.1 明确需求：说清目标与交付形式\n\nManus 作为通用型 AI 智能体，核心是理解需求→拆解任务→执行交付。要让 AI 准确响应，需在提示词中明确以下要素：\n\n* **目标**：用一句话概括核心诉求（如\"分析特斯拉股票\"\"制作物理课件\"）\n* **交付形式**：指定输出格式（HTML、PDF、Excel 等）及内容结构（图表类型、章节划分）\n* **约束条件**：预算、时间、数据源等限制（示例：\"预算 5000 美元\"\"使用 2024 年 Q1 财报数据\"）\n\n**正确示例**：\n\n\"我需要一个 4 月 15-23 日从西雅图出发的 7 天日本行程，预算为两人 2500-5000 美元。要求包含历史遗迹、剑道体验、求婚地点建议，并生成带地图的 HTML 手册。\"\n\n##### {#12__240}1.2 动态调整：任务中的灵活修正\n\nManus 支持在任务执行过程中修改需求。例如：\n\n* 增减预算或时间范围\n* 调整输出格式（如从 PPT 改为 Markdown）\n* 补充数据源或约束条件\n\n**操作步骤**：\n\n1. 在 Manus 任务面板点击\"修改参数\"\n2. 输入新指令（如\"将柱状图改为折线图\"）\n3. 系统自动回溯相关步骤并重新执行\n\n##### {#13__254}1.3 结果导向：以终为始设计提示词\n\n从最终成果倒推提示词结构：\n\n1. 定义输出格式：HTML/PDF/代码文件？是否需要交互功能？\n2. 拆解内容模块：如股票分析需包含财务数据、技术指标、SWOT 分析\n3. 预设验证标准：例如\"图表需标注数据来源\"\"代码需通过 PEP8 检查\"\n\n#### {#2__262}2. 经典模板：覆盖高频场景的提示词公式\n\n##### {#21__264}2.1 数据分析类模板\n\n**适用场景**：股票分析、市场调研、财报解读\n\n**结构公式**：\n> \"分析\\[对象\\]，要求包含：\\[模块 1\\]、\\[模块 2\\]、\\[模块 3\\]，数据源为\\[来源\\]，生成\\[格式\\]报告，重点展示\\[关键指标\\]。\"\n\n**示例**：\n\n\"深度分析英伟达股票，包含：市场情绪、技术指标、竞品对比，调用雅虎金融 API 生成交互式网页报告，用热力图展示股价相关性。\"\n\n##### {#22__276}2.2 内容生成类模板\n\n**适用场景**：课件制作、旅行规划、营销文案\n\n**结构公式**：\n> \"创建\\[主题\\]的\\[格式\\]内容，需包含：\\[要素 1\\]、\\[要素 2\\]、\\[要素 3\\]，风格参考\\[范例\\]，部署到\\[平台\\]。\"\n\n**示例**：\n\n\"制作动量守恒定律的 HTML 演示文稿，包含弹性碰撞、非弹性碰撞、爆炸案例的交互动画，按中学教学大纲分章节，部署到公开可访问的 URL。\"\n\n##### {#23__288}2.3 代码开发类模板\n\n**适用场景**：脚本编写、网页开发、自动化工具\n\n**结构公式**：\n> \"编写\\[语言\\]脚本实现\\[功能\\]，要求：\\[技术规范\\]，测试通过后交付\\[格式\\]，附\\[文档类型\\]说明。\"\n\n**示例**：\n\n\"开发 Python 自动化脚本，每日 8 点抓取微博热搜榜存入 Google Sheets，代码需符合 PEP8 规范，交付可执行文件及 API 调用文档。\"\n\n#### {#3__300}3. 分步教学：从零开始构建提示词\n\n##### {#31__302}3.1 第一步：需求拆解\n\n将复杂任务分解为 Manus 可执行的子任务：\n\n1. 信息收集：指定数据来源（如\"爬取小红书露营装备帖子\"）\n2. 数据处理：定义清洗规则（如\"剔除点赞量低于 100 的帖子\"）\n3. 分析建模：选择算法工具（如\"用 PySpark 计算品牌提及率\"）\n4. 成果交付：确定输出形式（如\"生成词云图+Excel 明细表\"）\n\n**案例**：\n\n\"监控竞品新品动态\"可拆解为：\n\n* 爬取电商平台商品页\n* 提取价格/功能参数\n* 对比历史数据生成波动图表\n\n##### {#32__319}3.2 第二步：格式规范\n\n通过结构化描述降低歧义：\n\n1. 章节划分：用数字序号或分级标题（如\"1.概述 2.财务分析\"）\n2. 图表规范：指定类型/尺寸/配色（如\"用 2A5CAA 色系绘制面积图\"）\n3. 交互需求：定义操作功能（如\"支持点击章节跳转\"\"鼠标悬停显示数据\"）\n\n**错误修正对比**：\n\n* 模糊指令：\"做个财报分析\"→ 失败率高\n* 明确指令：\"分析特斯拉 2024 年 Q4 财报，对比小鹏/理想的毛利率趋势，生成带注释的 PDF 报告\"→ 成功率高\n\n##### {#33__332}3.3 第三步：参数设置\n\n通过预设条件控制任务走向：\n\n1. 质量参数：分辨率（如\"图表导出为 300dpi PNG\"）\n2. 效率参数：超时限制（如\"若单步骤超 30 分钟则跳过\"）\n3. 安全参数：数据权限（如\"仅使用公开数据\"\"不访问本地文件夹\"）\n\n**操作界面**：\n\n在 Manus 任务面板的\"高级设置\"中，可勾选：\n\n* 是否保留中间文件\n* 错误处理策略（终止/跳过/重试）\n* 资源分配优先级\n\n#### {#4__348}4. 常见错误与修正方案\n\n##### {#41__1_350}4.1 错误类型 1：指令模糊\n\n**表现**：Manus 反复请求确认细节\n\n**修正方案**：\n\n* 补充场景信息（如\"中学物理教学\"而非\"教学\"）\n* 添加参照物（如\"按小米发布会风格设计 PPT\"）\n\n##### {#42__2_359}4.2 错误类型 2：忽略格式规范\n\n**表现**：输出文件排版混乱\n\n**修正方案**：\n\n* 提前定义模板（上传参考文件或指定官方模板库编号）\n* 要求分步确认（如\"先提交大纲审核再生成内容\"）\n\n##### {#43__3_368}4.3 错误类型 3：缺乏反馈机制\n\n**表现**：多次生成仍不符合预期\n\n**修正方案**：\n\n* 使用迭代指令（如\"基于 v1.0 报告，将第三章改为雷达图\"）\n* 启用人工干预模式（手动修改中间文件后继续任务）\n\n#### {#5__Manus__377}5. 进阶技巧：释放 Manus 全部潜力\n\n##### {#51__379}5.1 创建可复用的工作流模板\n\n将常用任务保存为模板：\n\n1. 在历史任务列表右键选择\"保存为模板\"\n2. 定义变量占位符（如{{公司名称}}、{{时间范围}}）\n3. 下次使用时直接替换变量一键执行\n\n##### {#52__387}5.2 多任务协同作战\n\n在\"任务看板\"中并行处理：\n\n* 数据依赖型任务：A 任务输出作为 B 任务输入（如爬虫→分析）\n* 资源隔离型任务：敏感数据在本地沙盒运行，公开数据调用云端算力\n\n##### {#53__394}5.3 通过反馈训练专属助手\n\n在用户偏好设置中：\n\n1. 定义术语库（如公司内部缩写对照表）\n2. 设置默认工具链（数据分析用 PySpark 而非 Pandas）\n3. 保存格式偏好（PPT 字体、图表配色方案）\n\n##### {#54__402}5.4 混合执行策略\n\n根据任务特性选择执行方式：\n\n* 本地执行：处理敏感数据（如合同扫描）\n* 云端执行：需要 GPU 加速的任务（如 3D 渲染）\n* 混合执行：先本地清洗数据，再云端建模分析\n\n### {#_410}五、实操案例解析\n\n#### {#_412}案例一：简历筛选\n\n##### {#11__414}1.1 任务输入与目标\n\n用户需要为\"强化学习算法工程师\"岗位筛选 15 份简历，并按候选人的专业知识水平进行排序。具体要求包括：\n\n* 上传包含 10 份简历的 ZIP 压缩包，随后补充上传 5 份简历\n* 提取候选人项目经验、技能匹配度等关键信息\n* 输出 Excel 格式的候选人排名表\n\n##### {#12_Manus__422}1.2 Manus 处理过程\n\n###### {#121__424}1.2.1 文件自动化处理\n\nManus 首先自动解压 ZIP 文件，逐份浏览 PDF 或 Word 格式的简历。对于用户后续补充上传的 5 份简历，系统异步接收并整合至任务队列，无需用户重复操作。\n\n###### {#122__428}1.2.2 智能分析与评估\n\n系统采用以下评估维度：\n\n1. 专业匹配度：识别简历中与强化学习相关的关键词（如 Q-learning、PPO 算法）\n2. 项目经验权重：根据项目复杂度、成果量化指标（如算法准确率提升百分比）打分\n3. 技能完整性：检测是否具备关联技术栈（Python、PyTorch、ROS 机器人平台）\n\n###### {#123__436}1.2.3 动态调整输出格式\n\n当用户临时要求将结果转为 Excel 表格时，Manus 自动执行以下操作：\n\n1. 调用 Python 的 pandas 库创建数据框架\n2. 按\"高级候选人\"\"基础经验者\"\"不匹配\"三级分类生成工作表\n3. 添加超链接直达候选人联系方式与作品集\n\n##### {#13__444}1.3 成果交付示例\n\n最终生成的 Excel 文件包含：\n\n* 主表：按综合评分排序的候选人列表\n* 附录：各评估维度的权重说明\n* 可视化图表：候选人技能雷达图（自动嵌入 SVG 格式）\n\n#### {#_452}案例二：股票相关性分析\n\n##### {#21__454}2.1 任务输入与目标\n\n用户要求分析英伟达（NVDA）、迈威尔科技（MRVL）、台积电（TSM）三家公司过去三年的股票价格相关性，并生成交互式可视化报告。具体需求包括：\n\n* 获取 2019 年 1 月-2022 年 1 月历史数据\n* 计算皮尔逊相关系数与滚动相关性\n* 部署可在线访问的数据仪表盘\n\n##### {#22_Manus__462}2.2 Manus 处理流程\n\n###### {#221__464}2.2.1 多源数据获取\n\n系统通过以下途径收集数据：\n\n1. 官方 API 调用：接入 Yahoo Finance 获取日线级收盘价\n2. 数据清洗：自动修复缺失值（如节假日休市数据）\n3. 交叉验证：对比 SEC 公开财报中的流通股数量\n\n###### {#222__472}2.2.2 统计分析实施\n\nManus 分阶段执行代码：\n\n1. 基础计算\n\n```prism language-python\n# 计算皮尔逊相关系数\ncorrelation_matrix = df[[\'NVDA\',\'MRVL\',\'TSM\']].corr(method=\'pearson\')\n```\n\n2. 进阶分析\n\n* 生成 30 日滚动相关性曲线\n* 绘制波动率对比热力图\n\n###### {#223__485}2.2.3 交互式可视化开发\n\n系统使用以下技术栈构建仪表盘：\n\n* 前端框架：Vue.js + ECharts 实现动态图表\n* 后端服务：FastAPI 提供数据接口\n* 部署方案：自动生成二级域名（如`https://stock.manus.space`）\n\n##### {#23__493}2.3 成果展示特点\n\n最终报告包含：\n\n* 时间序列图：叠加显示三只股票价格走势\n* 相关性矩阵：点击单元格可查看历史相关性变化动画\n* 投资建议模块：基于波动率提出对冲策略\n\n#### {#_501}案例三：物理教学课件制作\n\n##### {#31__503}3.1 任务输入与目标\n\n中学物理教师需要制作《动量守恒定律》的交互式教学课件，具体要求：\n\n* 包含弹性碰撞、非弹性碰撞等场景的动画演示\n* 支持课堂实时参数调整（如小球质量、初速度）\n* 输出 HTML 文件便于投影仪直接播放\n\n##### {#32_Manus__511}3.2 Manus 开发过程\n\n###### {#321__513}3.2.1 教学内容规划\n\n系统自动生成教学大纲：\n\n1. 基础概念：动量公式`p=mv`的矢量特性演示\n2. 实验模拟：\n   * 完全弹性碰撞（能量守恒）\n   * 完全非弹性碰撞（最大动能损失）\n3. 现实应用：汽车碰撞测试的动量变化分析\n\n###### {#322__523}3.2.2 交互动画开发\n\nManus 采用以下技术实现：\n\n* 动画引擎：基于 Canvas 的物理引擎模拟碰撞效果\n* 参数控制面板：\n\n```prism language-html\n<input type=\"range\" id=\"mass1\" min=\"1\" max=\"10\" value=\"4\">\n<label for=\"mass1\">小球质量(kg)</label>\n```\n\n* 即时计算反馈：\n\n```prism language-javascript\n// 实时显示动量总和\ndocument.getElementById(\'momentum\').innerHTML = m1v1 + m2v2;\n```\n\n###### {#323__539}3.2.3 教学资源整合\n\n系统自动补充：\n\n* 扩展阅读：链接至维基百科相关词条\n* 课堂习题：随机生成数值不同的练习题\n* 教师手册：Markdown 格式的教学建议文档\n\n##### {#33__547}3.3 教学应用效果\n\n最终课件支持：\n\n* 动态重置：一键恢复初始参数\n* 分步演示：分解碰撞过程的帧动画\n* 数据导出：将模拟结果保存为 CSV 供课后分析\n\n#### {#_555}案例共性特征总结\n\n1. **端到端自动化**：从原始数据到交付成果全程无需人工干预\n2. **多工具协同**：融合 API 调用、代码编写、可视化开发等能力\n3. **可扩展性**：所有输出文件保留完整源码，支持二次修改\n\n```java\n\n```\n\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/u014496893/article/details/146104183?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-04-28 17:37:59', '2025-04-30 12:29:19');
INSERT INTO `sys_article` VALUES (331, 1, 45, '机器学习特征筛选：向后淘汰法原理与Python实现', 'img/机器学习特征筛选：向后淘汰法原理与Python实现.png', '机器学习\n', '<p>向后淘汰法（Backward Elimination）是机器学习领域中一种重要的特征选择技术，其核心思想是通过系统性地移除对模型贡献较小的特征，以提高模型性能和可解释性。该方法从完整特征集出发，逐步剔除不重要的特征，最终保留对预测结果最具影响力的变量子集。</p>\n<h3><a id=\"_content_views_2\"></a>向后淘汰法的工作原理 {content_views}</h3>\n<p>向后淘汰法遵循一个迭代式的特征筛选过程，具体步骤如下：</p>\n<ol>\n<li><strong>初始模型构建</strong>：首先使用数据集中的全部特征构建模型。</li>\n<li><strong>模型拟合</strong>：在完整特征集上训练机器学习模型。</li>\n<li><strong>特征重要性评估</strong>：通过统计测试或性能指标（如线性回归中的p值）评估各个特征的重要性。</li>\n<li><strong>特征剔除</strong>：识别并移除对模型贡献最小的特征（例如具有最高p值或对模型性能影响最小的特征）。</li>\n<li><strong>模型重构</strong>：使用剩余特征重新训练模型。</li>\n<li><strong>迭代优化</strong>：重复上述过程，直到达到某个停止条件------例如所有剩余特征均达到统计显著性，或进一步移除特征会导致模型性能下降。</li>\n</ol>\n<h3><a id=\"_13\"></a>向后淘汰法的优势</h3>\n<p>向后淘汰法在特征选择过程中具有多方面的优势。首先，它能显著提升模型的简洁性，通过减少特征维度使模型更易于解释和理解。其次，移除不相关特征能够潜在地提高模型性能，有效避免过拟合现象。此外，特征数量的减少还能降低计算复杂度，提高模型训练和预测的效率。</p>\n<p>线性回归中的向后淘汰法实例</p>\n<p>在线性回归应用场景中，向后淘汰法的典型实现流程为：首先构建包含所有候选特征的完整模型；然后评估每个特征的p值，识别统计显著性最低（p值最高）的特征；将该特征从模型中剔除并重新训练；重复此过程直至所有保留的特征都具有统计显著性。</p>\n<h3><a id=\"_21\"></a>方法局限性</h3>\n<p>尽管向后淘汰法在特征选择中具有广泛应用，但也存在一定局限性：一是计算成本较高，特别是在处理高维特征空间时，迭代过程可能耗时较长；二是在特征间存在复杂依赖关系或非线性关联的情况下，该方法可能无法找到全局最优的特征子集，而是陷入局部最优解。</p>\n<p>向后淘汰法广泛应用于特征可解释性至关重要的模型中，如线性回归、逻辑回归等统计学习模型。</p>\n<h3><a id=\"Python_27\"></a>Python实现向后淘汰法</h3>\n<p>在Python环境中实现向后淘汰法有多种途径，既可利用现有库的自动化功能，也可以根据需求进行手动实现。</p>\n<h4><a id=\"statsmodels_31\"></a>基于statsmodels的自动化实现</h4>\n<p>Python的statsmodels库提供了便捷的功能支持向后淘汰过程，以下是在线性回归模型中的应用示例：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"> <span class=\"hljs-keyword\">import</span> statsmodels.api as sm\n<span class=\"hljs-keyword\">import</span> pandas as pd\n<span class=\"hljs-keyword\">import</span> numpy as np\n\n# 构建示例数据集\nX = np.random.rand(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">5</span>)  # <span class=\"hljs-number\">100</span>个样本，<span class=\"hljs-number\">5</span>个特征\ny = np.random.rand(<span class=\"hljs-number\">100</span>)\n\n# 添加常数项作为截距\nX = sm.add_constant(X)\n\n# 拟合模型\nmodel = sm.OLS(y, X).fit()\n\n# 输出摘要统计信息查看p值\n print(model.summary())\n</code></div></pre>\n<h4><a id=\"_56_54\"></a>{#_56}向后淘汰法的手动实现</h4>\n<p>对于需要更精细控制的场景，以下是向后淘汰法的手动实现方式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"> <span class=\"hljs-keyword\">import</span> pandas as pd\n<span class=\"hljs-keyword\">import</span> numpy as np\n<span class=\"hljs-keyword\">import</span> statsmodels.api as sm\nfrom sklearn.datasets <span class=\"hljs-keyword\">import</span> make_regression\n\n# 生成示例数据\nX, y = make_regression(n_samples=<span class=\"hljs-number\">100</span>, n_features=<span class=\"hljs-number\">5</span>, noise=<span class=\"hljs-number\">0.1</span>, random_state=<span class=\"hljs-number\">42</span>)\n\n# 添加常数项作为截距\nX = sm.add_constant(X)\n\ndef <span class=\"hljs-title function_\">backward_elimination</span><span class=\"hljs-params\">(X, y, significance_level=<span class=\"hljs-number\">0.05</span>)</span>:\n    features = X.columns.tolist()\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-title function_\">len</span><span class=\"hljs-params\">(features)</span> &gt; <span class=\"hljs-number\">0</span>:\n        # 拟合模型\n        model = sm.OLS(y, X[features]).fit()\n        # 获取各特征的p值\n        p_values = model.pvalues[<span class=\"hljs-number\">1</span>:]  # 排除常数项\n        max_p_value = max(p_values)\n        <span class=\"hljs-keyword\">if</span> max_p_value &gt; significance_level:\n            # 如果最大p值超过阈值，移除该特征\n            excluded_feature = features[p_values.argmax()]\n            print(f<span class=\"hljs-string\">&#x27;移除特征: {excluded_feature}，p值为 {max_p_value}&#x27;</span>)\n            features.remove(excluded_feature)\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">break</span>\n    <span class=\"hljs-keyword\">return</span> features\n\n# 将X转换为DataFrame以使用列名\nX_df = pd.DataFrame(X, columns=[<span class=\"hljs-string\">&#x27;const&#x27;</span>, <span class=\"hljs-string\">&#x27;Feature1&#x27;</span>, <span class=\"hljs-string\">&#x27;Feature2&#x27;</span>, <span class=\"hljs-string\">&#x27;Feature3&#x27;</span>, <span class=\"hljs-string\">&#x27;Feature4&#x27;</span>, <span class=\"hljs-string\">&#x27;Feature5&#x27;</span>])\n\n# 执行向后淘汰\nselected_features = backward_elimination(X_df, y)\n print(<span class=\"hljs-string\">&#x27;保留的特征:&#x27;</span>, selected_features)\n</code></div></pre>\n<p>上述手动实现遵循以下核心步骤：首先使用所有特征拟合线性模型（</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">sm.OLS\n</code></div></pre>\n<p>）；然后检查每个特征的p值，若最大p值超过显著性阈值（如0.05），表明该特征在统计上不显著，应予以移除；移除p值最高的特征后重新训练模型；重复此过程直至所有保留特征的p值均低于设定的阈值。</p>\n<h4><a id=\"_103_103\"></a>{#_103}何时采用手动向后淘汰</h4>\n<p>在以下情境下，手动实现向后淘汰法可能更为适合：</p>\n<p>当项目有特定的定制化需求，需要对筛选过程进行精细控制时；处理规模较小的数据集或出于教学目的深入理解算法机制时。然而，对于大多数实际的机器学习工作流程，使用</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">statsmodels\n</code></div></pre>\n<p>、</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">sklearn\n</code></div></pre>\n<p>等库提供的现成工具能够更高效地自动化特征选择过程。</p>\n<h4><a id=\"Scikitlearn_117Scikitlearn_121\"></a>{#Scikitlearn_117}基于Scikit-learn的递归特征消除</h4>\n<p>Scikit-learn库通过递归特征消除（RFE）提供了一种更为自动化的特征选择方法，本质上是向后淘汰法的一种系统化实现：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"> from sklearn.feature_selection <span class=\"hljs-keyword\">import</span> RFE\nfrom sklearn.linear_model <span class=\"hljs-keyword\">import</span> LinearRegression\n\n# 创建基础模型\nmodel = LinearRegression()\n\n# 创建RFE模型并选择前<span class=\"hljs-number\">3</span>个特征\nrfe = RFE(model, <span class=\"hljs-number\">3</span>)\nX_rfe = rfe.fit_transform(X, y)\n\n# 输出特征排名\n print(<span class=\"hljs-string\">&quot;特征排名:&quot;</span>, rfe.ranking_)\n</code></div></pre>\n<p>这种方法执行与向后淘汰相似的操作，但在自动化处理大规模特征选择任务时效率更高，适用于生产环境的模型开发。</p>\n<h3><a id=\"_138_142\"></a>{#_138}总结</h3>\n<p>向后淘汰法是机器学习中一种重要的特征选择技术，其工作原理是从全部特征出发，逐步剔除对模型贡献度低的特征。本文详细介绍了向后淘汰法的工作原理、实施步骤、优势局限性，并提供了多种Python实现方式，包括基于statsmodels的自动化实现、手动实现以及基于Scikit-learn的递归特征消除。向后淘汰法能有效提升模型简洁性、可解释性，并在某些情况下改善模型性能，特别适用于线性回归等统计学习模型。然而，该方法在计算成本和处理复杂特征关系方面存在一定局限。选择合适的特征筛选方法应根据具体应用场景、数据特性和模型需求进行评估。</p>\n<p><a href=\"https://avoid.overfit.cn/post/6ea004a2a69e4aab90feb285b0f4b4f4\" target=\"_blank\">https://avoid.overfit.cn/post/6ea004a2a69e4aab90feb285b0f4b4f4</a></p>\n<p>作者：Ravindu Ruminates</p>\n', '向后淘汰法（Backward Elimination）是机器学习领域中一种重要的特征选择技术，其核心思想是通过系统性地移除对模型贡献较小的特征，以提高模型性能和可解释性。该方法从完整特征集出发，逐步剔除不重要的特征，最终保留对预测结果最具影响力的变量子集。  \n\n### 向后淘汰法的工作原理 {content_views}\n\n向后淘汰法遵循一个迭代式的特征筛选过程，具体步骤如下：\n\n1. **初始模型构建**：首先使用数据集中的全部特征构建模型。\n2. **模型拟合**：在完整特征集上训练机器学习模型。\n3. **特征重要性评估**：通过统计测试或性能指标（如线性回归中的p值）评估各个特征的重要性。\n4. **特征剔除**：识别并移除对模型贡献最小的特征（例如具有最高p值或对模型性能影响最小的特征）。\n5. **模型重构**：使用剩余特征重新训练模型。\n6. **迭代优化**：重复上述过程，直到达到某个停止条件------例如所有剩余特征均达到统计显著性，或进一步移除特征会导致模型性能下降。\n\n### 向后淘汰法的优势\n\n向后淘汰法在特征选择过程中具有多方面的优势。首先，它能显著提升模型的简洁性，通过减少特征维度使模型更易于解释和理解。其次，移除不相关特征能够潜在地提高模型性能，有效避免过拟合现象。此外，特征数量的减少还能降低计算复杂度，提高模型训练和预测的效率。\n\n线性回归中的向后淘汰法实例\n\n在线性回归应用场景中，向后淘汰法的典型实现流程为：首先构建包含所有候选特征的完整模型；然后评估每个特征的p值，识别统计显著性最低（p值最高）的特征；将该特征从模型中剔除并重新训练；重复此过程直至所有保留的特征都具有统计显著性。\n\n### 方法局限性\n\n尽管向后淘汰法在特征选择中具有广泛应用，但也存在一定局限性：一是计算成本较高，特别是在处理高维特征空间时，迭代过程可能耗时较长；二是在特征间存在复杂依赖关系或非线性关联的情况下，该方法可能无法找到全局最优的特征子集，而是陷入局部最优解。\n\n向后淘汰法广泛应用于特征可解释性至关重要的模型中，如线性回归、逻辑回归等统计学习模型。\n\n### Python实现向后淘汰法\n\n在Python环境中实现向后淘汰法有多种途径，既可利用现有库的自动化功能，也可以根据需求进行手动实现。\n\n#### 基于statsmodels的自动化实现\n\nPython的statsmodels库提供了便捷的功能支持向后淘汰过程，以下是在线性回归模型中的应用示例：\n\n```java\n import statsmodels.api as sm\nimport pandas as pd\nimport numpy as np\n\n# 构建示例数据集\nX = np.random.rand(100, 5)  # 100个样本，5个特征\ny = np.random.rand(100)\n\n# 添加常数项作为截距\nX = sm.add_constant(X)\n\n# 拟合模型\nmodel = sm.OLS(y, X).fit()\n\n# 输出摘要统计信息查看p值\n print(model.summary())\n```\n\n#### {#_56}向后淘汰法的手动实现\n\n对于需要更精细控制的场景，以下是向后淘汰法的手动实现方式：\n\n```java\n import pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nfrom sklearn.datasets import make_regression\n\n# 生成示例数据\nX, y = make_regression(n_samples=100, n_features=5, noise=0.1, random_state=42)\n\n# 添加常数项作为截距\nX = sm.add_constant(X)\n\ndef backward_elimination(X, y, significance_level=0.05):\n    features = X.columns.tolist()\n    while len(features) > 0:\n        # 拟合模型\n        model = sm.OLS(y, X[features]).fit()\n        # 获取各特征的p值\n        p_values = model.pvalues[1:]  # 排除常数项\n        max_p_value = max(p_values)\n        if max_p_value > significance_level:\n            # 如果最大p值超过阈值，移除该特征\n            excluded_feature = features[p_values.argmax()]\n            print(f\'移除特征: {excluded_feature}，p值为 {max_p_value}\')\n            features.remove(excluded_feature)\n        else:\n            break\n    return features\n\n# 将X转换为DataFrame以使用列名\nX_df = pd.DataFrame(X, columns=[\'const\', \'Feature1\', \'Feature2\', \'Feature3\', \'Feature4\', \'Feature5\'])\n\n# 执行向后淘汰\nselected_features = backward_elimination(X_df, y)\n print(\'保留的特征:\', selected_features)\n```\n\n上述手动实现遵循以下核心步骤：首先使用所有特征拟合线性模型（\n\n```java\nsm.OLS\n```\n\n）；然后检查每个特征的p值，若最大p值超过显著性阈值（如0.05），表明该特征在统计上不显著，应予以移除；移除p值最高的特征后重新训练模型；重复此过程直至所有保留特征的p值均低于设定的阈值。\n\n#### {#_103}何时采用手动向后淘汰\n\n在以下情境下，手动实现向后淘汰法可能更为适合：\n\n当项目有特定的定制化需求，需要对筛选过程进行精细控制时；处理规模较小的数据集或出于教学目的深入理解算法机制时。然而，对于大多数实际的机器学习工作流程，使用\n\n```java\nstatsmodels\n```\n\n、\n\n```java\nsklearn\n```\n\n等库提供的现成工具能够更高效地自动化特征选择过程。\n\n#### {#Scikitlearn_117}基于Scikit-learn的递归特征消除\n\nScikit-learn库通过递归特征消除（RFE）提供了一种更为自动化的特征选择方法，本质上是向后淘汰法的一种系统化实现：\n\n```java\n from sklearn.feature_selection import RFE\nfrom sklearn.linear_model import LinearRegression\n\n# 创建基础模型\nmodel = LinearRegression()\n\n# 创建RFE模型并选择前3个特征\nrfe = RFE(model, 3)\nX_rfe = rfe.fit_transform(X, y)\n\n# 输出特征排名\n print(\"特征排名:\", rfe.ranking_)\n```\n\n这种方法执行与向后淘汰相似的操作，但在自动化处理大规模特征选择任务时效率更高，适用于生产环境的模型开发。\n\n### {#_138}总结\n\n向后淘汰法是机器学习中一种重要的特征选择技术，其工作原理是从全部特征出发，逐步剔除对模型贡献度低的特征。本文详细介绍了向后淘汰法的工作原理、实施步骤、优势局限性，并提供了多种Python实现方式，包括基于statsmodels的自动化实现、手动实现以及基于Scikit-learn的递归特征消除。向后淘汰法能有效提升模型简洁性、可解释性，并在某些情况下改善模型性能，特别适用于线性回归等统计学习模型。然而，该方法在计算成本和处理复杂特征关系方面存在一定局限。选择合适的特征筛选方法应根据具体应用场景、数据特性和模型需求进行评估。\n\n<https://avoid.overfit.cn/post/6ea004a2a69e4aab90feb285b0f4b4f4>\n\n作者：Ravindu Ruminates\n', 1, 0, 1, 0, 0, 0, 'https://blog.csdn.net/deephub/article/details/145976691?spm=1000.2115.3001.10524', 0, NULL, NULL, '2025-04-28 17:40:31', '2025-04-30 12:28:27');

-- ----------------------------
-- Table structure for sys_article_like
-- ----------------------------
DROP TABLE IF EXISTS `sys_article_like`;
CREATE TABLE `sys_article_like`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int NOT NULL COMMENT '用户id',
  `article_id` int NOT NULL COMMENT '文章id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 18 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文章点赞表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_article_like
-- ----------------------------
INSERT INTO `sys_article_like` VALUES (5, 1, 292);
INSERT INTO `sys_article_like` VALUES (6, 1, 300);
INSERT INTO `sys_article_like` VALUES (7, 1811, 332);
INSERT INTO `sys_article_like` VALUES (9, 1811, 296);
INSERT INTO `sys_article_like` VALUES (10, 1811, 298);
INSERT INTO `sys_article_like` VALUES (12, 1, 331);
INSERT INTO `sys_article_like` VALUES (13, 1811, 331);
INSERT INTO `sys_article_like` VALUES (16, 1, 296);
INSERT INTO `sys_article_like` VALUES (17, 4, 331);

-- ----------------------------
-- Table structure for sys_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `sys_article_tag`;
CREATE TABLE `sys_article_tag`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `article_id` int NOT NULL COMMENT '文章id',
  `tag_id` int NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1893 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文章标签关联表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_article_tag
-- ----------------------------
INSERT INTO `sys_article_tag` VALUES (1379, 292, 1);
INSERT INTO `sys_article_tag` VALUES (1380, 292, 12);
INSERT INTO `sys_article_tag` VALUES (1436, 297, 66);
INSERT INTO `sys_article_tag` VALUES (1437, 297, 103);
INSERT INTO `sys_article_tag` VALUES (1438, 297, 104);
INSERT INTO `sys_article_tag` VALUES (1475, 298, 66);
INSERT INTO `sys_article_tag` VALUES (1476, 298, 103);
INSERT INTO `sys_article_tag` VALUES (1477, 298, 104);
INSERT INTO `sys_article_tag` VALUES (1672, 325, 148);
INSERT INTO `sys_article_tag` VALUES (1673, 325, 185);
INSERT INTO `sys_article_tag` VALUES (1674, 325, 137);
INSERT INTO `sys_article_tag` VALUES (1675, 324, 66);
INSERT INTO `sys_article_tag` VALUES (1690, 308, 130);
INSERT INTO `sys_article_tag` VALUES (1691, 308, 18);
INSERT INTO `sys_article_tag` VALUES (1692, 308, 107);
INSERT INTO `sys_article_tag` VALUES (1693, 308, 63);
INSERT INTO `sys_article_tag` VALUES (1735, 321, 172);
INSERT INTO `sys_article_tag` VALUES (1736, 321, 136);
INSERT INTO `sys_article_tag` VALUES (1737, 321, 137);
INSERT INTO `sys_article_tag` VALUES (1738, 321, 173);
INSERT INTO `sys_article_tag` VALUES (1739, 321, 122);
INSERT INTO `sys_article_tag` VALUES (1740, 320, 170);
INSERT INTO `sys_article_tag` VALUES (1741, 320, 13);
INSERT INTO `sys_article_tag` VALUES (1742, 320, 171);
INSERT INTO `sys_article_tag` VALUES (1743, 320, 102);
INSERT INTO `sys_article_tag` VALUES (1786, 306, 125);
INSERT INTO `sys_article_tag` VALUES (1787, 306, 126);
INSERT INTO `sys_article_tag` VALUES (1788, 306, 127);
INSERT INTO `sys_article_tag` VALUES (1789, 306, 128);
INSERT INTO `sys_article_tag` VALUES (1790, 306, 129);
INSERT INTO `sys_article_tag` VALUES (1803, 301, 18);
INSERT INTO `sys_article_tag` VALUES (1804, 301, 63);
INSERT INTO `sys_article_tag` VALUES (1805, 301, 107);
INSERT INTO `sys_article_tag` VALUES (1806, 317, 155);
INSERT INTO `sys_article_tag` VALUES (1807, 317, 156);
INSERT INTO `sys_article_tag` VALUES (1808, 317, 157);
INSERT INTO `sys_article_tag` VALUES (1809, 317, 158);
INSERT INTO `sys_article_tag` VALUES (1810, 313, 139);
INSERT INTO `sys_article_tag` VALUES (1811, 313, 107);
INSERT INTO `sys_article_tag` VALUES (1812, 313, 140);
INSERT INTO `sys_article_tag` VALUES (1813, 313, 141);
INSERT INTO `sys_article_tag` VALUES (1814, 313, 142);
INSERT INTO `sys_article_tag` VALUES (1815, 313, 143);
INSERT INTO `sys_article_tag` VALUES (1816, 313, 144);
INSERT INTO `sys_article_tag` VALUES (1817, 313, 145);
INSERT INTO `sys_article_tag` VALUES (1819, 326, 186);
INSERT INTO `sys_article_tag` VALUES (1820, 326, 187);
INSERT INTO `sys_article_tag` VALUES (1821, 326, 136);
INSERT INTO `sys_article_tag` VALUES (1822, 326, 122);
INSERT INTO `sys_article_tag` VALUES (1823, 326, 188);
INSERT INTO `sys_article_tag` VALUES (1824, 326, 189);
INSERT INTO `sys_article_tag` VALUES (1825, 326, 190);
INSERT INTO `sys_article_tag` VALUES (1842, 312, 138);
INSERT INTO `sys_article_tag` VALUES (1843, 312, 18);
INSERT INTO `sys_article_tag` VALUES (1844, 312, 122);
INSERT INTO `sys_article_tag` VALUES (1845, 312, 107);
INSERT INTO `sys_article_tag` VALUES (1846, 312, 63);
INSERT INTO `sys_article_tag` VALUES (1852, 309, 131);
INSERT INTO `sys_article_tag` VALUES (1853, 309, 131);
INSERT INTO `sys_article_tag` VALUES (1854, 309, 132);
INSERT INTO `sys_article_tag` VALUES (1855, 309, 133);
INSERT INTO `sys_article_tag` VALUES (1856, 309, 122);
INSERT INTO `sys_article_tag` VALUES (1865, 304, 120);
INSERT INTO `sys_article_tag` VALUES (1866, 304, 121);
INSERT INTO `sys_article_tag` VALUES (1867, 304, 104);
INSERT INTO `sys_article_tag` VALUES (1868, 304, 122);
INSERT INTO `sys_article_tag` VALUES (1869, 302, 108);
INSERT INTO `sys_article_tag` VALUES (1870, 302, 109);
INSERT INTO `sys_article_tag` VALUES (1871, 302, 110);
INSERT INTO `sys_article_tag` VALUES (1872, 302, 111);
INSERT INTO `sys_article_tag` VALUES (1873, 302, 112);
INSERT INTO `sys_article_tag` VALUES (1874, 302, 113);
INSERT INTO `sys_article_tag` VALUES (1875, 302, 114);
INSERT INTO `sys_article_tag` VALUES (1883, 296, 1);
INSERT INTO `sys_article_tag` VALUES (1884, 331, 118);
INSERT INTO `sys_article_tag` VALUES (1885, 331, 161);
INSERT INTO `sys_article_tag` VALUES (1886, 329, 12);
INSERT INTO `sys_article_tag` VALUES (1887, 327, 134);
INSERT INTO `sys_article_tag` VALUES (1888, 318, 159);
INSERT INTO `sys_article_tag` VALUES (1889, 318, 161);
INSERT INTO `sys_article_tag` VALUES (1890, 318, 161);
INSERT INTO `sys_article_tag` VALUES (1891, 318, 162);
INSERT INTO `sys_article_tag` VALUES (1892, 318, 163);

-- ----------------------------
-- Table structure for sys_category
-- ----------------------------
DROP TABLE IF EXISTS `sys_category`;
CREATE TABLE `sys_category`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '名称',
  `sort` int NULL DEFAULT NULL COMMENT '排序',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 47 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '分类表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_category
-- ----------------------------
INSERT INTO `sys_category` VALUES (16, '运维部署', 1, '2024-12-22 18:59:28', NULL);
INSERT INTO `sys_category` VALUES (17, '后端开发', 1, NULL, NULL);
INSERT INTO `sys_category` VALUES (19, '网络爬虫', NULL, NULL, NULL);
INSERT INTO `sys_category` VALUES (20, '资源软件', NULL, NULL, NULL);
INSERT INTO `sys_category` VALUES (28, '数据库', NULL, NULL, NULL);
INSERT INTO `sys_category` VALUES (31, '前端开发', NULL, NULL, NULL);
INSERT INTO `sys_category` VALUES (32, '博客文档', NULL, NULL, NULL);
INSERT INTO `sys_category` VALUES (37, '读书', NULL, '2025-04-28 16:08:08', NULL);
INSERT INTO `sys_category` VALUES (38, 'c语言', NULL, '2025-04-28 17:04:18', NULL);
INSERT INTO `sys_category` VALUES (39, 'AI', NULL, '2025-04-28 17:04:38', NULL);
INSERT INTO `sys_category` VALUES (40, 'C++', NULL, '2025-04-28 17:05:10', NULL);
INSERT INTO `sys_category` VALUES (41, 'Java', NULL, '2025-04-28 17:28:20', NULL);
INSERT INTO `sys_category` VALUES (42, 'AIGC', NULL, '2025-04-28 17:29:41', NULL);
INSERT INTO `sys_category` VALUES (43, '编译器', NULL, '2025-04-28 17:30:51', NULL);
INSERT INTO `sys_category` VALUES (44, 'Linux', NULL, '2025-04-28 17:32:16', NULL);
INSERT INTO `sys_category` VALUES (45, '机器学习', NULL, '2025-04-28 17:40:51', NULL);
INSERT INTO `sys_category` VALUES (46, 'Python ', NULL, '2025-04-28 17:41:56', NULL);

-- ----------------------------
-- Table structure for sys_comment
-- ----------------------------
DROP TABLE IF EXISTS `sys_comment`;
CREATE TABLE `sys_comment`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '评论主键ID，自增唯一标识',
  `article_id` int NOT NULL COMMENT '关联的文章ID，表明该评论所属的文章',
  `user_id` int NOT NULL COMMENT '发表评论的用户ID',
  `reply_user_id` int NULL DEFAULT NULL COMMENT '回复人id',
  `parent_id` int NULL DEFAULT NULL COMMENT '父评论ID，用于实现回复评论的层级结构，若为顶级评论则为NULL',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论内容，使用utf8mb4字符集以支持更多字符类型',
  `like_count` int NULL DEFAULT 0 COMMENT '点赞数，记录该评论获得的点赞数量',
  `is_stick` int NULL DEFAULT 0 COMMENT '是否置顶',
  `ip` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip',
  `browser` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `system` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '系统',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_article_id`(`article_id` ASC) USING BTREE,
  INDEX `idx_user_id`(`user_id` ASC) USING BTREE,
  INDEX `idx_parent_id`(`parent_id` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 53 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '评论' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_comment
-- ----------------------------
INSERT INTO `sys_comment` VALUES (15, 1, 1, 9, 14, 'fwafwaf', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', NULL);
INSERT INTO `sys_comment` VALUES (19, 1, 1, 1, 14, 'sfawfwa', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', NULL);
INSERT INTO `sys_comment` VALUES (20, 1, 1, 9, 14, 'fawaf', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', NULL);
INSERT INTO `sys_comment` VALUES (21, 1, 1, NULL, NULL, '![laugh](https://media.giphy.com/media/10JhviFuU2gWD6/giphy.gif)', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', NULL);
INSERT INTO `sys_comment` VALUES (22, 1, 1, NULL, NULL, '\\![happy](https://media.giphy.com/media/XR9Dp54ZC4dji/giphy.gif)', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', NULL);
INSERT INTO `sys_comment` VALUES (23, 1, 1, NULL, NULL, '![happy](https://media.giphy.com/media/XR9Dp54ZC4dji/giphy.gif)', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', NULL);
INSERT INTO `sys_comment` VALUES (25, 292, 1, NULL, NULL, '<span style=\"color: #409eff\">hhhh</span>', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', '2024-12-27 20:40:32');
INSERT INTO `sys_comment` VALUES (27, 292, 1, 1809, 25, '那是', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', '2024-12-28 14:07:05');
INSERT INTO `sys_comment` VALUES (31, 265, 1, NULL, NULL, 'asfsafafwf', 0, 0, '127.0.0.1', 'Chrome 131.0.0.0', NULL, '内网IP|内网IP', '2024-12-31 14:48:18');
INSERT INTO `sys_comment` VALUES (32, 332, 1811, NULL, NULL, '哈哈哈哈哈哈哈哈哈', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-28 17:54:56');
INSERT INTO `sys_comment` VALUES (33, 332, 1811, 1811, 32, '***袜带', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', '2025-04-28 17:55:04');
INSERT INTO `sys_comment` VALUES (34, 298, 1811, NULL, NULL, '订单创建失败<div>快修</div>', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-28 17:59:23');
INSERT INTO `sys_comment` VALUES (35, 326, 1811, NULL, NULL, '<img src=\"https://baidubox-emoji.cdn.bcebos.com/imgs/[亲吻].png\" class=\"emoji\" style=\"width: 30px; height: 30px; vertical-align: middle;\">', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-28 18:11:32');
INSERT INTO `sys_comment` VALUES (36, 326, 1811, 1811, 35, '<img src=\"https://baidubox-emoji.cdn.bcebos.com/imgs/[滑稽].png\" class=\"emoji\" style=\"width: 22px; height: 22px; vertical-align: middle;\">', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', '2025-04-28 18:11:47');
INSERT INTO `sys_comment` VALUES (37, 296, 1, NULL, NULL, '1111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 16:44:10');
INSERT INTO `sys_comment` VALUES (38, 296, 1, NULL, NULL, '11111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 16:44:17');
INSERT INTO `sys_comment` VALUES (39, 296, 1, NULL, NULL, '11111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 16:44:22');
INSERT INTO `sys_comment` VALUES (40, 296, 1, NULL, NULL, '111111111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 16:44:28');
INSERT INTO `sys_comment` VALUES (41, 296, 1, NULL, NULL, '1111111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 16:44:33');
INSERT INTO `sys_comment` VALUES (42, 296, 1, NULL, NULL, '111111111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 16:44:39');
INSERT INTO `sys_comment` VALUES (43, 296, 1, NULL, NULL, '1111111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 16:44:46');
INSERT INTO `sys_comment` VALUES (44, 296, 1, NULL, NULL, '111111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 16:44:51');
INSERT INTO `sys_comment` VALUES (45, 296, 1, NULL, NULL, '111111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 16:44:57');
INSERT INTO `sys_comment` VALUES (46, 296, 1, NULL, NULL, '11111111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 16:45:02');
INSERT INTO `sys_comment` VALUES (47, 296, 1, NULL, NULL, '111111111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 16:45:08');
INSERT INTO `sys_comment` VALUES (48, 296, 1, 1, 47, '1111', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', '2025-04-29 16:45:16');
INSERT INTO `sys_comment` VALUES (49, 331, 1811, NULL, NULL, '111', 0, 0, '127.0.0.1', 'Chrome 135.0.0.0', NULL, '内网IP|内网IP', '2025-04-29 21:27:04');
INSERT INTO `sys_comment` VALUES (50, 296, 1, 1, 47, '1', 0, 0, '127.0.0.1', NULL, NULL, '内网IP|内网IP', '2025-04-30 00:15:21');
INSERT INTO `sys_comment` VALUES (51, 331, 2, NULL, NULL, '11', 0, 0, '113.45.240.54', 'Chrome 135.0.0.0', NULL, '中国|北京|北京市|鹏博士', '2025-05-09 00:13:38');
INSERT INTO `sys_comment` VALUES (52, 329, 4, NULL, NULL, '111', 0, 0, '113.45.240.54', 'Chrome 135.0.0.0', NULL, '中国|北京|北京市|鹏博士', '2025-05-10 13:30:40');

-- ----------------------------
-- Table structure for sys_config
-- ----------------------------
DROP TABLE IF EXISTS `sys_config`;
CREATE TABLE `sys_config`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '参数主键',
  `config_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '参数名称',
  `config_key` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '参数键名',
  `config_value` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '参数键值',
  `config_type` varchar(4) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT 'N' COMMENT '系统内置（Y是 N否）',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '参数配置表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_config
-- ----------------------------
INSERT INTO `sys_config` VALUES (1, '滑块验证码开关', 'slider_verify_switch', 'Y', 'Y', NULL, '2025-03-19 16:33:27', '开启：Y,关闭：N');

-- ----------------------------
-- Table structure for sys_dict
-- ----------------------------
DROP TABLE IF EXISTS `sys_dict`;
CREATE TABLE `sys_dict`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '字典名称',
  `type` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '字典类型',
  `status` int NOT NULL DEFAULT 1 COMMENT '是否发布(1:是，0:否)',
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `sort` int NULL DEFAULT 0 COMMENT '排序',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 39 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '字典表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_dict
-- ----------------------------
INSERT INTO `sys_dict` VALUES (26, '登录方式', 'login_type', 1, '登陆方式', '2024-12-28 22:25:17', '2024-12-28 22:25:17', 0);
INSERT INTO `sys_dict` VALUES (31, '反馈类型', 'feedback_type', 1, '反馈类型', '2025-01-12 10:37:00', '2025-01-12 10:37:00', 0);
INSERT INTO `sys_dict` VALUES (32, '反馈状态', 'feedback_status', 1, '', '2025-01-12 10:37:00', '2025-01-12 10:37:00', 0);
INSERT INTO `sys_dict` VALUES (33, '公告位置', 'notice_position', 1, '', '2025-02-11 15:27:51', '2025-02-11 15:27:51', 0);
INSERT INTO `sys_dict` VALUES (34, '是否状态', 'sys_yes_no', 1, '是和否状态', '2025-02-13 14:33:48', '2025-02-13 14:33:47', 0);
INSERT INTO `sys_dict` VALUES (35, '文件类型', 'sys_file_type', 1, '', '2025-02-13 17:10:46', '2025-02-13 17:10:45', 0);
INSERT INTO `sys_dict` VALUES (36, '存储平台', 'sys_file_oss', 1, '', '2025-02-14 08:47:01', '2025-02-14 08:47:01', 0);
INSERT INTO `sys_dict` VALUES (37, '文章状态', 'article_status', 1, NULL, '2025-01-16 09:56:49', '2025-01-16 09:56:49', 0);
INSERT INTO `sys_dict` VALUES (38, '资源分类', 'sys_resource_category', 1, NULL, '2025-03-12 10:04:22', '2025-03-12 10:04:22', 0);

-- ----------------------------
-- Table structure for sys_dict_data
-- ----------------------------
DROP TABLE IF EXISTS `sys_dict_data`;
CREATE TABLE `sys_dict_data`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `dict_id` bigint NOT NULL COMMENT '字典类型id',
  `label` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '字典标签',
  `value` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '字典键值',
  `style` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '回显样式',
  `is_default` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '是否默认（1是 0否）',
  `sort` int NULL DEFAULT NULL COMMENT '排序',
  `remark` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  `status` int NULL DEFAULT 1,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 67 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '字典数据表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_dict_data
-- ----------------------------
INSERT INTO `sys_dict_data` VALUES (1, 37, '下架', '0', 'danger', '0', 1, NULL, 1);
INSERT INTO `sys_dict_data` VALUES (2, 37, '上架', '1', 'success', '0', 2, NULL, 1);
INSERT INTO `sys_dict_data` VALUES (3, 37, '草稿', '2', 'warning', '0', 3, NULL, 1);
INSERT INTO `sys_dict_data` VALUES (4, 37, '审核', '3', 'info', '0', 4, NULL, 1);
INSERT INTO `sys_dict_data` VALUES (5, 26, 'QQ', 'qq', 'success', '1', 2, 'QQ登录', 1);
INSERT INTO `sys_dict_data` VALUES (6, 26, '微博', 'weibo', 'danger', '0', 2, '微博登录', 1);
INSERT INTO `sys_dict_data` VALUES (7, 26, '码云', 'gitee', 'danger', '0', 3, 'gitee登录', 1);
INSERT INTO `sys_dict_data` VALUES (8, 26, '微信', 'wechat', 'success', '1', 0, '微信登录', 1);
INSERT INTO `sys_dict_data` VALUES (9, 26, 'github', 'github', 'info', '1', 4, 'github登录', 1);
INSERT INTO `sys_dict_data` VALUES (38, 31, '问题反馈', 'bug', 'danger', '0', 1, '', 1);
INSERT INTO `sys_dict_data` VALUES (39, 31, '功能建议', 'feature', 'success', '0', 2, '', 1);
INSERT INTO `sys_dict_data` VALUES (40, 31, '其他', 'other', 'info', '0', 3, '', 1);
INSERT INTO `sys_dict_data` VALUES (49, 33, '顶部', 'top', 'primary', '0', 1, '', 1);
INSERT INTO `sys_dict_data` VALUES (50, 33, '右侧', 'right', 'info', '0', 2, '', 1);
INSERT INTO `sys_dict_data` VALUES (51, 34, '否', '0', 'danger', '0', 0, '', 1);
INSERT INTO `sys_dict_data` VALUES (52, 34, '是', '1', 'success', '0', 1, '', 1);
INSERT INTO `sys_dict_data` VALUES (53, 35, 'png', 'png', 'primary', '0', 0, '', 1);
INSERT INTO `sys_dict_data` VALUES (54, 35, 'gif', 'gif', 'info', '0', 1, '', 1);
INSERT INTO `sys_dict_data` VALUES (55, 35, 'jpg', 'jpg', 'primary', '0', 2, '', 1);
INSERT INTO `sys_dict_data` VALUES (56, 35, 'jpeg', 'jpeg', 'primary', '0', 3, '', 1);
INSERT INTO `sys_dict_data` VALUES (57, 35, 'doc', 'doc', 'warning', '0', 4, '', 1);
INSERT INTO `sys_dict_data` VALUES (58, 35, 'mp4', 'mp4', 'danger', '0', 5, '', 1);
INSERT INTO `sys_dict_data` VALUES (59, 36, '七牛云', 'qiniu', 'primary', '0', 0, '', 1);
INSERT INTO `sys_dict_data` VALUES (60, 36, '阿里云', 'ali', 'warning', '0', 1, '', 1);
INSERT INTO `sys_dict_data` VALUES (61, 36, '本地云', 'local', 'info', '0', 2, '', 1);
INSERT INTO `sys_dict_data` VALUES (62, 36, '腾讯云', 'tencent', 'primary', '0', 3, '', 1);
INSERT INTO `sys_dict_data` VALUES (63, 36, 'minio', 'minio', 'danger', '0', 4, '', 1);
INSERT INTO `sys_dict_data` VALUES (64, 37, '软件安装包', '1', 'primary', '0', 1, 'zip', 1);
INSERT INTO `sys_dict_data` VALUES (65, 37, 'PDF电子书', '2', 'danger', '0', 3, 'pdf', 1);
INSERT INTO `sys_dict_data` VALUES (66, 37, 'Office文档', '3', 'info', '0', 2, 'doc', 1);

-- ----------------------------
-- Table structure for sys_feedback
-- ----------------------------
DROP TABLE IF EXISTS `sys_feedback`;
CREATE TABLE `sys_feedback`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` bigint NOT NULL COMMENT '反馈人id',
  `type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '反馈类型',
  `content` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '反馈内容',
  `email` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '联系邮箱',
  `reply_content` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '回复内容',
  `status` int NULL DEFAULT 0 COMMENT '状态',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '反馈' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_feedback
-- ----------------------------

-- ----------------------------
-- Table structure for sys_file_oss
-- ----------------------------
DROP TABLE IF EXISTS `sys_file_oss`;
CREATE TABLE `sys_file_oss`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `domain` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '访问域名',
  `access_key` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'access-key',
  `secret_key` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'secret-key',
  `bucket` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '空间名',
  `base_path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '存储基础路径',
  `platform` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '存储类型',
  `is_enable` int NULL DEFAULT NULL COMMENT '是否启用存储',
  `storage_path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '本地存储路径',
  `enable_access` int NULL DEFAULT NULL COMMENT '本地启用访问',
  `path_patterns` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '本地访问路径',
  `region` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '仓库所在地域',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '存储平台' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_file_oss
-- ----------------------------
INSERT INTO `sys_file_oss` VALUES (1, 'http://127.0.0.1:80/localFile/', '', '', '', 'local-plus/', 'local', 1, 'D:/Temp/', 1, 'localFile/**', NULL, '2025-02-14 10:52:33');

-- ----------------------------
-- Table structure for sys_friend
-- ----------------------------
DROP TABLE IF EXISTS `sys_friend`;
CREATE TABLE `sys_friend`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '网站名称',
  `url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '网站地址',
  `avatar` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '网站头像地址',
  `info` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '网站描述',
  `email` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱',
  `sort` int NULL DEFAULT 0 COMMENT '排序',
  `reason` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '下架原因',
  `status` int NOT NULL DEFAULT 0 COMMENT 'ENUM-状态:\"0,下架;1,申请;2:上架\"',
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `url`(`url` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 70 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '友情链接' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_friend
-- ----------------------------
INSERT INTO `sys_friend` VALUES (4, '拾壹博客', 'https://www.shiyit.com', 'https://img.shiyit.com/logo11.png', '一个专注技术分享的平台', '2484913345@qq.com', 99, '1', 2, '2022-12-13 09:16:15', '2022-12-13 09:16:15');
INSERT INTO `sys_friend` VALUES (68, 'asdaf', 'https://gitee.com/tticw/code-cloud-star-chain.git', 'http://127.0.0.1:8800/localFile/local-plus/upload/e29c144950d45c11301503b80946ffb3-260x358.png', 'sb', '17758751671@163.com', 1, NULL, 2, '2025-04-27 14:53:55', '2025-04-27 14:53:55');
INSERT INTO `sys_friend` VALUES (69, 'dwa', 'http://localhost:3001/friends', 'http://localhost:3001/friends', 'dwa', '23让7539@qq.com', 1, NULL, 2, '2025-04-27 17:44:29', '2025-04-27 17:44:29');

-- ----------------------------
-- Table structure for sys_job
-- ----------------------------
DROP TABLE IF EXISTS `sys_job`;
CREATE TABLE `sys_job`  (
  `job_id` bigint NOT NULL AUTO_INCREMENT COMMENT '任务ID',
  `job_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '任务名称',
  `job_group` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '任务组名',
  `invoke_target` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '调用目标字符串',
  `cron_expression` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'cron执行表达式',
  `misfire_policy` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '3' COMMENT '计划执行错误策略（1立即执行 2执行一次 3放弃执行）',
  `concurrent` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '1' COMMENT '是否并发执行（0允许 1禁止）',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '0' COMMENT '状态（0正常 1暂停）',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '备注信息',
  PRIMARY KEY (`job_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '定时任务调度表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_job
-- ----------------------------
INSERT INTO `sys_job` VALUES (1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '* * * * * ? *', '3', '1', '1', '2024-11-17 12:39:45', NULL, '');
INSERT INTO `sys_job` VALUES (2, '系统默认（有参）', 'DEFAULT', 'demoTask.ryParams(\'ry\')', '0/15 * * * * ?', '3', '1', '1', '2024-11-17 12:39:45', NULL, '');
INSERT INTO `sys_job` VALUES (3, '系统默认（多参）', 'DEFAULT', 'demoTask.ryMultipleParams(\'ry\', true, 2000L, 316.50D, 100)', '0/20 * * * * ?', '3', '1', '1', '2024-11-17 12:39:45', NULL, '');
INSERT INTO `sys_job` VALUES (11, 'test', 'DEFAULT', 'task.neatNoParams', '0/15 * * * * ? *', '3', '1', '1', NULL, NULL, NULL);
INSERT INTO `sys_job` VALUES (12, '定时更新阅读量', 'DEFAULT', 'task.syncQuantity', '0 0 0 * * ? *', '1', '1', '1', NULL, NULL, NULL);

-- ----------------------------
-- Table structure for sys_job_log
-- ----------------------------
DROP TABLE IF EXISTS `sys_job_log`;
CREATE TABLE `sys_job_log`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '任务日志ID',
  `job_id` bigint NOT NULL COMMENT '任务ID',
  `job_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '任务名称',
  `job_group` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '任务组名',
  `invoke_target` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '调用目标字符串',
  `job_message` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '日志信息',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '0' COMMENT '执行状态（0正常 1失败）',
  `exception_info` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '' COMMENT '异常信息',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `start_time` datetime NULL DEFAULT NULL COMMENT '开始时间',
  `stop_time` datetime NULL DEFAULT NULL COMMENT '结束时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 150 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '定时任务调度日志表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_job_log
-- ----------------------------
INSERT INTO `sys_job_log` VALUES (77, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：-3毫秒', '0', '', '2025-04-27 09:41:59', '2025-04-27 09:41:59', '2025-04-27 09:41:59');
INSERT INTO `sys_job_log` VALUES (78, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:00', '2025-04-27 09:42:00', '2025-04-27 09:42:00');
INSERT INTO `sys_job_log` VALUES (79, 2, '系统默认（有参）', 'DEFAULT', 'demoTask.ryParams(\'ry\')', '系统默认（有参） 总共耗时：-1毫秒', '1', 'org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'demoTask\' available\r\n	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:893)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1318)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\r\n	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1156)\r\n	at com.mojian.utils.SpringUtil.getBean(SpringUtil.java:47)\r\n	at com.mojian.utils.JobInvokeUtils.invokeMethod(JobInvokeUtils.java:31)\r\n	at com.mojian.quartz.QuartzDisallowConcurrentExecution.doExecute(QuartzDisallowConcurrentExecution.java:15)\r\n	at com.mojian.quartz.AbstractQuartzJob.execute(AbstractQuartzJob.java:39)\r\n	at org.quartz.core.JobRunShell.run(JobRunShell.java:202)\r\n	at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573)\r\n', '2025-04-27 09:42:00', '2025-04-27 09:42:00', '2025-04-27 09:42:00');
INSERT INTO `sys_job_log` VALUES (80, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:01', '2025-04-27 09:42:01', '2025-04-27 09:42:01');
INSERT INTO `sys_job_log` VALUES (81, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:02', '2025-04-27 09:42:02', '2025-04-27 09:42:02');
INSERT INTO `sys_job_log` VALUES (82, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:03', '2025-04-27 09:42:03', '2025-04-27 09:42:03');
INSERT INTO `sys_job_log` VALUES (83, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:04', '2025-04-27 09:42:04', '2025-04-27 09:42:04');
INSERT INTO `sys_job_log` VALUES (84, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:05', '2025-04-27 09:42:05', '2025-04-27 09:42:05');
INSERT INTO `sys_job_log` VALUES (85, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:06', '2025-04-27 09:42:06', '2025-04-27 09:42:06');
INSERT INTO `sys_job_log` VALUES (86, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:07', '2025-04-27 09:42:07', '2025-04-27 09:42:07');
INSERT INTO `sys_job_log` VALUES (87, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:08', '2025-04-27 09:42:08', '2025-04-27 09:42:08');
INSERT INTO `sys_job_log` VALUES (88, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:09', '2025-04-27 09:42:09', '2025-04-27 09:42:09');
INSERT INTO `sys_job_log` VALUES (89, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:10', '2025-04-27 09:42:10', '2025-04-27 09:42:10');
INSERT INTO `sys_job_log` VALUES (90, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:11', '2025-04-27 09:42:11', '2025-04-27 09:42:11');
INSERT INTO `sys_job_log` VALUES (91, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:12', '2025-04-27 09:42:12', '2025-04-27 09:42:12');
INSERT INTO `sys_job_log` VALUES (92, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:13', '2025-04-27 09:42:13', '2025-04-27 09:42:13');
INSERT INTO `sys_job_log` VALUES (93, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:14', '2025-04-27 09:42:14', '2025-04-27 09:42:14');
INSERT INTO `sys_job_log` VALUES (94, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:15', '2025-04-27 09:42:15', '2025-04-27 09:42:15');
INSERT INTO `sys_job_log` VALUES (95, 2, '系统默认（有参）', 'DEFAULT', 'demoTask.ryParams(\'ry\')', '系统默认（有参） 总共耗时：0毫秒', '1', 'org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'demoTask\' available\r\n	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:893)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1318)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\r\n	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1156)\r\n	at com.mojian.utils.SpringUtil.getBean(SpringUtil.java:47)\r\n	at com.mojian.utils.JobInvokeUtils.invokeMethod(JobInvokeUtils.java:31)\r\n	at com.mojian.quartz.QuartzDisallowConcurrentExecution.doExecute(QuartzDisallowConcurrentExecution.java:15)\r\n	at com.mojian.quartz.AbstractQuartzJob.execute(AbstractQuartzJob.java:39)\r\n	at org.quartz.core.JobRunShell.run(JobRunShell.java:202)\r\n	at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573)\r\n', '2025-04-27 09:42:15', '2025-04-27 09:42:15', '2025-04-27 09:42:15');
INSERT INTO `sys_job_log` VALUES (96, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:16', '2025-04-27 09:42:16', '2025-04-27 09:42:16');
INSERT INTO `sys_job_log` VALUES (97, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:17', '2025-04-27 09:42:17', '2025-04-27 09:42:17');
INSERT INTO `sys_job_log` VALUES (98, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:18', '2025-04-27 09:42:18', '2025-04-27 09:42:18');
INSERT INTO `sys_job_log` VALUES (99, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:19', '2025-04-27 09:42:19', '2025-04-27 09:42:19');
INSERT INTO `sys_job_log` VALUES (100, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:20', '2025-04-27 09:42:20', '2025-04-27 09:42:20');
INSERT INTO `sys_job_log` VALUES (101, 3, '系统默认（多参）', 'DEFAULT', 'demoTask.ryMultipleParams(\'ry\', true, 2000L, 316.50D, 100)', '系统默认（多参） 总共耗时：-1毫秒', '1', 'org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'demoTask\' available\r\n	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:893)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1318)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\r\n	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1156)\r\n	at com.mojian.utils.SpringUtil.getBean(SpringUtil.java:47)\r\n	at com.mojian.utils.JobInvokeUtils.invokeMethod(JobInvokeUtils.java:31)\r\n	at com.mojian.quartz.QuartzDisallowConcurrentExecution.doExecute(QuartzDisallowConcurrentExecution.java:15)\r\n	at com.mojian.quartz.AbstractQuartzJob.execute(AbstractQuartzJob.java:39)\r\n	at org.quartz.core.JobRunShell.run(JobRunShell.java:202)\r\n	at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573)\r\n', '2025-04-27 09:42:20', '2025-04-27 09:42:20', '2025-04-27 09:42:20');
INSERT INTO `sys_job_log` VALUES (102, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:21', '2025-04-27 09:42:21', '2025-04-27 09:42:21');
INSERT INTO `sys_job_log` VALUES (103, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:22', '2025-04-27 09:42:22', '2025-04-27 09:42:22');
INSERT INTO `sys_job_log` VALUES (104, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:23', '2025-04-27 09:42:23', '2025-04-27 09:42:23');
INSERT INTO `sys_job_log` VALUES (105, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:24', '2025-04-27 09:42:24', '2025-04-27 09:42:24');
INSERT INTO `sys_job_log` VALUES (106, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:25', '2025-04-27 09:42:25', '2025-04-27 09:42:25');
INSERT INTO `sys_job_log` VALUES (107, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:26', '2025-04-27 09:42:26', '2025-04-27 09:42:26');
INSERT INTO `sys_job_log` VALUES (108, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:27', '2025-04-27 09:42:27', '2025-04-27 09:42:27');
INSERT INTO `sys_job_log` VALUES (109, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:28', '2025-04-27 09:42:28', '2025-04-27 09:42:28');
INSERT INTO `sys_job_log` VALUES (110, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:29', '2025-04-27 09:42:29', '2025-04-27 09:42:29');
INSERT INTO `sys_job_log` VALUES (111, 2, '系统默认（有参）', 'DEFAULT', 'demoTask.ryParams(\'ry\')', '系统默认（有参） 总共耗时：0毫秒', '1', 'org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'demoTask\' available\r\n	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:893)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1318)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\r\n	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1156)\r\n	at com.mojian.utils.SpringUtil.getBean(SpringUtil.java:47)\r\n	at com.mojian.utils.JobInvokeUtils.invokeMethod(JobInvokeUtils.java:31)\r\n	at com.mojian.quartz.QuartzDisallowConcurrentExecution.doExecute(QuartzDisallowConcurrentExecution.java:15)\r\n	at com.mojian.quartz.AbstractQuartzJob.execute(AbstractQuartzJob.java:39)\r\n	at org.quartz.core.JobRunShell.run(JobRunShell.java:202)\r\n	at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573)\r\n', '2025-04-27 09:42:30', '2025-04-27 09:42:30', '2025-04-27 09:42:30');
INSERT INTO `sys_job_log` VALUES (112, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:30', '2025-04-27 09:42:30', '2025-04-27 09:42:30');
INSERT INTO `sys_job_log` VALUES (113, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:31', '2025-04-27 09:42:31', '2025-04-27 09:42:31');
INSERT INTO `sys_job_log` VALUES (114, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:32', '2025-04-27 09:42:32', '2025-04-27 09:42:32');
INSERT INTO `sys_job_log` VALUES (115, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:33', '2025-04-27 09:42:33', '2025-04-27 09:42:33');
INSERT INTO `sys_job_log` VALUES (116, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:34', '2025-04-27 09:42:34', '2025-04-27 09:42:34');
INSERT INTO `sys_job_log` VALUES (117, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:35', '2025-04-27 09:42:35', '2025-04-27 09:42:35');
INSERT INTO `sys_job_log` VALUES (118, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:36', '2025-04-27 09:42:36', '2025-04-27 09:42:36');
INSERT INTO `sys_job_log` VALUES (119, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:37', '2025-04-27 09:42:37', '2025-04-27 09:42:37');
INSERT INTO `sys_job_log` VALUES (120, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:38', '2025-04-27 09:42:38', '2025-04-27 09:42:38');
INSERT INTO `sys_job_log` VALUES (121, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:39', '2025-04-27 09:42:39', '2025-04-27 09:42:39');
INSERT INTO `sys_job_log` VALUES (122, 3, '系统默认（多参）', 'DEFAULT', 'demoTask.ryMultipleParams(\'ry\', true, 2000L, 316.50D, 100)', '系统默认（多参） 总共耗时：0毫秒', '1', 'org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'demoTask\' available\r\n	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:893)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1318)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\r\n	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1156)\r\n	at com.mojian.utils.SpringUtil.getBean(SpringUtil.java:47)\r\n	at com.mojian.utils.JobInvokeUtils.invokeMethod(JobInvokeUtils.java:31)\r\n	at com.mojian.quartz.QuartzDisallowConcurrentExecution.doExecute(QuartzDisallowConcurrentExecution.java:15)\r\n	at com.mojian.quartz.AbstractQuartzJob.execute(AbstractQuartzJob.java:39)\r\n	at org.quartz.core.JobRunShell.run(JobRunShell.java:202)\r\n	at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573)\r\n', '2025-04-27 09:42:40', '2025-04-27 09:42:40', '2025-04-27 09:42:40');
INSERT INTO `sys_job_log` VALUES (123, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:40', '2025-04-27 09:42:40', '2025-04-27 09:42:40');
INSERT INTO `sys_job_log` VALUES (124, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:41', '2025-04-27 09:42:41', '2025-04-27 09:42:41');
INSERT INTO `sys_job_log` VALUES (125, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:42', '2025-04-27 09:42:42', '2025-04-27 09:42:42');
INSERT INTO `sys_job_log` VALUES (126, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:43', '2025-04-27 09:42:43', '2025-04-27 09:42:43');
INSERT INTO `sys_job_log` VALUES (127, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:44', '2025-04-27 09:42:44', '2025-04-27 09:42:44');
INSERT INTO `sys_job_log` VALUES (128, 2, '系统默认（有参）', 'DEFAULT', 'demoTask.ryParams(\'ry\')', '系统默认（有参） 总共耗时：0毫秒', '1', 'org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'demoTask\' available\r\n	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:893)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1318)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\r\n	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1156)\r\n	at com.mojian.utils.SpringUtil.getBean(SpringUtil.java:47)\r\n	at com.mojian.utils.JobInvokeUtils.invokeMethod(JobInvokeUtils.java:31)\r\n	at com.mojian.quartz.QuartzDisallowConcurrentExecution.doExecute(QuartzDisallowConcurrentExecution.java:15)\r\n	at com.mojian.quartz.AbstractQuartzJob.execute(AbstractQuartzJob.java:39)\r\n	at org.quartz.core.JobRunShell.run(JobRunShell.java:202)\r\n	at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573)\r\n', '2025-04-27 09:42:45', '2025-04-27 09:42:45', '2025-04-27 09:42:45');
INSERT INTO `sys_job_log` VALUES (129, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:45', '2025-04-27 09:42:45', '2025-04-27 09:42:45');
INSERT INTO `sys_job_log` VALUES (130, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:46', '2025-04-27 09:42:46', '2025-04-27 09:42:46');
INSERT INTO `sys_job_log` VALUES (131, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:47', '2025-04-27 09:42:47', '2025-04-27 09:42:47');
INSERT INTO `sys_job_log` VALUES (132, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:48', '2025-04-27 09:42:48', '2025-04-27 09:42:48');
INSERT INTO `sys_job_log` VALUES (133, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:49', '2025-04-27 09:42:49', '2025-04-27 09:42:49');
INSERT INTO `sys_job_log` VALUES (134, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:50', '2025-04-27 09:42:50', '2025-04-27 09:42:50');
INSERT INTO `sys_job_log` VALUES (135, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:51', '2025-04-27 09:42:51', '2025-04-27 09:42:51');
INSERT INTO `sys_job_log` VALUES (136, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:52', '2025-04-27 09:42:52', '2025-04-27 09:42:52');
INSERT INTO `sys_job_log` VALUES (137, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:53', '2025-04-27 09:42:53', '2025-04-27 09:42:53');
INSERT INTO `sys_job_log` VALUES (138, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:54', '2025-04-27 09:42:54', '2025-04-27 09:42:54');
INSERT INTO `sys_job_log` VALUES (139, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:55', '2025-04-27 09:42:55', '2025-04-27 09:42:55');
INSERT INTO `sys_job_log` VALUES (140, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:42:56', '2025-04-27 09:42:56', '2025-04-27 09:42:56');
INSERT INTO `sys_job_log` VALUES (141, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-04-27 09:44:34', '2025-04-27 09:44:34', '2025-04-27 09:44:34');
INSERT INTO `sys_job_log` VALUES (142, 2, '系统默认（有参）', 'DEFAULT', 'demoTask.ryParams(\'ry\')', '系统默认（有参） 总共耗时：0毫秒', '1', 'org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'demoTask\' available\r\n	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:893)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1318)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\r\n	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1156)\r\n	at com.mojian.utils.SpringUtil.getBean(SpringUtil.java:47)\r\n	at com.mojian.utils.JobInvokeUtils.invokeMethod(JobInvokeUtils.java:31)\r\n	at com.mojian.quartz.QuartzDisallowConcurrentExecution.doExecute(QuartzDisallowConcurrentExecution.java:15)\r\n	at com.mojian.quartz.AbstractQuartzJob.execute(AbstractQuartzJob.java:39)\r\n	at org.quartz.core.JobRunShell.run(JobRunShell.java:202)\r\n	at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573)\r\n', '2025-04-27 09:44:38', '2025-04-27 09:44:38', '2025-04-27 09:44:38');
INSERT INTO `sys_job_log` VALUES (143, 3, '系统默认（多参）', 'DEFAULT', 'demoTask.ryMultipleParams(\'ry\', true, 2000L, 316.50D, 100)', '系统默认（多参） 总共耗时：0毫秒', '1', 'org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'demoTask\' available\r\n	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:893)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1318)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\r\n	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1156)\r\n	at com.mojian.utils.SpringUtil.getBean(SpringUtil.java:47)\r\n	at com.mojian.utils.JobInvokeUtils.invokeMethod(JobInvokeUtils.java:31)\r\n	at com.mojian.quartz.QuartzDisallowConcurrentExecution.doExecute(QuartzDisallowConcurrentExecution.java:15)\r\n	at com.mojian.quartz.AbstractQuartzJob.execute(AbstractQuartzJob.java:39)\r\n	at org.quartz.core.JobRunShell.run(JobRunShell.java:202)\r\n	at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573)\r\n', '2025-04-27 09:44:44', '2025-04-27 09:44:44', '2025-04-27 09:44:44');
INSERT INTO `sys_job_log` VALUES (144, 11, 'test', 'DEFAULT', 'neatTask.neatParams(\'neat\')', 'test 总共耗时：0毫秒', '1', 'org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'neatTask\' available\r\n	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:893)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1318)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\r\n	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1156)\r\n	at com.mojian.utils.SpringUtil.getBean(SpringUtil.java:47)\r\n	at com.mojian.utils.JobInvokeUtils.invokeMethod(JobInvokeUtils.java:31)\r\n	at com.mojian.quartz.QuartzDisallowConcurrentExecution.doExecute(QuartzDisallowConcurrentExecution.java:15)\r\n	at com.mojian.quartz.AbstractQuartzJob.execute(AbstractQuartzJob.java:39)\r\n	at org.quartz.core.JobRunShell.run(JobRunShell.java:202)\r\n	at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573)\r\n', '2025-04-27 09:51:58', '2025-04-27 09:51:58', '2025-04-27 09:51:58');
INSERT INTO `sys_job_log` VALUES (145, 11, 'test', 'DEFAULT', 'neatTask.neatParams(\'neat\')', 'test 总共耗时：0毫秒', '1', 'org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'neatTask\' available\r\n	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:893)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1318)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\r\n	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1156)\r\n	at com.mojian.utils.SpringUtil.getBean(SpringUtil.java:47)\r\n	at com.mojian.utils.JobInvokeUtils.invokeMethod(JobInvokeUtils.java:31)\r\n	at com.mojian.quartz.QuartzDisallowConcurrentExecution.doExecute(QuartzDisallowConcurrentExecution.java:15)\r\n	at com.mojian.quartz.AbstractQuartzJob.execute(AbstractQuartzJob.java:39)\r\n	at org.quartz.core.JobRunShell.run(JobRunShell.java:202)\r\n	at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573)\r\n', '2025-04-27 09:52:26', '2025-04-27 09:52:26', '2025-04-27 09:52:26');
INSERT INTO `sys_job_log` VALUES (146, 11, 'test', 'DEFAULT', 'task.neatNoParams', 'test 总共耗时：0毫秒', '0', '', '2025-04-27 09:52:37', '2025-04-27 09:52:37', '2025-04-27 09:52:37');
INSERT INTO `sys_job_log` VALUES (147, 12, '定时更新阅读量', 'DEFAULT', 'task.syncQuantity', '定时更新阅读量 总共耗时：-82毫秒', '0', '', '2025-04-27 09:53:53', '2025-04-27 09:53:53', '2025-04-27 09:53:53');
INSERT INTO `sys_job_log` VALUES (148, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：-2毫秒', '0', '', '2025-05-29 17:56:06', '2025-05-29 17:56:06', '2025-05-29 17:56:06');
INSERT INTO `sys_job_log` VALUES (149, 1, '系统默认（无参）', 'DEFAULT', 'task.neatNoParams', '系统默认（无参） 总共耗时：0毫秒', '0', '', '2025-05-29 17:56:21', '2025-05-29 17:56:21', '2025-05-29 17:56:21');

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `parent_id` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '上级资源ID',
  `path` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '路由路径',
  `component` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '组件路径',
  `title` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '菜单名称',
  `sort` int NULL DEFAULT 0 COMMENT '排序',
  `icon` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '资源图标',
  `type` varchar(32) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '类型 menu、button',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `redirect` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '重定向地址',
  `name` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '跳转地址',
  `hidden` int NULL DEFAULT NULL COMMENT '是否隐藏',
  `perm` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '权限标识',
  `is_external` int NULL DEFAULT 0 COMMENT '是否外链 0:否  1:是',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 141 CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci COMMENT = '权限资源表 ' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES (1, '0', '/system', 'Layout', '系统管理', 4, 'Setting', 'CATALOG', '2019-03-28 18:51:08', '2021-12-17 15:26:06', '/system/user', '', 0, NULL, 0);
INSERT INTO `sys_menu` VALUES (2, '1', 'role', '/system/role/index', '角色管理', 2, 'Avatar', 'MENU', '2019-03-30 14:00:03', '2021-11-16 15:40:42', '', '', 0, NULL, 0);
INSERT INTO `sys_menu` VALUES (3, '2', NULL, NULL, '角色列表', 1, '', 'BUTTON', NULL, '2024-11-18 17:56:16', '', NULL, 1, 'system:role', 0);
INSERT INTO `sys_menu` VALUES (4, '0', '/monitor', 'Layout', '监控中心', 5, 'Monitor', 'CATALOG', NULL, '2024-11-17 21:38:25', '/monitor/server', '', 0, NULL, 0);
INSERT INTO `sys_menu` VALUES (7, '6', '', '', '新增', 1, '', 'BUTTON', NULL, '2024-11-16 14:18:24', NULL, '', 1, 'a:b:add', 0);
INSERT INTO `sys_menu` VALUES (8, '2', '', '', '新增角色', 1, '', 'BUTTON', NULL, '2024-11-21 22:16:56', NULL, '', 1, 'sys:role:add', 0);
INSERT INTO `sys_menu` VALUES (9, '1', 'dict', '/system/dict/index', '字典管理', 3, 'Memo', 'MENU', '2024-11-17 21:29:51', '2024-11-17 21:39:06', NULL, '', 0, NULL, 0);
INSERT INTO `sys_menu` VALUES (10, '9', '', '', '新增字典', 1, '', 'BUTTON', '2024-11-17 21:30:23', NULL, NULL, '', 1, 'sys:dict:add', 0);
INSERT INTO `sys_menu` VALUES (11, '9', '', '', '修改字典', 2, '', 'BUTTON', '2024-11-17 21:32:34', '2024-11-18 18:01:35', NULL, '', 1, 'sys:dict:update', 0);
INSERT INTO `sys_menu` VALUES (12, '9', '', '', '删除字典', 3, '', 'BUTTON', '2024-11-17 21:34:33', '2024-11-17 21:39:11', NULL, '', 1, 'sys:dict:delete', 0);
INSERT INTO `sys_menu` VALUES (13, '1', 'menu', '/system/menu/index', '菜单管理', 5, 'Menu', 'MENU', NULL, '2021-11-18 11:26:00', '', 'menu', 0, NULL, 0);
INSERT INTO `sys_menu` VALUES (14, '1', 'user', '/system/user/index', '用户管理', 1, 'User', 'MENU', '2024-11-18 01:10:52', '2024-11-18 01:11:13', NULL, '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (16, '4', 'server', '/monitor/server/index', '服务监控', 1, 'Crop', 'MENU', '2024-11-18 01:18:12', '2024-11-18 01:20:27', NULL, '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (17, '4', 'cache', '/monitor/cache/index', '缓存监控', 2, 'Coin', 'MENU', '2024-11-18 06:56:49', NULL, NULL, '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (18, '4', 'job', '/monitor/job/index', '定时任务', 3, 'AlarmClock', 'MENU', '2024-11-18 06:57:38', NULL, NULL, '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (19, '4', 'job-log', '/monitor/job/log', '调度日志', 4, 'Document', 'MENU', '2024-11-18 06:58:43', '2024-11-18 06:58:55', NULL, '', 1, '', 0);
INSERT INTO `sys_menu` VALUES (27, '14', '', '', '新增用户', 2, '', 'BUTTON', '2024-11-18 09:18:14', '2024-11-21 22:15:30', NULL, '', 1, 'sys:user:add', 0);
INSERT INTO `sys_menu` VALUES (28, '14', '', '', '编辑用户', 2, '', 'BUTTON', '2024-11-18 09:18:38', '2024-11-21 14:38:56', NULL, '', 1, 'sys:user:update', 0);
INSERT INTO `sys_menu` VALUES (29, '14', '', '', '删除用户', 3, '', 'BUTTON', '2024-11-18 09:18:53', '2024-11-21 22:15:43', NULL, '', 1, 'sys:user:delete', 0);
INSERT INTO `sys_menu` VALUES (30, '0', '/tool', 'Layout', '系统工具', 6, 'Suitcase', 'CATALOG', '2024-11-18 09:21:10', '2024-11-18 12:23:55', '/tool/gen', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (31, '30', 'gen', '/tool/gen/index', '代码生成', 1, 'Compass', 'MENU', '2024-11-18 09:21:52', NULL, NULL, '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (32, '1', 'log', '', '日志管理', 5, 'DocumentCopy', 'MENU', '2024-11-18 10:52:47', '2024-11-18 10:58:00', '/system/log/operation', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (33, '32', 'operation', '/system/log/operation/index', '操作日志', 1, 'CircleCheckFilled', 'MENU', '2024-11-18 10:53:10', '2024-11-18 11:05:22', NULL, '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (39, '14', '', '', '用户列表', 1, '', 'BUTTON', '2024-11-18 17:54:15', '2024-11-21 22:07:33', '', '', 1, 'sys:user', 0);
INSERT INTO `sys_menu` VALUES (40, '2', '', '', '修改角色', 2, '', 'BUTTON', '2024-11-18 17:56:10', '2024-11-21 22:04:52', '', '', 1, 'sys:role:update', 0);
INSERT INTO `sys_menu` VALUES (41, '2', '', '', '删除角色', 3, '', 'BUTTON', '2024-11-18 17:56:34', '2024-11-21 22:17:17', '', NULL, 1, 'sys:role:delete', 0);
INSERT INTO `sys_menu` VALUES (43, '2', '', '', '分配权限', 5, '', 'BUTTON', '2024-11-18 17:57:28', NULL, '', NULL, 1, 'sys:role:menus', 0);
INSERT INTO `sys_menu` VALUES (44, '9', '', '', '批量删除', 4, '', 'BUTTON', '2024-11-18 17:58:16', '2024-11-21 22:07:06', '', '', 1, 'sys:dict:deleteBatch', 0);
INSERT INTO `sys_menu` VALUES (48, '13', '', '', '添加菜单', 1, '', 'BUTTON', '2024-11-18 17:56:58', NULL, '', NULL, 1, 'sys:menu:add', 0);
INSERT INTO `sys_menu` VALUES (49, '13', '', '', '修改菜单', 2, '', 'BUTTON', '2024-11-18 17:56:58', NULL, '', NULL, 1, 'sys:menu:update', 0);
INSERT INTO `sys_menu` VALUES (50, '13', '', '', '删除菜单', 3, '', 'BUTTON', '2024-11-21 21:55:49', NULL, '', '', 1, 'sys:menu:delete', 0);
INSERT INTO `sys_menu` VALUES (51, '13', '', '', '菜单列表', 1, '', 'BUTTON', '2024-11-21 21:58:29', NULL, '', '', 1, 'sys:menu', 0);
INSERT INTO `sys_menu` VALUES (52, '14', '', '', '重置密码', 5, '', 'BUTTON', '2024-11-21 22:00:30', NULL, '', '', 1, 'sys:user:reset', 0);
INSERT INTO `sys_menu` VALUES (53, '9', '', '', '字典列表', 1, '', 'BUTTON', '2024-11-18 17:58:16', NULL, '', '', 1, 'sys:dict', 0);
INSERT INTO `sys_menu` VALUES (54, '1', 'profile', '/system/user/profile/index', '个人中心', 99, 'Avatar', 'MENU', '2024-11-21 22:12:18', '2024-11-21 22:12:46', '', '', 1, '', 0);
INSERT INTO `sys_menu` VALUES (55, '33', '', '', '操作日志列表', 1, '', 'BUTTON', '2024-11-18 10:53:10', '2024-11-18 11:05:22', '', '', 1, 'sys:operateLog', 0);
INSERT INTO `sys_menu` VALUES (56, '33', '', '', '删除操作日志', 2, '', 'BUTTON', '2024-11-18 10:53:10', '2024-11-18 11:05:22', '', '', 1, 'sys:operateLog:delete', 0);
INSERT INTO `sys_menu` VALUES (58, '18', '', '', '定时任务列表', 3, '', 'BUTTON', '2024-11-18 17:56:58', '2024-11-21 22:04:42', '', NULL, 1, 'sys:job', 0);
INSERT INTO `sys_menu` VALUES (59, '18', '', '', '添加定时任务', 2, '', 'BUTTON', '2024-11-18 17:56:58', '2024-11-21 22:04:42', '', NULL, 1, 'sys:job:add', 0);
INSERT INTO `sys_menu` VALUES (60, '18', '', '', '修改定时任务', 1, '', 'BUTTON', '2024-11-18 17:56:58', '2024-11-21 22:04:42', '', NULL, 1, 'sys:job:update', 0);
INSERT INTO `sys_menu` VALUES (61, '18', '', '', '删除定时任务', 4, '', 'BUTTON', '2024-11-18 17:56:58', '2024-11-21 22:04:42', '', NULL, 1, 'sys:job:delete', 0);
INSERT INTO `sys_menu` VALUES (62, '18', '', '', '修改任务状态', 1, '', 'BUTTON', '2024-11-18 17:56:58', '2024-11-21 22:04:42', '', NULL, 0, 'sys:job:changeStatus', 0);
INSERT INTO `sys_menu` VALUES (63, '19', '', '', '删除定时任务日志', 1, '', 'BUTTON', '2024-11-21 22:26:56', NULL, '', '', 1, 'sys:jobLog:delete', 0);
INSERT INTO `sys_menu` VALUES (64, '19', '', '', '清空定时任务日志', 2, '', 'BUTTON', '2024-11-21 22:27:09', NULL, '', '', 1, 'sys:jobLog:clean', 0);
INSERT INTO `sys_menu` VALUES (65, '18', '', '', '批量删除定时任务', 1, '', 'BUTTON', '2024-11-21 22:37:01', '2024-11-21 22:38:05', '', '', 1, 'sys:job:deleteBatch', 0);
INSERT INTO `sys_menu` VALUES (66, '19', '', '', '定时任务日志列表', 1, '', 'BUTTON', '2024-11-21 23:09:47', NULL, '', '', 1, 'sys:jobLog', 0);
INSERT INTO `sys_menu` VALUES (67, '4', 'online', '/monitor/online/index', '在线用户', 4, 'Avatar', 'MENU', '2024-12-03 12:40:41', NULL, '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (68, '0', '/article', 'Layout', '文章管理', 1, 'Document', 'CATALOG', '2024-12-22 10:49:22', '2024-12-22 10:49:37', '/article/index', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (69, '68', 'tag', '/article/tag/index', '标签管理', 2, 'PriceTag', 'MENU', '2024-12-22 10:49:22', '2024-12-22 10:49:37', '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (70, '68', 'category', '/article/category/index', '分类管理', 2, 'Dessert', 'MENU', '2024-12-22 10:49:22', '2024-12-22 10:49:37', '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (71, '68', 'index', '/article/article/index', '文章管理', 1, 'DocumentRemove', 'MENU', '2024-12-25 13:47:27', NULL, '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (72, '0', '/site', 'Layout', '站点管理', 2, 'DeleteLocation', 'CATALOG', '2024-12-25 16:13:03', '2024-12-25 16:13:33', '/site/config', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (73, '72', 'friend', '/site/friend/index', '友链管理', 2, 'ChromeFilled', 'MENU', '2024-12-25 16:17:24', NULL, '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (74, '72', 'config', '/site/config/index', '网站配置', 1, 'AddLocation', 'MENU', '2024-12-25 16:35:39', NULL, '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (75, '71', '', '', '文章列表', 1, '', 'BUTTON', '2024-12-28 22:02:24', NULL, '', '', 1, 'sys:article:list', 0);
INSERT INTO `sys_menu` VALUES (76, '71', '', '', '新增文章', 2, '', 'BUTTON', '2024-12-28 22:02:24', NULL, '', '', 1, 'sys:article:add', 0);
INSERT INTO `sys_menu` VALUES (77, '71', '', '', '修改文章', 3, '', 'BUTTON', '2024-12-28 22:02:24', NULL, '', '', 1, 'sys:article:update', 0);
INSERT INTO `sys_menu` VALUES (78, '71', '', '', '修改状态', 4, '', 'BUTTON', '2024-12-28 22:02:24', NULL, '', '', 1, 'sys:article:updateStatus', 0);
INSERT INTO `sys_menu` VALUES (79, '71', '', '', '删除文章', 2, '', 'BUTTON', '2024-12-28 22:02:24', NULL, '', '', 1, 'sys:article:delete', 0);
INSERT INTO `sys_menu` VALUES (80, '69', '', '', '标签列表', 1, '', 'BUTTON', '2024-12-28 22:05:25', NULL, '', '', 1, 'sys:tag:list', 0);
INSERT INTO `sys_menu` VALUES (81, '69', '', '', '新增标签', 2, '', 'BUTTON', '2024-12-28 22:05:59', NULL, '', '', 1, 'sys:tag:add', 0);
INSERT INTO `sys_menu` VALUES (82, '69', '', '', '修改标签', 3, '', 'BUTTON', '2024-12-28 22:06:26', NULL, '', '', 1, 'sys:tag:update', 0);
INSERT INTO `sys_menu` VALUES (83, '69', '', '', '删除标签', 4, '', 'BUTTON', '2024-12-28 22:06:40', NULL, '', '', 1, 'sys:tag:delete', 0);
INSERT INTO `sys_menu` VALUES (84, '70', '', '', '分类列表', 1, '', 'BUTTON', '2024-12-28 22:07:27', NULL, '', '', 1, 'sys:category:list', 0);
INSERT INTO `sys_menu` VALUES (85, '70', '', '', '新增分类', 2, '', 'BUTTON', '2024-12-28 22:07:40', NULL, '', '', 1, 'sys:category:add', 0);
INSERT INTO `sys_menu` VALUES (86, '70', '', '', '修改分类', 3, '', 'BUTTON', '2024-12-28 22:07:58', NULL, '', '', 1, 'sys:category:update', 0);
INSERT INTO `sys_menu` VALUES (87, '70', '', '', '删除分类', 4, '', 'BUTTON', '2024-12-28 22:08:11', NULL, '', '', 1, 'sys:category:delete', 0);
INSERT INTO `sys_menu` VALUES (88, '74', '', '', '网站列表', 1, '', 'BUTTON', '2024-12-28 22:09:06', NULL, '', '', 1, 'sys:web:config', 0);
INSERT INTO `sys_menu` VALUES (89, '74', '', '', '修改配置', 2, '', 'BUTTON', '2024-12-28 22:09:21', NULL, '', '', 1, 'sys:web:update', 0);
INSERT INTO `sys_menu` VALUES (90, '73', '', '', '友链列表', 1, '', 'BUTTON', '2024-12-28 22:10:26', NULL, '', '', 1, 'sys:friend:list', 0);
INSERT INTO `sys_menu` VALUES (91, '73', '', '', '新增友链', 2, '', 'BUTTON', '2024-12-28 22:10:41', NULL, '', '', 1, 'sys:friend:add', 0);
INSERT INTO `sys_menu` VALUES (92, '73', '', '', '修改友链', 3, '', 'BUTTON', '2024-12-28 22:11:09', NULL, '', '', 1, 'sys:friend:update', 0);
INSERT INTO `sys_menu` VALUES (93, '73', '', '', '删除友链', 4, '', 'BUTTON', '2024-12-28 22:11:21', NULL, '', '', 1, 'sys:friend:delete', 0);
INSERT INTO `sys_menu` VALUES (94, '17', '', '', '清空缓存', 2, '', 'BUTTON', '2024-12-28 22:22:54', NULL, '', '', 1, 'monitor:cache', 0);
INSERT INTO `sys_menu` VALUES (95, '17', '', '', '缓存信息', 1, '', 'BUTTON', '2024-12-28 22:23:36', NULL, '', '', 1, 'monitor:cache:info', 0);
INSERT INTO `sys_menu` VALUES (96, '0', '/comment', 'Layout', '消息管理', 3, 'ChatDotSquare', 'CATALOG', '2025-01-02 09:49:06', NULL, '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (97, '96', 'comment', '/message/comment/index', '评论管理', 1, 'ChatDotRound', 'MENU', '2024-12-22 10:49:22', '2024-12-22 10:49:37', '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (98, '97', '', '', '评论列表', 1, '', 'BUTTON', '2025-01-02 09:58:33', NULL, '', '', 1, 'sys:comment:list', 0);
INSERT INTO `sys_menu` VALUES (99, '97', '', '', '删除评论', 2, '', 'BUTTON', '2025-01-02 09:58:50', NULL, '', '', 1, 'sys:comment:delete', 0);
INSERT INTO `sys_menu` VALUES (100, '96', 'message', '/message/message/index', '留言管理', 2, 'ChatLineSquare', 'MENU', '2025-01-02 10:07:04', NULL, '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (101, '100', '', '', '留言列表', 1, '', 'BUTTON', '2025-01-02 10:12:14', NULL, '', '', 1, 'sys:message:list', 0);
INSERT INTO `sys_menu` VALUES (102, '100', '', '', '删除留言', 2, '', 'BUTTON', '2025-01-02 10:22:06', NULL, '', '', 1, 'sys:message:delete', 0);
INSERT INTO `sys_menu` VALUES (103, '71', '', '', '爬取文章', 6, '', 'BUTTON', '2025-01-02 16:34:53', NULL, '', '', 1, 'sys:article:reptile', 0);
INSERT INTO `sys_menu` VALUES (104, '67', '', '', '列表', 1, '', 'BUTTON', '2025-01-03 15:53:46', NULL, '', '', 1, 'monitor:online:list', 0);
INSERT INTO `sys_menu` VALUES (105, '67', '', '', '强退', 2, '', 'BUTTON', '2025-01-03 15:54:03', NULL, '', '', 1, 'monitor:online:forceLogout', 0);
INSERT INTO `sys_menu` VALUES (106, '96', 'feedback', '/message/feedback/index', '反馈管理', 3, 'Checked', 'MENU', '2025-01-12 11:23:23', NULL, '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (107, '106', '', '', '列表', 1, '', 'BUTTON', '2025-01-12 12:30:48', '2025-01-12 12:31:51', '', '', 1, 'sys:feedback:list', 0);
INSERT INTO `sys_menu` VALUES (108, '106', '', '', '修改', 2, '', 'BUTTON', '2025-01-12 12:31:00', '2025-01-12 12:31:55', '', '', 1, 'sys:feedback:update', 0);
INSERT INTO `sys_menu` VALUES (109, '106', '', '', '删除', 3, '', 'BUTTON', '2025-01-12 12:31:14', '2025-01-12 12:31:19', '', '', 1, 'sys:feedback:delete', 0);
INSERT INTO `sys_menu` VALUES (110, '68', '/moments', '/article/moment/index', '说说管理', 4, 'ChatDotRound', 'MENU', '2025-02-06 10:22:22', NULL, '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (111, '110', '', '', '新增', 1, '', 'BUTTON', '2025-02-06 10:32:06', NULL, '', '', 1, 'sys:moment:add', 0);
INSERT INTO `sys_menu` VALUES (112, '110', '', '', '修改', 2, '', 'BUTTON', '2025-02-06 10:32:20', NULL, '', '', 1, 'sys:moment:update', 0);
INSERT INTO `sys_menu` VALUES (113, '110', '', '', '删除', 3, '', 'BUTTON', '2025-02-06 10:32:37', NULL, '', '', 1, 'sys:moment:delete', 0);
INSERT INTO `sys_menu` VALUES (114, '72', '/album', '/site/album/index', '相册管理', 1, 'CreditCard', 'MENU', '2025-02-07 10:49:51', '2025-02-07 10:50:23', '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (115, '114', '', '', '列表', 1, '', 'BUTTON', '2025-02-07 15:08:50', NULL, '', '', 1, 'sys:album:list', 0);
INSERT INTO `sys_menu` VALUES (116, '114', '', '', '新增', 2, '', 'BUTTON', '2025-02-07 15:09:03', NULL, '', '', 1, 'sys:album:add', 0);
INSERT INTO `sys_menu` VALUES (117, '114', '', '', '修改', 3, '', 'BUTTON', '2025-02-07 15:09:30', NULL, '', '', 1, 'sys:album:update', 0);
INSERT INTO `sys_menu` VALUES (118, '114', '', '', '删除', 4, '', 'BUTTON', '2025-02-07 15:09:53', NULL, '', '', 1, 'sys:album:delete', 0);
INSERT INTO `sys_menu` VALUES (119, '114', '', '', '新增照片', 5, '', 'BUTTON', '2025-02-07 15:10:39', NULL, '', '', 1, 'sys:photo:add', 0);
INSERT INTO `sys_menu` VALUES (120, '114', '', '', '修改照片', 6, '', 'BUTTON', '2025-02-07 15:10:55', NULL, '', '', 1, 'sys:photo:update', 0);
INSERT INTO `sys_menu` VALUES (121, '114', '', '', '删除照片', 7, '', 'BUTTON', '2025-02-07 15:11:18', NULL, '', '', 1, 'sys:photo:delete', 0);
INSERT INTO `sys_menu` VALUES (122, '114', '', '', '移动照片', 8, '', 'BUTTON', '2025-02-07 15:11:38', NULL, '', '', 1, 'sys:photo:move', 0);
INSERT INTO `sys_menu` VALUES (123, '72', '/notice', '/site/notice/index', '公告管理', 4, 'AlarmClock', 'MENU', '2024-12-25 16:13:03', '2024-12-25 16:13:33', '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (124, '123', '', '', '列表', 1, '', 'BUTTON', '2025-02-11 16:32:27', NULL, '', '', 1, 'sys:notice:list', 0);
INSERT INTO `sys_menu` VALUES (125, '123', '', '', '新增', 2, '', 'BUTTON', '2025-02-11 16:32:37', NULL, '', '', 1, 'sys:notice:add', 0);
INSERT INTO `sys_menu` VALUES (126, '123', '', '', '修改', 3, '', 'BUTTON', '2025-02-11 16:32:49', NULL, '', '', 0, 'sys:notice:update', 0);
INSERT INTO `sys_menu` VALUES (127, '123', '', '', '删除', 4, '', 'BUTTON', '2025-02-11 16:33:01', NULL, '', '', 1, 'sys:notice:delete', 0);
INSERT INTO `sys_menu` VALUES (128, '1', '/file', '/system/file/index', '文件管理', 6, 'Folder', 'MENU', '2025-02-13 16:01:54', NULL, '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (129, '128', '', '', '列表', 1, '', 'BUTTON', '2025-02-13 17:04:56', NULL, '', '', 1, 'sys:file:list', 0);
INSERT INTO `sys_menu` VALUES (130, '128', '', '', '删除', 2, '', 'BUTTON', '2025-02-13 17:05:09', NULL, '', '', 1, 'sys:file:delete', 0);
INSERT INTO `sys_menu` VALUES (131, '128', '', '', '保存oss配置', 2, '', 'BUTTON', '2025-02-13 17:05:09', NULL, '', '', 1, 'sys:oss:submit', 0);
INSERT INTO `sys_menu` VALUES (136, '1', '/config', '/system/config/index', '参数管理', 4, 'Film', 'MENU', '2025-03-19 15:56:07', NULL, '', '', 0, '', 0);
INSERT INTO `sys_menu` VALUES (137, '136', '', '', '列表', 1, '', 'BUTTON', '2025-03-19 16:55:57', NULL, '', '', 1, 'sys:config:list', 0);
INSERT INTO `sys_menu` VALUES (138, '136', '', '', '添加', 2, '', 'BUTTON', '2025-03-19 16:56:09', NULL, '', '', 1, 'sys:config:add', 0);
INSERT INTO `sys_menu` VALUES (139, '136', '', '', '修改', 3, '', 'BUTTON', '2025-03-19 16:56:20', NULL, '', '', 1, 'sys:config:update', 0);
INSERT INTO `sys_menu` VALUES (140, '136', '', '', '删除', 4, '', 'BUTTON', '2025-03-19 16:56:34', NULL, '', '', 1, 'sys:config:delete', 0);

-- ----------------------------
-- Table structure for sys_message
-- ----------------------------
DROP TABLE IF EXISTS `sys_message`;
CREATE TABLE `sys_message`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '头像',
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '内容',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'IP地址',
  `source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'IP来源',
  `browser` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '浏览器',
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1437 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '留言' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_message
-- ----------------------------
INSERT INTO `sys_message` VALUES (1423, '游客', 'img/logo.jpeg', '伟大', '127.0.0.1', '内网IP|内网IP', NULL, '2025-04-26 02:53:00');
INSERT INTO `sys_message` VALUES (1424, '游客', 'img/logo.jpeg', '发发哇', '127.0.0.1', '内网IP|内网IP', NULL, '2025-04-26 15:28:17');
INSERT INTO `sys_message` VALUES (1425, '游客', 'img/logo.jpeg', '个啊啊', '127.0.0.1', '内网IP|内网IP', NULL, '2025-04-28 17:53:05');
INSERT INTO `sys_message` VALUES (1426, '游客', 'img/logo.jpeg', '嗨嗨嗨', '127.0.0.1', '内网IP|内网IP', NULL, '2025-04-29 10:49:08');
INSERT INTO `sys_message` VALUES (1427, '游客', 'img/logo.jpeg', '啊偶哈', '127.0.0.1', '内网IP|内网IP', NULL, '2025-04-29 16:33:19');
INSERT INTO `sys_message` VALUES (1428, '码云星链', 'img/logo.jpeg', '1111', '127.0.0.1', '内网IP|内网IP', NULL, '2025-04-29 16:50:54');
INSERT INTO `sys_message` VALUES (1429, '游客', 'img/logo.jpeg', '111', '127.0.0.1', '内网IP|内网IP', NULL, '2025-04-29 16:53:47');
INSERT INTO `sys_message` VALUES (1430, '游客', 'img/logo.jpeg', '11', '220.162.58.13', '中国|福建省|泉州市|电信', NULL, '2025-05-08 15:38:18');
INSERT INTO `sys_message` VALUES (1431, '码云星链', 'https://ss0.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1152107840,119779555&fm=253&gp=0.jpg', 'yyds', '113.45.240.54', '中国|北京|北京市|鹏博士', NULL, '2025-05-10 13:31:05');
INSERT INTO `sys_message` VALUES (1432, '游客', 'https://api.dicebear.com/7.x/avataaars/svg?seed=Guest', 'i 不错哦', '113.45.240.54', '中国|北京|北京市|鹏博士', NULL, '2025-05-14 22:40:35');
INSERT INTO `sys_message` VALUES (1433, '游客', 'https://api.dicebear.com/7.x/avataaars/svg?seed=Guest', '我是刘姐，到此一游', '113.45.240.54', '中国|北京|北京市|鹏博士', NULL, '2025-05-19 11:24:24');
INSERT INTO `sys_message` VALUES (1434, '游客', 'https://api.dicebear.com/7.x/avataaars/svg?seed=Guest', '我是永劫无间，到此一游', '113.45.240.54', '中国|北京|北京市|鹏博士', NULL, '2025-05-19 11:24:58');
INSERT INTO `sys_message` VALUES (1436, '游客', NULL, '111', '120.32.140.89', '中国|福建省|厦门市|电信', NULL, '2025-06-25 00:03:42');

-- ----------------------------
-- Table structure for sys_moment
-- ----------------------------
DROP TABLE IF EXISTS `sys_moment`;
CREATE TABLE `sys_moment`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` bigint NULL DEFAULT NULL COMMENT '用户id',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '文章内容',
  `images` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '图片',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 27 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '说说' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_moment
-- ----------------------------
INSERT INTO `sys_moment` VALUES (2, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (15, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (16, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (17, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (18, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (19, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (20, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (21, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (22, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (23, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (24, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (25, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');
INSERT INTO `sys_moment` VALUES (26, 1, '<h1>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</h1><p>fegagggggggggg</p>', 'img/logo.jpeg', '2025-04-26 03:01:27');

-- ----------------------------
-- Table structure for sys_notice
-- ----------------------------
DROP TABLE IF EXISTS `sys_notice`;
CREATE TABLE `sys_notice`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '公告内容',
  `is_show` int NULL DEFAULT NULL COMMENT '是否展示',
  `position` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '显示位置 （top：顶部，right:右侧）',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '公告' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_notice
-- ----------------------------
INSERT INTO `sys_notice` VALUES (2, '欢迎来到码云星链博客网站', 1, 'right', '2025-04-27 17:47:11');

-- ----------------------------
-- Table structure for sys_notifications
-- ----------------------------
DROP TABLE IF EXISTS `sys_notifications`;
CREATE TABLE `sys_notifications`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '通知的唯一标识，自增主键',
  `user_id` bigint NULL DEFAULT NULL COMMENT '推送用户id',
  `from_user_id` bigint NULL DEFAULT NULL COMMENT '来自用户id,如评论就存评论的用户id',
  `type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '通知的类型，如 system、comment、like 等',
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '通知的标题',
  `message` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '通知的具体内容',
  `is_read` tinyint(1) NOT NULL DEFAULT 0 COMMENT '标记通知是否已读，0 表示未读，1 表示已读',
  `article_id` bigint NULL DEFAULT NULL COMMENT '文章id',
  `link` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '跳转链接',
  `create_time` datetime NOT NULL COMMENT '通知的创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 22 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '消息通知表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_notifications
-- ----------------------------
INSERT INTO `sys_notifications` VALUES (1, 1, 1811, 'comment', '新评论通知', '哈哈哈哈哈哈哈哈哈', 1, 332, NULL, '2025-04-28 17:54:56');
INSERT INTO `sys_notifications` VALUES (2, 1811, 1811, 'comment', '评论回复通知', '***袜带', 1, 332, NULL, '2025-04-28 17:55:04');
INSERT INTO `sys_notifications` VALUES (3, 1, 1811, 'comment', '新评论通知', '订单创建失败<div>快修</div>', 1, 298, NULL, '2025-04-28 17:59:23');
INSERT INTO `sys_notifications` VALUES (4, 1, 1811, 'comment', '新评论通知', '<img src=\"https://baidubox-emoji.cdn.bcebos.com/imgs/[亲吻].png\" class=\"emoji\" style=\"width: 30px; height: 30px; vertical-align: middle;\">', 1, 326, NULL, '2025-04-28 18:11:32');
INSERT INTO `sys_notifications` VALUES (5, 1811, 1811, 'comment', '评论回复通知', '<img src=\"https://baidubox-emoji.cdn.bcebos.com/imgs/[滑稽].png\" class=\"emoji\" style=\"width: 22px; height: 22px; vertical-align: middle;\">', 0, 326, NULL, '2025-04-28 18:11:47');
INSERT INTO `sys_notifications` VALUES (6, 1, 1, 'comment', '新评论通知', '1111', 0, 296, NULL, '2025-04-29 16:44:10');
INSERT INTO `sys_notifications` VALUES (7, 1, 1, 'comment', '新评论通知', '11111', 0, 296, NULL, '2025-04-29 16:44:17');
INSERT INTO `sys_notifications` VALUES (8, 1, 1, 'comment', '新评论通知', '11111', 0, 296, NULL, '2025-04-29 16:44:22');
INSERT INTO `sys_notifications` VALUES (9, 1, 1, 'comment', '新评论通知', '111111111', 0, 296, NULL, '2025-04-29 16:44:28');
INSERT INTO `sys_notifications` VALUES (10, 1, 1, 'comment', '新评论通知', '1111111', 0, 296, NULL, '2025-04-29 16:44:33');
INSERT INTO `sys_notifications` VALUES (11, 1, 1, 'comment', '新评论通知', '111111111', 0, 296, NULL, '2025-04-29 16:44:39');
INSERT INTO `sys_notifications` VALUES (12, 1, 1, 'comment', '新评论通知', '1111111', 0, 296, NULL, '2025-04-29 16:44:46');
INSERT INTO `sys_notifications` VALUES (13, 1, 1, 'comment', '新评论通知', '111111', 0, 296, NULL, '2025-04-29 16:44:52');
INSERT INTO `sys_notifications` VALUES (14, 1, 1, 'comment', '新评论通知', '111111', 0, 296, NULL, '2025-04-29 16:44:57');
INSERT INTO `sys_notifications` VALUES (15, 1, 1, 'comment', '新评论通知', '11111111', 0, 296, NULL, '2025-04-29 16:45:02');
INSERT INTO `sys_notifications` VALUES (16, 1, 1, 'comment', '新评论通知', '111111111', 0, 296, NULL, '2025-04-29 16:45:08');
INSERT INTO `sys_notifications` VALUES (17, 1, 1, 'comment', '评论回复通知', '1111', 0, 296, NULL, '2025-04-29 16:45:16');
INSERT INTO `sys_notifications` VALUES (18, 1, 1811, 'comment', '新评论通知', '111', 0, 331, NULL, '2025-04-29 21:27:05');
INSERT INTO `sys_notifications` VALUES (19, 1, 1, 'comment', '评论回复通知', '1', 0, 296, NULL, '2025-04-30 00:15:21');
INSERT INTO `sys_notifications` VALUES (20, 1, 2, 'comment', '新评论通知', '11', 0, 331, NULL, '2025-05-09 00:13:38');
INSERT INTO `sys_notifications` VALUES (21, 1, 4, 'comment', '新评论通知', '111', 0, 329, NULL, '2025-05-10 13:30:40');

-- ----------------------------
-- Table structure for sys_operate_log
-- ----------------------------
DROP TABLE IF EXISTS `sys_operate_log`;
CREATE TABLE `sys_operate_log`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作用户',
  `request_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '请求接口',
  `type` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '请求方式',
  `operation_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作名称',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip',
  `source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `spend_time` bigint NULL DEFAULT NULL COMMENT '请求接口耗时',
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `params_json` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '请求参数',
  `class_path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '类地址',
  `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '方法名',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2270 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_operate_log
-- ----------------------------
INSERT INTO `sys_operate_log` VALUES (2249, 'admin', '/sys/role', 'POST', '新增角色', '127.0.0.1', '内网IP|内网IP', 145, '2025-04-27 09:01:59', '{\"role\":{\"id\":20,\"code\":\"1\",\"name\":\"1\",\"remarks\":\"\",\"createTime\":1731731340000,\"updateTime\":1731731340000}}', 'com.mojian.controller.system.SysRoleController', 'addRole');
INSERT INTO `sys_operate_log` VALUES (2250, 'admin', '/sys/role', 'PUT', '修改角色', '127.0.0.1', '内网IP|内网IP', 92, '2025-04-27 09:02:06', '{\"role\":{\"id\":20,\"code\":\"1\",\"name\":\"1\",\"remarks\":\"1\",\"createTime\":1731731340000,\"updateTime\":1731731340000}}', 'com.mojian.controller.system.SysRoleController', 'updateRole');
INSERT INTO `sys_operate_log` VALUES (2251, 'admin', '/sys/user', 'POST', '新增用户', '127.0.0.1', '内网IP|内网IP', 253, '2025-04-27 09:04:46', '{\"sysUserAddDto\":{\"user\":{\"id\":1811,\"username\":\"111\",\"password\":\"$2a$10$7hTMqMROhxun7iBkAHARguqIP4o0AVQYhOWGb765DY5akg61LfTMC\",\"status\":1,\"nickname\":\"111\",\"mobile\":\"\",\"email\":\"\",\"sex\":0,\"createTime\":1745715885963},\"roleIds\":[14]}}', 'com.mojian.controller.system.SysUserController', 'addUser');
INSERT INTO `sys_operate_log` VALUES (2252, 'admin', '/monitor/job/changeStatus', 'PUT', '修改任务状态', '127.0.0.1', '内网IP|内网IP', 116, '2025-04-27 09:41:59', '{\"job\":{\"jobId\":1,\"status\":\"0\"}}', 'com.mojian.controller.SysJobController', 'changeStatus');
INSERT INTO `sys_operate_log` VALUES (2253, 'admin', '/monitor/job/changeStatus', 'PUT', '修改任务状态', '127.0.0.1', '内网IP|内网IP', 108, '2025-04-27 09:42:00', '{\"job\":{\"jobId\":2,\"status\":\"0\"}}', 'com.mojian.controller.SysJobController', 'changeStatus');
INSERT INTO `sys_operate_log` VALUES (2254, 'admin', '/monitor/job/changeStatus', 'PUT', '修改任务状态', '127.0.0.1', '内网IP|内网IP', 106, '2025-04-27 09:42:00', '{\"job\":{\"jobId\":3,\"status\":\"0\"}}', 'com.mojian.controller.SysJobController', 'changeStatus');
INSERT INTO `sys_operate_log` VALUES (2255, 'admin', '/monitor/job/changeStatus', 'PUT', '修改任务状态', '127.0.0.1', '内网IP|内网IP', 108, '2025-04-27 09:42:57', '{\"job\":{\"jobId\":1,\"status\":\"1\"}}', 'com.mojian.controller.SysJobController', 'changeStatus');
INSERT INTO `sys_operate_log` VALUES (2256, 'admin', '/monitor/job/changeStatus', 'PUT', '修改任务状态', '127.0.0.1', '内网IP|内网IP', 107, '2025-04-27 09:42:57', '{\"job\":{\"jobId\":2,\"status\":\"1\"}}', 'com.mojian.controller.SysJobController', 'changeStatus');
INSERT INTO `sys_operate_log` VALUES (2257, 'admin', '/monitor/job/changeStatus', 'PUT', '修改任务状态', '127.0.0.1', '内网IP|内网IP', 106, '2025-04-27 09:42:58', '{\"job\":{\"jobId\":3,\"status\":\"1\"}}', 'com.mojian.controller.SysJobController', 'changeStatus');
INSERT INTO `sys_operate_log` VALUES (2258, 'admin', '/monitor/job', 'POST', '新增定时任务', '127.0.0.1', '内网IP|内网IP', 123, '2025-04-27 09:51:54', '{\"job\":{\"jobId\":11,\"jobName\":\"test\",\"jobGroup\":\"DEFAULT\",\"invokeTarget\":\"neatTask.neatParams(\'neat\')\",\"cronExpression\":\"0/15 * * * * ? *\",\"misfirePolicy\":\"3\",\"concurrent\":\"1\",\"status\":\"1\"}}', 'com.mojian.controller.SysJobController', 'add');
INSERT INTO `sys_operate_log` VALUES (2259, 'admin', '/monitor/job', 'PUT', '修改定时任务', '127.0.0.1', '内网IP|内网IP', 134, '2025-04-27 09:52:31', '{\"job\":{\"jobId\":11,\"jobName\":\"test\",\"jobGroup\":\"DEFAULT\",\"invokeTarget\":\"task.neatNoParams\",\"cronExpression\":\"0/15 * * * * ? *\",\"misfirePolicy\":\"3\",\"concurrent\":\"1\",\"status\":\"1\"}}', 'com.mojian.controller.SysJobController', 'edit');
INSERT INTO `sys_operate_log` VALUES (2260, 'admin', '/monitor/job', 'POST', '新增定时任务', '127.0.0.1', '内网IP|内网IP', 114, '2025-04-27 09:53:43', '{\"job\":{\"jobId\":12,\"jobName\":\"定时更新阅读量\",\"jobGroup\":\"DEFAULT\",\"invokeTarget\":\"task.syncQuantity\",\"cronExpression\":\"0 0 0 * * ? *\",\"misfirePolicy\":\"1\",\"concurrent\":\"1\",\"status\":\"1\"}}', 'com.mojian.controller.SysJobController', 'add');
INSERT INTO `sys_operate_log` VALUES (2261, 'admin', '/sys/role/menus/1', 'PUT', '修改角色权限', '127.0.0.1', '内网IP|内网IP', 217, '2025-04-27 13:01:54', '{\"id\":1,\"menuIds\":[68,71,75,76,79,77,78,103,69,80,81,82,83,70,84,85,86,87,110,111,112,113,72,74,88,89,114,115,116,117,118,119,120,121,122,73,90,91,92,93,123,124,125,126,127,96,97,98,99,100,101,102,106,107,108,109,1,14,39,27,28,29,52,2,3,8,40,41,43,9,10,53,11,12,44,136,137,138,139,140,13,48,51,49,50,32,33,55,56,128,129,130,131,54,4,16,17,95,94,18,60,62,65,59,58,61,19,63,66,64,67,104,105,30,31,34]}', 'com.mojian.controller.system.SysRoleController', 'updateRoleMenus');
INSERT INTO `sys_operate_log` VALUES (2262, 'admin', '/sys/role/menus/14', 'PUT', '修改角色权限', '127.0.0.1', '内网IP|内网IP', 160, '2025-04-27 18:13:31', '{\"id\":14,\"menuIds\":[68,71,75,69,80,70,84,72,74,88,73,90,96,97,98,100,101,1,14,39,2,3,9,53,13,51,32,33,55,54,4,16,17,95,18,58,19,66,67,104,30,31,34]}', 'com.mojian.controller.system.SysRoleController', 'updateRoleMenus');
INSERT INTO `sys_operate_log` VALUES (2263, 'admin', '/sys/user', 'PUT', '修改用户', '127.0.0.1', '内网IP|内网IP', 317, '2025-04-27 22:06:51', '{\"user\":{\"user\":{\"id\":1811,\"username\":\"111\",\"status\":1,\"ip\":\"127.0.0.1\",\"ipLocation\":\"内网IP|内网IP\",\"lastLoginTime\":1745735739000,\"nickname\":\"111\",\"mobile\":\"\",\"email\":\"\",\"sex\":0,\"createTime\":1745715886000,\"updateTime\":1745762812700},\"roleIds\":[14]}}', 'com.mojian.controller.system.SysUserController', 'update');
INSERT INTO `sys_operate_log` VALUES (2264, 'admin', '/sys/role', 'PUT', '修改角色', '127.0.0.1', '内网IP|内网IP', 87, '2025-04-27 22:07:23', '{\"role\":{\"id\":20,\"code\":\"1\",\"name\":\"11\",\"remarks\":\"1\",\"createTime\":1731731340000,\"updateTime\":1731731340000}}', 'com.mojian.controller.system.SysRoleController', 'updateRole');
INSERT INTO `sys_operate_log` VALUES (2265, 'admin', '/sys/user/updProfile', 'PUT', '修改个人信息', '127.0.0.1', '内网IP|内网IP', 47, '2025-04-27 22:07:40', '{\"user\":{\"id\":1,\"nickname\":\"码云星链\",\"mobile\":\"18016724816\",\"email\":\"2180323848@qq.com\",\"sex\":1,\"updateTime\":1745762861766}}', 'com.mojian.controller.system.SysUserController', 'updateProfile');
INSERT INTO `sys_operate_log` VALUES (2266, 'admin', '/monitor/job/changeStatus', 'PUT', '修改任务状态', '27.148.48.195', '中国|福建省|福州市|电信', 56, '2025-05-29 17:56:05', '{\"job\":{\"jobId\":2,\"status\":\"0\"}}', 'com.mojian.controller.SysJobController', 'changeStatus');
INSERT INTO `sys_operate_log` VALUES (2267, 'admin', '/monitor/job/changeStatus', 'PUT', '修改任务状态', '27.148.48.195', '中国|福建省|福州市|电信', 53, '2025-05-29 17:56:05', '{\"job\":{\"jobId\":1,\"status\":\"0\"}}', 'com.mojian.controller.SysJobController', 'changeStatus');
INSERT INTO `sys_operate_log` VALUES (2268, 'admin', '/monitor/job/changeStatus', 'PUT', '修改任务状态', '27.148.48.195', '中国|福建省|福州市|电信', 49, '2025-05-29 17:56:06', '{\"job\":{\"jobId\":1,\"status\":\"1\"}}', 'com.mojian.controller.SysJobController', 'changeStatus');
INSERT INTO `sys_operate_log` VALUES (2269, 'admin', '/monitor/job/changeStatus', 'PUT', '修改任务状态', '27.148.48.195', '中国|福建省|福州市|电信', 48, '2025-05-29 17:56:06', '{\"job\":{\"jobId\":2,\"status\":\"1\"}}', 'com.mojian.controller.SysJobController', 'changeStatus');

-- ----------------------------
-- Table structure for sys_photo
-- ----------------------------
DROP TABLE IF EXISTS `sys_photo`;
CREATE TABLE `sys_photo`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `album_id` bigint NOT NULL COMMENT '相册id',
  `description` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '图片描述',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '图片地址',
  `record_time` date NULL DEFAULT NULL COMMENT '记录时间',
  `sort` int NULL DEFAULT NULL COMMENT '排序',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '照片' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_photo
-- ----------------------------
INSERT INTO `sys_photo` VALUES (2, 7, '1', 'img/logo.jpeg', NULL, 1, '2025-04-26 21:59:41');
INSERT INTO `sys_photo` VALUES (3, 7, '2', 'img/logo.jpeg', NULL, 1, '2025-04-26 22:00:33');
INSERT INTO `sys_photo` VALUES (4, 7, 'caoshen\n', 'img/logo.jpeg', '2025-04-26', 1, '2025-04-26 22:07:59');

-- ----------------------------
-- Table structure for sys_resource
-- ----------------------------
DROP TABLE IF EXISTS `sys_resource`;
CREATE TABLE `sys_resource`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` bigint NOT NULL COMMENT '用户id',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '资源名',
  `category` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '分类',
  `downloads` int NULL DEFAULT NULL COMMENT '下载量',
  `is_free` int NULL DEFAULT NULL COMMENT '是否免费',
  `pay_type` int NULL DEFAULT NULL COMMENT '付费方式',
  `pan_path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '网盘地址',
  `pan_code` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '网盘验证码',
  `status` int NULL DEFAULT NULL COMMENT '状态',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '资源表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_resource
-- ----------------------------

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `code` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '角色编码',
  `name` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '角色名称',
  `remarks` varchar(500) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '角色描述',
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 21 CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci COMMENT = '角色表 ' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES (1, 'admin', '超级管理员', '拥有一切权限\n', '2024-11-16 12:29:00', '2024-11-16 12:29:00');
INSERT INTO `sys_role` VALUES (14, 'demo', '演示账号', '仅提供演示用，所有按钮权限可看到但不能操作', '2024-11-21 22:59:30', '2024-11-21 22:59:29');
INSERT INTO `sys_role` VALUES (15, 'user', '用户', '门户注册的用户', '2024-12-28 13:32:09', '2024-12-28 13:32:08');
INSERT INTO `sys_role` VALUES (20, '1', '11', '1', '2024-11-16 12:29:00', '2024-11-16 12:29:00');

-- ----------------------------
-- Table structure for sys_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role_id` int NULL DEFAULT NULL COMMENT '角色ID',
  `menu_id` int NULL DEFAULT NULL COMMENT '菜单ID',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `role_id`(`role_id` ASC, `menu_id` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 553 CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci COMMENT = '角色-权限资源关联表 ' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES (450, 1, 1);
INSERT INTO `sys_role_menu` VALUES (457, 1, 2);
INSERT INTO `sys_role_menu` VALUES (458, 1, 3);
INSERT INTO `sys_role_menu` VALUES (488, 1, 4);
INSERT INTO `sys_role_menu` VALUES (459, 1, 8);
INSERT INTO `sys_role_menu` VALUES (463, 1, 9);
INSERT INTO `sys_role_menu` VALUES (464, 1, 10);
INSERT INTO `sys_role_menu` VALUES (466, 1, 11);
INSERT INTO `sys_role_menu` VALUES (467, 1, 12);
INSERT INTO `sys_role_menu` VALUES (474, 1, 13);
INSERT INTO `sys_role_menu` VALUES (451, 1, 14);
INSERT INTO `sys_role_menu` VALUES (489, 1, 16);
INSERT INTO `sys_role_menu` VALUES (490, 1, 17);
INSERT INTO `sys_role_menu` VALUES (493, 1, 18);
INSERT INTO `sys_role_menu` VALUES (500, 1, 19);
INSERT INTO `sys_role_menu` VALUES (453, 1, 27);
INSERT INTO `sys_role_menu` VALUES (454, 1, 28);
INSERT INTO `sys_role_menu` VALUES (455, 1, 29);
INSERT INTO `sys_role_menu` VALUES (507, 1, 30);
INSERT INTO `sys_role_menu` VALUES (508, 1, 31);
INSERT INTO `sys_role_menu` VALUES (479, 1, 32);
INSERT INTO `sys_role_menu` VALUES (480, 1, 33);
INSERT INTO `sys_role_menu` VALUES (509, 1, 34);
INSERT INTO `sys_role_menu` VALUES (452, 1, 39);
INSERT INTO `sys_role_menu` VALUES (460, 1, 40);
INSERT INTO `sys_role_menu` VALUES (461, 1, 41);
INSERT INTO `sys_role_menu` VALUES (462, 1, 43);
INSERT INTO `sys_role_menu` VALUES (468, 1, 44);
INSERT INTO `sys_role_menu` VALUES (475, 1, 48);
INSERT INTO `sys_role_menu` VALUES (477, 1, 49);
INSERT INTO `sys_role_menu` VALUES (478, 1, 50);
INSERT INTO `sys_role_menu` VALUES (476, 1, 51);
INSERT INTO `sys_role_menu` VALUES (456, 1, 52);
INSERT INTO `sys_role_menu` VALUES (465, 1, 53);
INSERT INTO `sys_role_menu` VALUES (487, 1, 54);
INSERT INTO `sys_role_menu` VALUES (481, 1, 55);
INSERT INTO `sys_role_menu` VALUES (482, 1, 56);
INSERT INTO `sys_role_menu` VALUES (498, 1, 58);
INSERT INTO `sys_role_menu` VALUES (497, 1, 59);
INSERT INTO `sys_role_menu` VALUES (494, 1, 60);
INSERT INTO `sys_role_menu` VALUES (499, 1, 61);
INSERT INTO `sys_role_menu` VALUES (495, 1, 62);
INSERT INTO `sys_role_menu` VALUES (501, 1, 63);
INSERT INTO `sys_role_menu` VALUES (503, 1, 64);
INSERT INTO `sys_role_menu` VALUES (496, 1, 65);
INSERT INTO `sys_role_menu` VALUES (502, 1, 66);
INSERT INTO `sys_role_menu` VALUES (504, 1, 67);
INSERT INTO `sys_role_menu` VALUES (394, 1, 68);
INSERT INTO `sys_role_menu` VALUES (402, 1, 69);
INSERT INTO `sys_role_menu` VALUES (407, 1, 70);
INSERT INTO `sys_role_menu` VALUES (395, 1, 71);
INSERT INTO `sys_role_menu` VALUES (416, 1, 72);
INSERT INTO `sys_role_menu` VALUES (429, 1, 73);
INSERT INTO `sys_role_menu` VALUES (417, 1, 74);
INSERT INTO `sys_role_menu` VALUES (396, 1, 75);
INSERT INTO `sys_role_menu` VALUES (397, 1, 76);
INSERT INTO `sys_role_menu` VALUES (399, 1, 77);
INSERT INTO `sys_role_menu` VALUES (400, 1, 78);
INSERT INTO `sys_role_menu` VALUES (398, 1, 79);
INSERT INTO `sys_role_menu` VALUES (403, 1, 80);
INSERT INTO `sys_role_menu` VALUES (404, 1, 81);
INSERT INTO `sys_role_menu` VALUES (405, 1, 82);
INSERT INTO `sys_role_menu` VALUES (406, 1, 83);
INSERT INTO `sys_role_menu` VALUES (408, 1, 84);
INSERT INTO `sys_role_menu` VALUES (409, 1, 85);
INSERT INTO `sys_role_menu` VALUES (410, 1, 86);
INSERT INTO `sys_role_menu` VALUES (411, 1, 87);
INSERT INTO `sys_role_menu` VALUES (418, 1, 88);
INSERT INTO `sys_role_menu` VALUES (419, 1, 89);
INSERT INTO `sys_role_menu` VALUES (430, 1, 90);
INSERT INTO `sys_role_menu` VALUES (431, 1, 91);
INSERT INTO `sys_role_menu` VALUES (432, 1, 92);
INSERT INTO `sys_role_menu` VALUES (433, 1, 93);
INSERT INTO `sys_role_menu` VALUES (492, 1, 94);
INSERT INTO `sys_role_menu` VALUES (491, 1, 95);
INSERT INTO `sys_role_menu` VALUES (439, 1, 96);
INSERT INTO `sys_role_menu` VALUES (440, 1, 97);
INSERT INTO `sys_role_menu` VALUES (441, 1, 98);
INSERT INTO `sys_role_menu` VALUES (442, 1, 99);
INSERT INTO `sys_role_menu` VALUES (443, 1, 100);
INSERT INTO `sys_role_menu` VALUES (444, 1, 101);
INSERT INTO `sys_role_menu` VALUES (445, 1, 102);
INSERT INTO `sys_role_menu` VALUES (401, 1, 103);
INSERT INTO `sys_role_menu` VALUES (505, 1, 104);
INSERT INTO `sys_role_menu` VALUES (506, 1, 105);
INSERT INTO `sys_role_menu` VALUES (446, 1, 106);
INSERT INTO `sys_role_menu` VALUES (447, 1, 107);
INSERT INTO `sys_role_menu` VALUES (448, 1, 108);
INSERT INTO `sys_role_menu` VALUES (449, 1, 109);
INSERT INTO `sys_role_menu` VALUES (412, 1, 110);
INSERT INTO `sys_role_menu` VALUES (413, 1, 111);
INSERT INTO `sys_role_menu` VALUES (414, 1, 112);
INSERT INTO `sys_role_menu` VALUES (415, 1, 113);
INSERT INTO `sys_role_menu` VALUES (420, 1, 114);
INSERT INTO `sys_role_menu` VALUES (421, 1, 115);
INSERT INTO `sys_role_menu` VALUES (422, 1, 116);
INSERT INTO `sys_role_menu` VALUES (423, 1, 117);
INSERT INTO `sys_role_menu` VALUES (424, 1, 118);
INSERT INTO `sys_role_menu` VALUES (425, 1, 119);
INSERT INTO `sys_role_menu` VALUES (426, 1, 120);
INSERT INTO `sys_role_menu` VALUES (427, 1, 121);
INSERT INTO `sys_role_menu` VALUES (428, 1, 122);
INSERT INTO `sys_role_menu` VALUES (434, 1, 123);
INSERT INTO `sys_role_menu` VALUES (435, 1, 124);
INSERT INTO `sys_role_menu` VALUES (436, 1, 125);
INSERT INTO `sys_role_menu` VALUES (437, 1, 126);
INSERT INTO `sys_role_menu` VALUES (438, 1, 127);
INSERT INTO `sys_role_menu` VALUES (483, 1, 128);
INSERT INTO `sys_role_menu` VALUES (484, 1, 129);
INSERT INTO `sys_role_menu` VALUES (485, 1, 130);
INSERT INTO `sys_role_menu` VALUES (486, 1, 131);
INSERT INTO `sys_role_menu` VALUES (469, 1, 136);
INSERT INTO `sys_role_menu` VALUES (470, 1, 137);
INSERT INTO `sys_role_menu` VALUES (471, 1, 138);
INSERT INTO `sys_role_menu` VALUES (472, 1, 139);
INSERT INTO `sys_role_menu` VALUES (473, 1, 140);
INSERT INTO `sys_role_menu` VALUES (28, 2, 1);
INSERT INTO `sys_role_menu` VALUES (29, 2, 2);
INSERT INTO `sys_role_menu` VALUES (25, 2, 4);
INSERT INTO `sys_role_menu` VALUES (26, 2, 6);
INSERT INTO `sys_role_menu` VALUES (27, 2, 7);
INSERT INTO `sys_role_menu` VALUES (30, 2, 8);
INSERT INTO `sys_role_menu` VALUES (527, 14, 1);
INSERT INTO `sys_role_menu` VALUES (530, 14, 2);
INSERT INTO `sys_role_menu` VALUES (531, 14, 3);
INSERT INTO `sys_role_menu` VALUES (540, 14, 4);
INSERT INTO `sys_role_menu` VALUES (532, 14, 9);
INSERT INTO `sys_role_menu` VALUES (534, 14, 13);
INSERT INTO `sys_role_menu` VALUES (528, 14, 14);
INSERT INTO `sys_role_menu` VALUES (541, 14, 16);
INSERT INTO `sys_role_menu` VALUES (542, 14, 17);
INSERT INTO `sys_role_menu` VALUES (544, 14, 18);
INSERT INTO `sys_role_menu` VALUES (546, 14, 19);
INSERT INTO `sys_role_menu` VALUES (550, 14, 30);
INSERT INTO `sys_role_menu` VALUES (551, 14, 31);
INSERT INTO `sys_role_menu` VALUES (536, 14, 32);
INSERT INTO `sys_role_menu` VALUES (537, 14, 33);
INSERT INTO `sys_role_menu` VALUES (552, 14, 34);
INSERT INTO `sys_role_menu` VALUES (529, 14, 39);
INSERT INTO `sys_role_menu` VALUES (535, 14, 51);
INSERT INTO `sys_role_menu` VALUES (533, 14, 53);
INSERT INTO `sys_role_menu` VALUES (539, 14, 54);
INSERT INTO `sys_role_menu` VALUES (538, 14, 55);
INSERT INTO `sys_role_menu` VALUES (545, 14, 58);
INSERT INTO `sys_role_menu` VALUES (547, 14, 66);
INSERT INTO `sys_role_menu` VALUES (548, 14, 67);
INSERT INTO `sys_role_menu` VALUES (510, 14, 68);
INSERT INTO `sys_role_menu` VALUES (513, 14, 69);
INSERT INTO `sys_role_menu` VALUES (515, 14, 70);
INSERT INTO `sys_role_menu` VALUES (511, 14, 71);
INSERT INTO `sys_role_menu` VALUES (517, 14, 72);
INSERT INTO `sys_role_menu` VALUES (520, 14, 73);
INSERT INTO `sys_role_menu` VALUES (518, 14, 74);
INSERT INTO `sys_role_menu` VALUES (512, 14, 75);
INSERT INTO `sys_role_menu` VALUES (514, 14, 80);
INSERT INTO `sys_role_menu` VALUES (516, 14, 84);
INSERT INTO `sys_role_menu` VALUES (519, 14, 88);
INSERT INTO `sys_role_menu` VALUES (521, 14, 90);
INSERT INTO `sys_role_menu` VALUES (543, 14, 95);
INSERT INTO `sys_role_menu` VALUES (522, 14, 96);
INSERT INTO `sys_role_menu` VALUES (523, 14, 97);
INSERT INTO `sys_role_menu` VALUES (524, 14, 98);
INSERT INTO `sys_role_menu` VALUES (525, 14, 100);
INSERT INTO `sys_role_menu` VALUES (526, 14, 101);
INSERT INTO `sys_role_menu` VALUES (549, 14, 104);

-- ----------------------------
-- Table structure for sys_tag
-- ----------------------------
DROP TABLE IF EXISTS `sys_tag`;
CREATE TABLE `sys_tag`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '名称',
  `sort` int NULL DEFAULT NULL COMMENT '排序',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 206 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '标签表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_tag
-- ----------------------------
INSERT INTO `sys_tag` VALUES (1, 'Spring Boot', 20, '2021-11-12 14:43:27', '2023-06-05 03:00:00');
INSERT INTO `sys_tag` VALUES (12, 'Vue', 18, '2021-12-29 14:01:50', '2023-06-05 03:00:00');
INSERT INTO `sys_tag` VALUES (13, 'Spring Cloud', 19, '2021-12-29 14:02:32', '2023-06-05 03:00:00');
INSERT INTO `sys_tag` VALUES (18, 'Linux', 10, '2022-01-25 14:09:17', '2023-06-05 03:00:00');
INSERT INTO `sys_tag` VALUES (31, 'Mysql', 10, '2022-02-18 16:01:07', '2023-06-05 03:00:00');
INSERT INTO `sys_tag` VALUES (32, 'Nginx', 5, '2022-04-13 17:48:08', '2023-06-05 03:00:00');
INSERT INTO `sys_tag` VALUES (57, 'Java Script', 1, '2023-06-27 16:02:33', '2023-06-27 08:02:32');
INSERT INTO `sys_tag` VALUES (59, 'Dcoker', 12, '2023-07-13 15:51:12', '2023-07-13 07:51:12');
INSERT INTO `sys_tag` VALUES (62, 'oauth2', 0, '2023-08-15 09:30:12', '2023-08-15 01:30:11');
INSERT INTO `sys_tag` VALUES (63, '服务器', 0, '2023-09-05 17:28:08', '2023-09-05 09:28:07');
INSERT INTO `sys_tag` VALUES (109, '深度学习', NULL, '2025-04-28 16:45:42', NULL);
INSERT INTO `sys_tag` VALUES (110, '大模型应用', NULL, '2025-04-28 16:45:42', NULL);
INSERT INTO `sys_tag` VALUES (111, 'RAG', NULL, '2025-04-28 16:45:43', NULL);
INSERT INTO `sys_tag` VALUES (112, 'DeepSeek', NULL, '2025-04-28 16:45:43', NULL);
INSERT INTO `sys_tag` VALUES (116, 'Python之路', NULL, '2025-04-28 16:46:23', NULL);
INSERT INTO `sys_tag` VALUES (117, '计算机视觉', NULL, '2025-04-28 16:46:23', NULL);
INSERT INTO `sys_tag` VALUES (118, '机器学习', NULL, '2025-04-28 16:46:23', NULL);
INSERT INTO `sys_tag` VALUES (119, 'opencv', NULL, '2025-04-28 16:46:23', NULL);
INSERT INTO `sys_tag` VALUES (120, '算法分析', NULL, '2025-04-28 16:47:04', NULL);
INSERT INTO `sys_tag` VALUES (134, 'AI', NULL, '2025-04-28 16:52:50', NULL);
INSERT INTO `sys_tag` VALUES (135, '智能体', NULL, '2025-04-28 16:52:50', NULL);
INSERT INTO `sys_tag` VALUES (136, 'c语言', NULL, '2025-04-28 16:53:21', NULL);
INSERT INTO `sys_tag` VALUES (140, 'prometheus', NULL, '2025-04-28 17:10:14', NULL);
INSERT INTO `sys_tag` VALUES (144, '运维监控', NULL, '2025-04-28 17:10:15', NULL);
INSERT INTO `sys_tag` VALUES (145, '业务接口', NULL, '2025-04-28 17:10:15', NULL);
INSERT INTO `sys_tag` VALUES (158, 'mybatis', NULL, '2025-04-28 17:18:17', NULL);
INSERT INTO `sys_tag` VALUES (159, '测试开发和测试', NULL, '2025-04-28 17:18:54', NULL);
INSERT INTO `sys_tag` VALUES (161, 'Python', NULL, '2025-04-28 17:18:54', NULL);
INSERT INTO `sys_tag` VALUES (162, '质量效能', NULL, '2025-04-28 17:18:55', NULL);
INSERT INTO `sys_tag` VALUES (163, '智能化测试', NULL, '2025-04-28 17:18:55', NULL);
INSERT INTO `sys_tag` VALUES (166, 'ocr', NULL, '2025-04-28 17:19:21', NULL);
INSERT INTO `sys_tag` VALUES (167, '大数据', NULL, '2025-04-28 17:19:21', NULL);
INSERT INTO `sys_tag` VALUES (168, '图像识别', NULL, '2025-04-28 17:19:21', NULL);
INSERT INTO `sys_tag` VALUES (169, '图表解析', NULL, '2025-04-28 17:19:21', NULL);
INSERT INTO `sys_tag` VALUES (173, 'visual studio', NULL, '2025-04-28 17:19:57', NULL);

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `username` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '账号',
  `password` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '登录密码',
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  `status` int NULL DEFAULT 1 COMMENT '状态 0:禁用 1:正常',
  `ip` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT 'ip地址',
  `ip_location` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `os` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '登录系统',
  `last_login_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后登录时间',
  `browser` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `nickname` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '头像',
  `mobile` varchar(15) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `email` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL,
  `sex` int NULL DEFAULT NULL COMMENT '性别',
  `login_type` varchar(20) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '登录方式',
  `signature` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL COMMENT '个性签名',
  `type` int NULL DEFAULT NULL COMMENT '登录方式',
  `balance` int(10) UNSIGNED ZEROFILL NOT NULL DEFAULT 0000000000 COMMENT '账户余额',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1812 CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci COMMENT = '用户信息表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES (1, 'admin', '$2a$10$WqeDDkDqtMaG3RTxQnDPIuFHN7H.YzOE3lni14.VEeuF5PUzXpY2m', '2024-12-27 14:16:17', '2025-04-28 10:10:51', 1, '192.168.0.108', '内网IP|内网IP', 'Windows', '2025-06-25 18:56:42', 'Chrome', '码云星链', 'https://ss0.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1152107840,119779555&fm=253&gp=0.jpg', '18016724816', '1964960588@qq.com', 1, 'email', NULL, NULL, 0000000000);
INSERT INTO `sys_user` VALUES (1811, '111', '$2a$10$94dFQCE8plWmP5YKrFr19OkcsxpkbiPZi8yWQhfAlQHU1zCZv36bS', '2025-04-27 09:04:46', '2025-04-28 17:54:21', 1, '127.0.0.1', '内网IP|内网IP', 'Windows', '2025-04-30 14:18:15', 'Chrome', '111', 'http://127.0.0.1:8800/localFile/local-plus/20250428/avatar/85_avatar.jpg', '', '2180323848@qq.com', 0, NULL, NULL, NULL, 0000000000);

-- ----------------------------
-- Table structure for sys_user_pay
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_pay`;
CREATE TABLE `sys_user_pay`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `user_id` bigint NOT NULL COMMENT '用户ID',
  `article_id` bigint NOT NULL COMMENT '文章ID',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_user_id`(`user_id` ASC) USING BTREE,
  INDEX `idx_article_id`(`article_id` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '付费文章关联表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user_pay
-- ----------------------------
INSERT INTO `sys_user_pay` VALUES (1, 1, 292);
INSERT INTO `sys_user_pay` VALUES (2, 1, 296);

-- ----------------------------
-- Table structure for sys_user_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role_id` int NULL DEFAULT NULL COMMENT '角色ID',
  `user_id` int NULL DEFAULT NULL COMMENT '用户ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 57 CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci COMMENT = '系统管理 - 用户角色关联表 ' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user_role
-- ----------------------------
INSERT INTO `sys_user_role` VALUES (42, 14, 9);
INSERT INTO `sys_user_role` VALUES (44, 14, 1810);
INSERT INTO `sys_user_role` VALUES (51, 1, 1);
INSERT INTO `sys_user_role` VALUES (56, 1, 1811);

-- ----------------------------
-- Table structure for sys_web_config
-- ----------------------------
DROP TABLE IF EXISTS `sys_web_config`;
CREATE TABLE `sys_web_config`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `logo` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'logo(文件UID)',
  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '网站名称',
  `summary` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '介绍',
  `record_num` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '备案号',
  `web_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '网站地址',
  `author` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '作者',
  `author_info` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '个性签名',
  `author_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '作者头像',
  `ali_pay` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '支付宝收款码',
  `weixin_pay` varchar(150) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '微信收款码',
  `github` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'github地址',
  `gitee` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'gitee地址',
  `qq_number` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'QQ号',
  `qq_group` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'QQ群',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱',
  `wechat` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '微信',
  `show_list` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '显示的列表（用于控制邮箱、QQ、QQ群、Github、Gitee、微信是否显示在前端）',
  `login_type_list` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '登录方式列表（用于控制前端登录方式，如账号密码,码云,Github,QQ,微信）',
  `open_comment` tinyint(1) NOT NULL DEFAULT 1 COMMENT '是否开启评论(0:否 1:是)',
  `open_admiration` tinyint(1) NOT NULL DEFAULT 1 COMMENT '是否开启赞赏(0:否， 1:是)',
  `tourist_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '游客头像',
  `about_me` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '关于我',
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  `open_lantern` int NULL DEFAULT NULL COMMENT '开启灯笼',
  `bulletin` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '网站配置表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_web_config
-- ----------------------------
INSERT INTO `sys_web_config` VALUES (1, 'img/logo.jpeg', '码云星链', '一个专注于技术分享的博客平台', '', 'https://gitee.com/tticw/code-cloud-star-chain.git', '码云星链', '遇事不决，可问春风', 'https://api.dicebear.com/7.x/avataaars/svg?seed=Felix', 'http://127.0.0.1:80/localFile/local-plus/20250427/default/91_屏幕截图 2025-04-14 224717.png', 'http://127.0.0.1:80/localFile/local-plus/20250427/default/00_屏幕截图 2025-01-22 004145.png', 'https://gitee.com/brony', 'https://gitee.com/brony', '1248954763', '779881756', '1248954763@qq.com', '1248954763', '[\"qq\",\"wechat\",\"gitee\",\"qqGroup\",\"github\",\"email\"]', '[\"gitee\",\"qq\",\"wechat\"]', 1, 1, 'https://api.dicebear.com/7.x/avataaars/svg?seed=Guest', '<h3>网站简介</h3><p> &nbsp; &nbsp; &nbsp; &nbsp;码云星链是一个博客平台，旨在提供技术分享与开发记录。网站定位于前后端技术交流，并集成了多种现代开发工具，以便开发者学习和使用。</p><h3>网站的创建背景、目的和定位</h3><p> &nbsp; &nbsp; &nbsp; &nbsp;码云星链的创建初衷是为开发者提供一个可以记录、交流和学习技术的平台。它主要聚焦于前后端开发技术，并支持多种功能，如第三方登录、动态权限管理等，以优化用户体验。</p><h3>网站的主要内容或主题</h3><p> &nbsp; &nbsp; &nbsp; &nbsp;网站主要围绕技术分享展开，涵盖博客发布、技术探讨、代码高亮、搜索优化、前后端分离等内容，同时还支持第三方授权登录，提升用户访问便捷度。</p><p><br></p><h3>网站历史</h3><p><strong>创建时间：2025年4月27日 发展历程：网站持续迭代更新，并且支持Markdown编辑器、弹幕留言、RBAC权限管理等功能，以提升用户体验。 重要里程碑：</strong></p><ul><li>增加推荐文章功能，提高内容曝光度。</li><li>集成AOP日志管理，实现动态权限修改。</li><li>提供博客群聊功能，支持发送表情、图片、文件等。</li></ul><p><br></p><h3>技术栈</h3><p><strong>前端技术：</strong></p><ul><li>门户：Vue 2.0 + Vuex + Vue Router + Axios + Element UI</li><li>后台管理系统：Vue 3.0 + Pinia + Vue Router + Axios + Element Plus + ECharts</li></ul><p><strong>后端技术：</strong></p><ul><li>Spring Boot + Nginx + Docker + Sa-Token + Swagger2 + MyBatis Plus + MySQL + Redis + Elasticsearch</li></ul><p><strong>部署方式：</strong></p><ul><li>服务器：腾讯云2核4G CentOS7.6</li><li>对象存储：七牛云OSS</li><li>可调整配置以适应不同服务器环境</li></ul><p><br></p><h3>版权声明</h3><p> &nbsp; &nbsp; &nbsp; &nbsp;网站内容的版权归属码云星链所有。 允许转载和引用，但需注明来源，并遵守开源协议要求。</p><p><br></p><h3>隐私政策</h3><p><strong>网站会对用户数据进行收集和存储，主要用于分析访问情况和优化用户体验。 使用的第三方服务：</strong></p><ul><li>统计工具：集成ElasticSearch提高搜索体验</li><li>对象存储：七牛云OSS</li><li>账户管理：支持QQ、码云、微信公众号授权登录</li></ul><p><br></p><h3>鸣谢</h3><p>网站依赖多个开源项目，如：</p><ul><li>Vue、Spring Boot、MyBatis Plus、Redis</li><li>七牛云存储、Sa-Token权限认证</li></ul><p>感谢社区及开发者的贡献，欢迎提交PR共同改进项目。</p><p><br></p><h3>留言或反馈</h3><p> &nbsp; &nbsp; &nbsp; &nbsp;网站希望持续优化用户体验，并增加更多趣味功能，如访问统计、深色模式、彩蛋展示等。 你可以通过留言或提交代码建议参与改进，让这个博客平台更具活力！🚀</p>', '2024-12-22 11:55:25', '2024-12-22 11:55:25', 0, NULL);

-- ----------------------------
-- Table structure for we_chat_info
-- ----------------------------
DROP TABLE IF EXISTS `we_chat_info`;
CREATE TABLE `we_chat_info`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '微信扫码登录的信息id',
  `openid` varchar(2555) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '微信标识码',
  `nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '微信昵称',
  `headimgurl` varchar(2555) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '微信头像',
  `sex` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '性别',
  `role_id` int NOT NULL DEFAULT 15 COMMENT '角色id(默认为普通用户)',
  `user` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT 'user',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `mobile` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '手机号',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'ip地址',
  `ip_location` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'ip地址',
  `os` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '系统',
  `last_login_time` datetime NULL DEFAULT NULL COMMENT '最后的登录时间',
  `browser` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '1' COMMENT '浏览器引擎',
  `signature` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '个人简介',
  `balance` int NOT NULL DEFAULT 0 COMMENT '账户余额',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `role_id`(`role_id` ASC) USING BTREE,
  CONSTRAINT `role_id` FOREIGN KEY (`role_id`) REFERENCES `sys_role` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of we_chat_info
-- ----------------------------
INSERT INTO `we_chat_info` VALUES (8, 'o2Tn77E5dA67kKNL3idSF14csKgs', '🍑 icw.', 'https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIZmpjibvlwshS7GAWbEjEibsylzByOV1mIZ0eGq4F0caZnicj0YUOuKvofbMI8sXyxmyKDo7xUjFraVNOKYoUPh7lKHA5KDqDzO24GF5Tfe2Vvg/132', '男', 1, 'user', '2025-04-30 11:27:41', NULL, NULL, '36.251.161.15', '中国|福建省|泉州市|联通', 'Linux', '2025-04-30 11:54:10', 'Chrome', NULL, 0);
INSERT INTO `we_chat_info` VALUES (9, 'o2Tn77Ch1uDltxEZJ7SYnQvfdof8', '＃00FF00_HEAD', 'https://thirdwx.qlogo.cn/mmopen/vi_32/FhMSuUga8jGHibXFzqdrwbAKfibAuw9n1Hyc9J01hzM0HdPSEjUoH88cVsuCia4ZNaSOicEEQ5iadgxp8icpL1U27lzQ/132', '男', 1, 'user', '2025-04-30 11:27:42', NULL, NULL, '110.86.216.80', '中国|福建省|厦门市|电信', 'Linux', '2025-04-30 11:56:05', 'Chrome', NULL, 0);
INSERT INTO `we_chat_info` VALUES (10, 'o2Tn77Oz0302gFlPKdPh1oljIGpY', '落.', 'https://thirdwx.qlogo.cn/mmopen/vi_32/2GCf7F9ANPKaDlrcmzmzQ5F8XUMV1xbfxWepZd5CiaHtHPUYqaHAp8304TNMoEMNr6KiaE2RNiblxnSBwOE7QUhGA/132', '男', 15, 'user', '2025-04-30 11:40:13', NULL, NULL, '36.251.161.15', '中国|福建省|泉州市|联通', 'Linux', '2025-04-30 11:57:40', 'Chrome', NULL, 0);

SET FOREIGN_KEY_CHECKS = 1;
